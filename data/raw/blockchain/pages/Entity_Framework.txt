Entity Framework (EF) is an open source object–relational mapping (ORM) framework for ADO.NET. It was originally shipped as an integral part of .NET Framework, however starting with Entity Framework version 6.0 it has been delivered separately from the .NET Framework.
Entity Framework 6.4 was the latest release of the classic framework. Although Entity Framework 6 is still supported, it is no longer being developed and will only receive fixes for security issues.
A new framework known as Entity Framework Core (EF Core) was introduced in 2016 with similar but not complete feature parity. Version numbering of this framework restarted from 1.0.


== Overview ==
The Entity Framework is a set of technologies in ADO.NET that supports the development of data-oriented software applications. Architects and developers of data-oriented applications have typically struggled with the need to achieve two very different objectives. They must model the entities, relationships, and logic of the business problems they are solving, and they must also work with the data engines used to store and retrieve the data. The data can span multiple storage systems, each with its own protocols; even applications that work with a single storage system must balance the requirements of the storage system against the requirements of writing efficient and maintainable application code. This problem is generally referred to as the "object–relational impedance mismatch".
Many object–relational mapping (ORM) tools (aka "object–relational managers") have been developed to enable developers to work with data in the form of domain-specific objects and properties, such as customers and customer addresses, without having to concern themselves with the underlying database tables and columns where this data is stored. With an ORM, developers can work at a higher level of abstraction when they deal with data, and can create and maintain data-oriented applications with less code than in traditional applications. Entity Framework is the ORM solution currently promoted for use within the Microsoft development stack.


== History ==
The first version of Entity Framework (EFv1) was included with .NET Framework 3.5 Service Pack 1 and Visual Studio 2008 Service Pack 1, released on 11 August 2008 (2008-08-11). This version was widely criticized, even attracting a 'vote of no confidence' signed by at least one thousand developers.
The second version of Entity Framework, named Entity Framework 4.0 (EFv4), was released as part of .NET 4.0 on 12 April 2010 and addressed many of the criticisms made of version 1.
A third version of Entity Framework, version 4.1, was released on April 12, 2011, with Code First support.
A refresh of version 4.1, named Entity Framework 4.1 Update 1, was released on July 25, 2011. It includes bug fixes and new supported types.
The version 4.3.1 was released on February 29, 2012. There were a few updates, like support for migration.
Version 5.0.0 was released on August 11, 2012 and is targeted at .NET framework 4.5.
Also, this version is available for .Net framework 4, but without any runtime advantages over version 4.
Version 6.0 was released on October 17, 2013 and is now an open source project licensed under Apache License v2. Like ASP.NET MVC, its source code is hosted at GitHub using Git. This version has a number of improvements for code-first support.
Microsoft then decided to modernize, componentize and bring .NET cross-platform to Linux, OSX and elsewhere, meaning the next version of Entity Framework would be a complete rewrite. On 27 June 2016 this was released as Entity Framework Core 1.0, alongside ASP.NET Core 1.0 and .NET Core 1.0. It was originally named Entity Framework 7, but was renamed to highlight that it was a complete rewrite rather than an incremental upgrade and it doesn't replace EF6.
Entity Framework Core 1.0 is licensed under Apache License v2, and was built entirely in the open on GitHub. While Entity Framework Core 1.0 shares some conceptual similarities with prior versions of Entity Framework, it was a completely new codebase designed to be more efficient, powerful, flexible, and extensible, running on Windows, Linux and OSX, and supporting a new range of relational and NoSQL data stores.
Entity Framework Core 2.0 was released on 14 August 2017 (2017-08-14) along with Visual Studio 2017 15.3 and ASP.NET Core 2.0 
Entity Framework Core 3.0 was released on 23 September 2019 (2019-09-23) along with Visual Studio 2019 16.3 and ASP.NET Core 3.0,
Entity Framework Core 3.1 (EF Core 3.1) was formally released for production use on 3 December 2019 (2019-12-03) and will be the preferred long-term supported version until at least 3 December 2022.
Entity Framework Core 5.0 (EF Core 5) was released for production use on 9 November 2020 (2020-11-09). It was retired and out of support 1.5 years later on May 10, 2022.
Entity Framework Core 6.0 (EF Core 6) was released on 10 November 2021 (2021-11-10) and will be the preferred long-term supported version until at least 12 November 2024.
Entity Framework Core 7.0 (EF Core 7) was released on 8 November 2022 (2022-11-08) adding features such as JSON columns and bulk updates.
Entity Framework Core 8.0 (EF Core 8) was released on 14 November 2023 (2023-11-14) adding features such as Value objects using Complex Types and Primitive collections.


== Architecture ==

The architecture of the ADO.NET Entity Framework, from the bottom up, consists of the following:

Data source specific providers, which abstract the ADO.NET interfaces to connect to the database when programming against the conceptual schema.
Map provider, a database-specific provider that translates the Entity SQL command tree into a query in the native SQL flavor of the database. It includes the Store-specific bridge, which is the component responsible for translating the generic command tree into a store-specific command tree.
EDM parser and view mapping, which takes the SDL specification of the data model and how it maps onto the underlying relational model and enables programming against the conceptual model. From the relational schema, it creates views of the data corresponding to the conceptual model. It aggregates information from multiple tables in order to aggregate them into an entity, and splits an update to an entity into multiple updates to whichever table(s) contributed to that entity.
Query and update pipeline, processes queries, filters and updates requests to convert them into canonical command trees which are then converted into store-specific queries by the map provider.
Metadata services, which handle all metadata related to entities, relationships and mappings.
Transactions, to integrate with transactional capabilities of the underlying store. If the underlying store does not support transactions, support for it needs to be implemented at this layer.
Conceptual layer API, the runtime that exposes the programming model for coding against the conceptual schema. It follows the ADO.NET pattern of using Connection objects to refer to the map provider, using Command objects to send the query, and returning EntityResultSets or EntitySets containing the result.
Disconnected components, which locally cache datasets and entity sets for using the ADO.NET Entity Framework in an occasionally connected environment.
Embedded database: ADO.NET Entity Framework includes a lightweight embedded database for client-side caching and querying of relational data.
Design tools, such as Mapping Designer, are also included with ADO.NET Entity Framework, which simplifies the job of mapping a conceptual schema to the relational schema and specifying which properties of an entity type correspond to which table in the database.
Programming layer, which exposes the EDM as programming constructs which can be consumed by programming languages.
Object services, automatically generate code for CLR classes that expose the same properties as an entity, thus enabling instantiation of entities as .NET objects.
Web services, which expose entities as web services.
High-level services, such as reporting services which work on entities rather than relational data.


== Entity Data Model ==
The Entity Data Model (EDM) specifies the conceptual model (CSDL) of the data, using a modelling technique that is itself called Entity Data Model, an extended version of the entity–relationship model.
The data model primarily describes the Entities and the Associations they participate in. The EDM schema is expressed in the Schema Definition Language (SDL), which is an application of XML (Extended markup language). In addition, the mapping (MSL) of the elements of the conceptual schema (CSDL) to the storage schema (SSDL) must also be specified. The mapping specification is also expressed in XML.

Visual Studio also provides the Entity Designer for visual creation of the EDM and the mapping specification. This approach is named as "Model First" approach, as alternatives to "Code First" and "Database First" approaches. The output of the tool is the XML file (*.edmx) specifying the schema and the mapping. Edmx file contains EF metadata artifacts (CSDL/MSL/SSDL content). These three files (csdl, msl, ssdl) can also be created or edited by hand. The "Model First" approach is not going to be supported in EF Core version.  


=== Mapping ===
Entity Data Model Wizard in Visual Studio initially generates a one-to-one (1:1) mapping between the database schema and the conceptual schema in most of the cases. In the relational schema, the elements are composed of the tables, with the primary and foreign keys gluing the related tables together. In contrast, the Entity Types define the conceptual schema of the data.
The entity types are an aggregation of multiple typed fields – each field maps to a certain column in the database – and can contain information from multiple physical tables. The entity types can be related to each other, independent of the relationships in the physical schema. Related entities are also exposed similarly – via a field whose name denotes the relation they are participating in and accessing which, instead of retrieving the value from some column in the database, traverses the relationship and returns the entity (or a collection of entities) with which it is related.

Entity Types form the class of objects entities conform to, with the Entities being instances of the entity types. Entities represent individual objects that form a part of the problem being solved by the application and are indexed by a key. For example, converting the physical schema described above, we will have two entity types:

CustomerEntity, which contains the customer's name from the Customers table, and the customer's address from the Contacts table.
OrderEntity, which encapsulates the orders of a certain customer, retrieving it from the Orders table.
The logical schema and its mapping with the physical schema is represented as an Entity Data Model (EDM), specified as an XML file. ADO.NET Entity Framework uses the EDM to actually perform the mapping letting the application work with the entities, while internally abstracting the use of ADO.NET constructs like DataSet and RecordSet. ADO.NET Entity Framework performs the joins necessary to have entity reference information from multiple tables, or when a relationship is traversed. When an entity is updated, it traces back which table the information came from and issues SQL update statements to update the tables in which some data has been updated. ADO.NET Entity Framework uses eSQL, a derivative of SQL, to perform queries, set-theoretic operations, and updates on entities and their relationships. Queries in eSQL, if required, are then translated to the native SQL flavor of the underlying database.
Entity types and entity sets just form the logical EDM schema, and can be exposed as anything. ADO.NET Entity Framework includes Object Service that presents these entities as Objects with the elements and relationships exposed as properties. Thus Entity objects are just front-end to the instances of the EDM entity types, which lets Object Oriented languages access and use them. Similarly, other front-ends can be created, which expose the entities via web services (e.g., WCF Data Services) or XML that is used when entities are serialized for persistence storage or over-the-wire transfer.


=== Entities ===
Entities** are instances of EntityTypes; they represent the individual instances of the objects (such as customer, orders) to which the information pertains. The identity of an entity is defined by the entity type it is an instance of; in that sense an entity type defines the class an entity belongs to and also defines what properties an entity will have. Properties describe some aspect of the entity by giving it a name and a type. The properties of an entity type in ADO.NET Entity Framework are fully typed, and are fully compatible with the type system used in a DBMS system, as well as the Common Type System of the .NET Framework. A property can be SimpleType, or ComplexType, and can be multi-valued as well. All EntityTypes belong to some namespace, and have an EntityKey property that uniquely identifies each instance of the entity type. The different property types are distinguished as follows:

SimpleType, corresponds to primitive data types such as Integer, Characters and Floating Point numbers.
ComplexType, is an aggregate of multiple properties of type SimpleType, or ComplexType. Unlike EntityTypes, however, ComplexTypes cannot have an EntityKey. In Entity Framework v1 ComplexTypes cannot be inherited.
All entity instances are housed in EntityContainers, which are per-project containers for entities. Each project has one or more named EntityContainers, which can reference entities across multiple namespaces and entity types. Multiple instances of one entity type can be stored in collections called EntitySets. One entity type can have multiple EntitySets.
EDM primitive types (simple types):


=== Relationships ===
Any two entity types can be related, by either an Association relation or a Containment relation. For example, a shipment is billed to a customer is an association whereas an order contains order details is a containment relation. A containment relation can also be used to model inheritance between entities. The relation between two entity types is specified by a Relationship Type, instances of which, called Relationships, relate entity instances. In future releases, other kinds of relationship types such as Composition, or Identification, may be introduced.
Relationship types are characterized by their degree (arity) or the count of entity types they relate and their multiplicity. However, in the initial release of ADO.NET Entity Framework, relationships are limited to a binary (of degree two) bi-directional relationship. Multiplicity defines how many entity instances can be related together. Based on multiplicity, relationships can be either one-to-one, one-to-many, or many-to-many. Relationships between entities are named; the name is called a Role. It defines the purpose of the relationship.
A relationship type can also have an Operation or Action associated with it, which allows some action to be performed on an entity in the event of an action being performed on a related entity. A relationship can be specified to take an Action when some Operation is done on a related entity. For example, on deleting an entity that forms the part of a relation (the OnDelete operation) the actions that can be taken are:

Cascade, which instructs to delete the relationship instance and all associated entity instances.
None.
For association relationships, which can have different semantics at either ends, different actions can be specified for either end.


=== Schema definition language ===
ADO.NET Entity Framework uses an XML based Data Definition Language called Schema Definition Language (SDL) to define the EDM Schema. The SDL defines the SimpleTypes similar to the CTS primitive types, including String, Int32, Double, Decimal, Guid, and DateTime, among others. An Enumeration, which defines a map of primitive values and names, is also considered a simple type. Enumerations are supported from framework version 5.0 onwards only. ComplexTypes are created from an aggregation of other types. A collection of properties of these types define an Entity Type. This definition can be written in EBNF grammar as:

Facets are used to describe metadata of a property, such as whether it is nullable or has a default value, as also the cardinality of the property, i.e., whether the property is single valued or multi valued. A multiplicity of “1” denotes a single valued property; a “*” means it is a multi-valued property. As an example, an entity can be denoted in SDL as:

A relationship type is defined as specifying the end points and their multiplicities. For example, a one-to-many relationship between Customer and Orders can be defined as


== Querying data ==


=== Entity SQL ===
ADO.NET Entity Framework uses a variant of the Structured Query Language, named Entity SQL, which is aimed at writing declarative queries and updates over entities and entity relationships – at the conceptual level. It differs from SQL in that it does not have explicit constructs for joins because the EDM is designed to abstract partitioning data across tables.
Querying against the conceptual model is facilitated by EntityClient classes, which accepts an Entity SQL query. The query pipeline parses the Entity SQL query into a command tree, segregating the query across multiple tables, which is handed over to the EntityClient provider. Like ADO.NET data providers, an EntityClient provider is also initialized using a Connection object, which in addition to the usual parameters of data store and authentication info, requires the SDL schema and the mapping information. The EntityClient provider in turn then turns the Entity SQL command tree into an SQL query in the native flavor of the database. The execution of the query then returns an Entity SQL ResultSet, which is not limited to a tabular structure, unlike ADO.NET ResultSets.
Entity SQL enhances SQL by adding intrinsic support for:

Types, as ADO.NET entities are fully typed.
EntitySets, which are treated as collections of entities.
Composability, which removes restrictions on where subqueries can be used.


==== Entity SQL canonical functions ====
Canonical functions are supported by all Entity Framework compliant data providers. They can be used in an Entity SQL query. Also, most of the extension methods in LINQ to Entities are translated to canonical functions. They are independent of any specific database. When ADO.NET data provider receives a function, it translates it to the desired SQL statement.
But not all DBMSs have equivalent functionality and a set of standard embedded functions. There are also differences in the accuracy of calculations. Therefore, not all canonical functions are supported for all databases, and not all canonical functions return the same results.


=== LINQ to Entities ===

The LINQ to Entities provider allows LINQ to be used to query various RDBMS data sources. Several database server specific providers with Entity Framework support are available.


=== Native SQL ===
In the Entity Framework v4 new methods ExecuteStoreQuery() and ExecuteStoreCommand() were added to the class ObjectContext.


=== Visualizers ===
Visual Studio has a feature called Visualizer. A LINQ query written in Visual Studio can be viewed as Native SQL using a Visualizer during debug session. A Visualizer for LINQ to Entities (Object Query) targeting all RDBMS is available in the Visual Studio Marketplace.


== Performance Profiling ==
Various profilers are commercially available to troubleshoot performance issues using Entity Framework, both for EF and EF Core variants.


== Tools and extensions - Entity Framework Core ==
Entity Framework Core Tools and Extensions are available to enhance the performance of Entity Framework Core.
EF Core exposes design-time commands for migrations and reverse engineering via the .NET CLI (dotnet ef) and Visual Studio Package Manager Console, which scaffold a DbContext and entity types from an existing database. Beyond the official tooling, IDE integrations provide GUI workflows for common tasks: EF Core Power Tools in Visual Studio adds database-first reverse engineering and model visualization, while Entity Developer offers a visual designer for EF Core that supports database-first and model-first approaches with code generation and mapping configuration.
Similar capabilities are available in other IDEs (e.g., Rider’s UI for EF Core commands), and advanced scenarios can leverage customizable scaffolding templates to control generated code.


== Tools and extensions - Entity Framework EF6 ==
Entity Framework Tools and Extensions are available to enhance the performance of Entity Framework.


== See also ==

List of object–relational mapping software
LINQ to SQL
.NET Persistence API (NPA)
LLBLGEN Pro


== References ==


== Bibliography ==


== External links ==

The ADO.NET Entity Framework (at Data Developer Center)
EntityFramework on GitHub