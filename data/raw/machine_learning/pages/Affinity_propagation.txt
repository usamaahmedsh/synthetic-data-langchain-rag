In statistics and data mining, affinity propagation (AP) is a clustering algorithm based on the concept of "message passing" between data points.
Unlike clustering algorithms such as k-means or k-medoids, affinity propagation does not require the number of clusters to be determined or estimated before running the algorithm. Similar to k-medoids, affinity propagation finds "exemplars," members of the input set that are representative of clusters.


== Algorithm ==
Let x1 through xn be a set of data points, with no assumptions made about their internal structure, and let s be a function that quantifies the similarity between any two points, such that s(i, j) > s(i, k) if and only if xi is more similar to xj than to xk. For this example, the negative squared distance of two data points was used i.e. for points xi and xk, 
  
    
      
        s
        (
        i
        ,
        k
        )
        =
        −
        
          
            ‖
            
              
                x
                
                  i
                
              
              −
              
                x
                
                  k
                
              
            
            ‖
          
          
            2
          
        
      
    
    {\displaystyle s(i,k)=-\left\|x_{i}-x_{k}\right\|^{2}}
  
.
The diagonal of s (i.e. 
  
    
      
        s
        (
        i
        ,
        i
        )
      
    
    {\displaystyle s(i,i)}
  
) is particularly important, as it represents the instance preference, meaning how likely a particular instance is to become an exemplar. When it is set to the same value for all inputs, it controls how many classes the algorithm produces. A value close to the minimum possible similarity produces fewer classes, while a value close to or larger than the maximum possible similarity produces many classes. It is typically initialized to the median similarity of all pairs of inputs.
The algorithm proceeds by alternating between two message-passing steps, which update two matrices:

The "responsibility" matrix R has values r(i, k) that quantify how well-suited xk is to serve as the exemplar for xi, relative to other candidate exemplars for xi.
The "availability" matrix A contains values a(i, k) that represent how "appropriate" it would be for xi to pick xk as its exemplar, taking into account other points' preference for xk as an exemplar.
Both matrices are initialized to all zeroes, and can be viewed as log-probability tables. The algorithm then performs the following updates iteratively:

First, responsibility updates are sent around: 
  
    
      
        r
        (
        i
        ,
        k
        )
        ←
        s
        (
        i
        ,
        k
        )
        −
        
          max
          
            
              k
              ′
            
            ≠
            k
          
        
        
          
            {
            
              a
              (
              i
              ,
              
                k
                ′
              
              )
              +
              s
              (
              i
              ,
              
                k
                ′
              
              )
            
            }
          
        
      
    
    {\displaystyle r(i,k)\gets s(i,k)-\max _{k'\neq k}{\left\{a(i,k')+s(i,k')\right\}}}
  

Then, availability is updated per 
  
    
      
        a
        (
        i
        ,
        k
        )
        ←
        min
        
          
            (
            
              0
              ,
              r
              (
              k
              ,
              k
              )
              +
              
                ∑
                
                  
                    i
                    ′
                  
                  ∉
                  {
                  i
                  ,
                  k
                  }
                
              
              max
              (
              0
              ,
              r
              (
              
                i
                ′
              
              ,
              k
              )
              )
            
            )
          
        
        
        
           for 
        
        i
        ≠
        k
      
    
    {\displaystyle a(i,k)\gets \min {\left(0,r(k,k)+\sum _{i'\not \in \{i,k\}}\max(0,r(i',k))\right)}\quad {\text{ for }}i\neq k}
  
 and 
  
    
      
        a
        (
        k
        ,
        k
        )
        ←
        
          ∑
          
            
              i
              ′
            
            ≠
            k
          
        
        max
        (
        0
        ,
        r
        (
        
          i
          ′
        
        ,
        k
        )
        )
        .
      
    
    {\displaystyle a(k,k)\leftarrow \sum _{i'\neq k}\max(0,r(i',k)).}
  

Iterations are performed until either the cluster boundaries remain unchanged over a number of iterations, or some predetermined number (of iterations) is reached.  The exemplars are extracted from the final matrices as those whose 'responsibility + availability' for themselves is positive (i.e. 
  
    
      
        (
        r
        (
        i
        ,
        i
        )
        +
        a
        (
        i
        ,
        i
        )
        )
        >
        0
      
    
    {\displaystyle (r(i,i)+a(i,i))>0}
  
).


== Applications ==
The inventors of affinity propagation showed it is better for certain computer vision and computational biology tasks, e.g. clustering of pictures of human faces and identifying regulated transcripts, than k-means, even when k-means was allowed many random restarts and initialized using PCA.
A study comparing affinity propagation and Markov clustering on protein interaction graph partitioning found Markov clustering to work better for that problem. A semi-supervised variant has been proposed for text mining applications. Another recent application was in economics, when the affinity propagation was used to find some temporal patterns in the output multipliers of the US economy between 1997 and 2017.


== Software ==
A Java implementation is included in the ELKI data mining framework.
A Julia implementation of affinity propagation is contained in Julia Statistics's Clustering.jl package.
A Python version is part of the scikit-learn library.
An R implementation is available in the "apcluster" package.


== References ==