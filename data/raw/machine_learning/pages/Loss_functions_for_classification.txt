In machine learning and mathematical optimization, loss functions for classification are computationally feasible loss functions representing the price paid for inaccuracy of predictions in classification problems (problems of identifying which category a particular observation belongs to).  Given 
  
    
      
        
          
            X
          
        
      
    
    {\displaystyle {\mathcal {X}}}
  
 as the space of all possible inputs (usually 
  
    
      
        
          
            X
          
        
        ⊂
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle {\mathcal {X}}\subset \mathbb {R} ^{d}}
  
), and 
  
    
      
        
          
            Y
          
        
        =
        {
        −
        1
        ,
        1
        }
      
    
    {\displaystyle {\mathcal {Y}}=\{-1,1\}}
  
 as the set of labels (possible outputs), a typical goal of classification algorithms is to find a function 
  
    
      
        f
        :
        
          
            X
          
        
        →
        
          
            Y
          
        
      
    
    {\displaystyle f:{\mathcal {X}}\to {\mathcal {Y}}}
  
 which best predicts a label 
  
    
      
        y
      
    
    {\displaystyle y}
  
 for a given input 
  
    
      
        
          
            
              x
              →
            
          
        
      
    
    {\displaystyle {\vec {x}}}
  
.  However, because of incomplete information, noise in the measurement, or probabilistic components in the underlying process, it is possible for the same 
  
    
      
        
          
            
              x
              →
            
          
        
      
    
    {\displaystyle {\vec {x}}}
  
 to generate different 
  
    
      
        y
      
    
    {\displaystyle y}
  
.  As a result, the goal of the learning problem is to minimize expected loss (also known as the risk), defined as

  
    
      
        I
        [
        f
        ]
        =
        
          
            ∫
            
              
                
                  X
                
              
              ×
              
                
                  Y
                
              
            
          
          V
          (
          f
          (
          
            
              
                x
                →
              
            
          
          )
          ,
          y
          )
          
          p
          (
          
            
              
                x
                →
              
            
          
          ,
          y
          )
          
          d
          
            
              
                x
                →
              
            
          
          
          d
          y
        
      
    
    {\displaystyle I[f]=\displaystyle \int _{{\mathcal {X}}\times {\mathcal {Y}}}V(f({\vec {x}}),y)\,p({\vec {x}},y)\,d{\vec {x}}\,dy}
  

where 
  
    
      
        V
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        ,
        y
        )
      
    
    {\displaystyle V(f({\vec {x}}),y)}
  
 is a given loss function, and  
  
    
      
        p
        (
        
          
            
              x
              →
            
          
        
        ,
        y
        )
      
    
    {\displaystyle p({\vec {x}},y)}
  
 is the probability density function of the process that generated the data, which can equivalently be written as

  
    
      
        p
        (
        
          
            
              x
              →
            
          
        
        ,
        y
        )
        =
        p
        (
        y
        ∣
        
          
            
              x
              →
            
          
        
        )
        p
        (
        
          
            
              x
              →
            
          
        
        )
        .
      
    
    {\displaystyle p({\vec {x}},y)=p(y\mid {\vec {x}})p({\vec {x}}).}
  

Within classification, several commonly used loss functions are written solely in terms of the product of the true label 
  
    
      
        y
      
    
    {\displaystyle y}
  
 and the predicted label 
  
    
      
        f
        (
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle f({\vec {x}})}
  
. Therefore, they can be defined as functions of only one variable 
  
    
      
        υ
        =
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle \upsilon =yf({\vec {x}})}
  
, so that 
  
    
      
        V
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        ,
        y
        )
        =
        ϕ
        (
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
        =
        ϕ
        (
        υ
        )
      
    
    {\displaystyle V(f({\vec {x}}),y)=\phi (yf({\vec {x}}))=\phi (\upsilon )}
  
 with a suitably chosen function 
  
    
      
        ϕ
        :
        
          R
        
        →
        
          R
        
      
    
    {\displaystyle \phi :\mathbb {R} \to \mathbb {R} }
  
. These are called margin-based loss functions. Choosing a margin-based loss function amounts to choosing 
  
    
      
        ϕ
      
    
    {\displaystyle \phi }
  
. Selection of a loss function within this framework impacts the optimal 
  
    
      
        
          f
          
            ϕ
          
          
            ∗
          
        
      
    
    {\displaystyle f_{\phi }^{*}}
  
 which minimizes the expected risk, see empirical risk minimization. 
In the case of binary classification, it is possible to simplify the calculation of expected risk from the integral specified above.  Specifically,

  
    
      
        
          
            
              
                I
                [
                f
                ]
              
              
                
                =
                
                  ∫
                  
                    
                      
                        X
                      
                    
                    ×
                    
                      
                        Y
                      
                    
                  
                
                V
                (
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                ,
                y
                )
                
                p
                (
                
                  
                    
                      x
                      →
                    
                  
                
                ,
                y
                )
                
                d
                
                  
                    
                      x
                      →
                    
                  
                
                
                d
                y
              
            
            
              
              
                
                =
                
                  ∫
                  
                    
                      X
                    
                  
                
                
                  ∫
                  
                    
                      Y
                    
                  
                
                ϕ
                (
                y
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                
                p
                (
                y
                ∣
                
                  
                    
                      x
                      →
                    
                  
                
                )
                
                p
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                
                d
                y
                
                d
                
                  
                    
                      x
                      →
                    
                  
                
              
            
            
              
              
                
                =
                
                  ∫
                  
                    
                      X
                    
                  
                
                [
                ϕ
                (
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                
                p
                (
                1
                ∣
                
                  
                    
                      x
                      →
                    
                  
                
                )
                +
                ϕ
                (
                −
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                
                p
                (
                −
                1
                ∣
                
                  
                    
                      x
                      →
                    
                  
                
                )
                ]
                
                p
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                
                d
                
                  
                    
                      x
                      →
                    
                  
                
              
            
            
              
              
                
                =
                
                  ∫
                  
                    
                      X
                    
                  
                
                [
                ϕ
                (
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                
                p
                (
                1
                ∣
                
                  
                    
                      x
                      →
                    
                  
                
                )
                +
                ϕ
                (
                −
                f
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                
                (
                1
                −
                p
                (
                1
                ∣
                
                  
                    
                      x
                      →
                    
                  
                
                )
                )
                ]
                
                p
                (
                
                  
                    
                      x
                      →
                    
                  
                
                )
                
                d
                
                  
                    
                      x
                      →
                    
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}I[f]&=\int _{{\mathcal {X}}\times {\mathcal {Y}}}V(f({\vec {x}}),y)\,p({\vec {x}},y)\,d{\vec {x}}\,dy\\[6pt]&=\int _{\mathcal {X}}\int _{\mathcal {Y}}\phi (yf({\vec {x}}))\,p(y\mid {\vec {x}})\,p({\vec {x}})\,dy\,d{\vec {x}}\\[6pt]&=\int _{\mathcal {X}}[\phi (f({\vec {x}}))\,p(1\mid {\vec {x}})+\phi (-f({\vec {x}}))\,p(-1\mid {\vec {x}})]\,p({\vec {x}})\,d{\vec {x}}\\[6pt]&=\int _{\mathcal {X}}[\phi (f({\vec {x}}))\,p(1\mid {\vec {x}})+\phi (-f({\vec {x}}))\,(1-p(1\mid {\vec {x}}))]\,p({\vec {x}})\,d{\vec {x}}\end{aligned}}}
  

The second equality follows from the properties described above.  The third equality follows from the fact that 1 and −1 are the only possible values for 
  
    
      
        y
      
    
    {\displaystyle y}
  
, and the fourth because 
  
    
      
        p
        (
        −
        1
        ∣
        x
        )
        =
        1
        −
        p
        (
        1
        ∣
        x
        )
      
    
    {\displaystyle p(-1\mid x)=1-p(1\mid x)}
  
. The term within brackets 
  
    
      
        [
        ϕ
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
        p
        (
        1
        ∣
        
          
            
              x
              →
            
          
        
        )
        +
        ϕ
        (
        −
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
        (
        1
        −
        p
        (
        1
        ∣
        
          
            
              x
              →
            
          
        
        )
        )
        ]
      
    
    {\displaystyle [\phi (f({\vec {x}}))p(1\mid {\vec {x}})+\phi (-f({\vec {x}}))(1-p(1\mid {\vec {x}}))]}
  
 is known as the conditional risk.
One can solve for the minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 by taking the functional derivative of the last equality with respect to 
  
    
      
        f
      
    
    {\displaystyle f}
  
 and setting the derivative equal to 0.  This will result in the following equation

  
    
      
        
          
            
              ∂
              ϕ
              (
              f
              )
            
            
              ∂
              f
            
          
        
        η
        +
        
          
            
              ∂
              ϕ
              (
              −
              f
              )
            
            
              ∂
              f
            
          
        
        (
        1
        −
        η
        )
        =
        0
        ,
        
        
        
        
        
        (
        1
        )
      
    
    {\displaystyle {\frac {\partial \phi (f)}{\partial f}}\eta +{\frac {\partial \phi (-f)}{\partial f}}(1-\eta )=0,\;\;\;\;\;(1)}
  

where 
  
    
      
        η
        =
        p
        (
        y
        =
        1
        
          |
        
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle \eta =p(y=1|{\vec {x}})}
  
, which is also equivalent to setting the derivative of the conditional risk equal to zero.
Given the binary nature of classification, a natural selection for a loss function (assuming equal cost for false positives and false negatives) would be the 0-1 loss function (0–1 indicator function), which takes the value of 0 if the predicted classification equals that of the true class or a 1 if the predicted classification does not match the true class. This selection is modeled by

  
    
      
        V
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        ,
        y
        )
        =
        H
        (
        −
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
      
    
    {\displaystyle V(f({\vec {x}}),y)=H(-yf({\vec {x}}))}
  

where 
  
    
      
        H
      
    
    {\displaystyle H}
  
 indicates the Heaviside step function.
However, this loss function is non-convex and non-smooth, and solving for the optimal solution is an NP-hard combinatorial optimization problem.  As a result, it is better to substitute loss function surrogates which are tractable for commonly used learning algorithms, as they have convenient properties such as being convex and smooth.  In addition to  their computational tractability,  one can show that the solutions to the learning problem using these loss surrogates allow for the recovery of the actual solution to the original classification problem.  Some of these surrogates are described below.
In practice, the probability distribution 
  
    
      
        p
        (
        
          
            
              x
              →
            
          
        
        ,
        y
        )
      
    
    {\displaystyle p({\vec {x}},y)}
  
 is unknown.  Consequently, utilizing a training set of 
  
    
      
        n
      
    
    {\displaystyle n}
  
 independently and identically distributed sample points

  
    
      
        S
        =
        {
        (
        
          
            
              
                x
                →
              
            
          
          
            1
          
        
        ,
        
          y
          
            1
          
        
        )
        ,
        …
        ,
        (
        
          
            
              
                x
                →
              
            
          
          
            n
          
        
        ,
        
          y
          
            n
          
        
        )
        }
      
    
    {\displaystyle S=\{({\vec {x}}_{1},y_{1}),\dots ,({\vec {x}}_{n},y_{n})\}}
  

drawn from the data sample space, one seeks to minimize empirical risk

  
    
      
        
          I
          
            S
          
        
        [
        f
        ]
        =
        
          
            1
            n
          
        
        
          ∑
          
            i
            =
            1
          
          
            n
          
        
        V
        (
        f
        (
        
          
            
              
                x
                →
              
            
          
          
            i
          
        
        )
        ,
        
          y
          
            i
          
        
        )
      
    
    {\displaystyle I_{S}[f]={\frac {1}{n}}\sum _{i=1}^{n}V(f({\vec {x}}_{i}),y_{i})}
  

as a proxy for expected risk. (See statistical learning theory for a more detailed description.)


== Bayes consistency ==
Utilizing Bayes' theorem, it can be shown that the optimal 
  
    
      
        
          f
          
            0
            
              /
            
            1
          
          
            ∗
          
        
      
    
    {\displaystyle f_{0/1}^{*}}
  
, i.e., the one that minimizes the expected risk associated with the zero-one loss, implements the Bayes optimal decision rule for a binary classification problem and is in the form of

  
    
      
        
          f
          
            0
            
              /
            
            1
          
          
            ∗
          
        
        (
        
          
            
              x
              →
            
          
        
        )
        
        =
        
        
          
            {
            
              
                
                  
                  
                  
                  1
                
                
                  
                    if 
                  
                  p
                  (
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                  >
                  p
                  (
                  −
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                
              
              
                
                  
                  
                  
                  0
                
                
                  
                    if 
                  
                  p
                  (
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                  =
                  p
                  (
                  −
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                
              
              
                
                  −
                  1
                
                
                  
                    if 
                  
                  p
                  (
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                  <
                  p
                  (
                  −
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                
              
            
            
          
        
      
    
    {\displaystyle f_{0/1}^{*}({\vec {x}})\;=\;{\begin{cases}\;\;\;1&{\text{if }}p(1\mid {\vec {x}})>p(-1\mid {\vec {x}})\\\;\;\;0&{\text{if }}p(1\mid {\vec {x}})=p(-1\mid {\vec {x}})\\-1&{\text{if }}p(1\mid {\vec {x}})<p(-1\mid {\vec {x}})\end{cases}}}
  
.
A loss function is said to be classification-calibrated or Bayes consistent if its optimal 
  
    
      
        
          f
          
            ϕ
          
          
            ∗
          
        
      
    
    {\displaystyle f_{\phi }^{*}}
  
 is such that 
  
    
      
        
          f
          
            0
            
              /
            
            1
          
          
            ∗
          
        
        (
        
          
            
              x
              →
            
          
        
        )
        =
        sgn
        ⁡
        (
        
          f
          
            ϕ
          
          
            ∗
          
        
        (
        
          
            
              x
              →
            
          
        
        )
        )
      
    
    {\displaystyle f_{0/1}^{*}({\vec {x}})=\operatorname {sgn} (f_{\phi }^{*}({\vec {x}}))}
  
and is thus optimal under the Bayes decision rule.  A Bayes consistent loss function allows us to find the Bayes optimal decision function 
  
    
      
        
          f
          
            ϕ
          
          
            ∗
          
        
      
    
    {\displaystyle f_{\phi }^{*}}
  
 by directly minimizing the expected risk and without having to explicitly model the probability density functions.
For convex margin loss 
  
    
      
        ϕ
        (
        υ
        )
      
    
    {\displaystyle \phi (\upsilon )}
  
, it can be shown that 
  
    
      
        ϕ
        (
        υ
        )
      
    
    {\displaystyle \phi (\upsilon )}
  
 is Bayes consistent if and only if it is differentiable at 0 and 
  
    
      
        
          ϕ
          ′
        
        (
        0
        )
        <
        0
      
    
    {\displaystyle \phi '(0)<0}
  
. Yet, this result does not exclude the existence of non-convex Bayes consistent loss functions.  A more general result states that Bayes consistent loss functions can be generated using the following formulation 

  
    
      
        ϕ
        (
        v
        )
        =
        C
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        +
        (
        1
        −
        
          f
          
            −
            1
          
        
        (
        v
        )
        )
        
          C
          ′
        
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        
        
        
        
        
        (
        2
        )
      
    
    {\displaystyle \phi (v)=C[f^{-1}(v)]+(1-f^{-1}(v))C'[f^{-1}(v)]\;\;\;\;\;(2)}
  
,
where 
  
    
      
        f
        (
        η
        )
        ,
        (
        0
        ≤
        η
        ≤
        1
        )
      
    
    {\displaystyle f(\eta ),(0\leq \eta \leq 1)}
  
 is any invertible function such that 
  
    
      
        
          f
          
            −
            1
          
        
        (
        −
        v
        )
        =
        1
        −
        
          f
          
            −
            1
          
        
        (
        v
        )
      
    
    {\displaystyle f^{-1}(-v)=1-f^{-1}(v)}
  
 and 
  
    
      
        C
        (
        η
        )
      
    
    {\displaystyle C(\eta )}
  
 is any differentiable strictly concave function such that 
  
    
      
        C
        (
        η
        )
        =
        C
        (
        1
        −
        η
        )
      
    
    {\displaystyle C(\eta )=C(1-\eta )}
  
. Table-I shows the generated Bayes consistent loss functions for some example choices of 
  
    
      
        C
        (
        η
        )
      
    
    {\displaystyle C(\eta )}
  
 and 
  
    
      
        
          f
          
            −
            1
          
        
        (
        v
        )
      
    
    {\displaystyle f^{-1}(v)}
  
. Note that the Savage and Tangent loss are not convex. Such non-convex loss functions have been shown to be useful in dealing with outliers in classification. For all loss functions generated from (2), the posterior probability 
  
    
      
        p
        (
        y
        =
        1
        
          |
        
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle p(y=1|{\vec {x}})}
  
 can be found using the invertible link function as  
  
    
      
        p
        (
        y
        =
        1
        
          |
        
        
          
            
              x
              →
            
          
        
        )
        =
        η
        =
        
          f
          
            −
            1
          
        
        (
        v
        )
      
    
    {\displaystyle p(y=1|{\vec {x}})=\eta =f^{-1}(v)}
  
. Such loss functions where the posterior probability can be recovered using the invertible link are called proper loss functions.   

The sole minimizer of the expected risk, 
  
    
      
        
          f
          
            ϕ
          
          
            ∗
          
        
      
    
    {\displaystyle f_{\phi }^{*}}
  
, associated with the above generated loss functions can be directly found from equation (1) and shown to be equal to the corresponding 
  
    
      
        f
        (
        η
        )
      
    
    {\displaystyle f(\eta )}
  
. This holds even for the nonconvex loss functions, which means that gradient descent based algorithms such as gradient boosting can be used to construct the minimizer.


== Proper loss functions, loss margin and regularization ==

For proper loss functions, the loss margin can be defined as 
  
    
      
        
          μ
          
            ϕ
          
        
        =
        −
        
          
            
              
                ϕ
                ′
              
              (
              0
              )
            
            
              
                ϕ
                ″
              
              (
              0
              )
            
          
        
      
    
    {\displaystyle \mu _{\phi }=-{\frac {\phi '(0)}{\phi ''(0)}}}
  
 and shown to be directly related to the regularization properties of the classifier. Specifically a loss function of larger margin increases regularization and produces better estimates of the posterior probability. For example, the loss margin can be increased for the logistic loss by introducing a 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
 parameter and writing the logistic loss as 
  
    
      
        
          
            1
            γ
          
        
        log
        ⁡
        (
        1
        +
        
          e
          
            −
            γ
            v
          
        
        )
      
    
    {\displaystyle {\frac {1}{\gamma }}\log(1+e^{-\gamma v})}
  
 where smaller 
  
    
      
        0
        <
        γ
        <
        1
      
    
    {\displaystyle 0<\gamma <1}
  
 increases the margin of the loss. It is shown that this is directly equivalent to decreasing the learning rate in gradient boosting 
  
    
      
        
          F
          
            m
          
        
        (
        x
        )
        =
        
          F
          
            m
            −
            1
          
        
        (
        x
        )
        +
        γ
        
          h
          
            m
          
        
        (
        x
        )
        ,
      
    
    {\displaystyle F_{m}(x)=F_{m-1}(x)+\gamma h_{m}(x),}
  
 where decreasing 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
 improves the regularization of the boosted classifier. The theory makes it clear that when a learning rate of 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
 is used, the correct formula for retrieving the posterior probability is now 
  
    
      
        η
        =
        
          f
          
            −
            1
          
        
        (
        γ
        F
        (
        x
        )
        )
      
    
    {\displaystyle \eta =f^{-1}(\gamma F(x))}
  
.
In conclusion, by choosing a loss function with larger margin (smaller 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
) we increase regularization and improve our estimates of the posterior probability which in turn improves the ROC curve of the final classifier.


== Square loss ==
While more commonly used in regression, the square loss function can be re-written as a function 
  
    
      
        ϕ
        (
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
      
    
    {\displaystyle \phi (yf({\vec {x}}))}
  
 and utilized for classification.  It can be generated using (2) and Table-I as follows

  
    
      
        ϕ
        (
        v
        )
        =
        C
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        +
        (
        1
        −
        
          f
          
            −
            1
          
        
        (
        v
        )
        )
        
          C
          ′
        
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        =
        4
        (
        
          
            1
            2
          
        
        (
        v
        +
        1
        )
        )
        (
        1
        −
        
          
            1
            2
          
        
        (
        v
        +
        1
        )
        )
        +
        (
        1
        −
        
          
            1
            2
          
        
        (
        v
        +
        1
        )
        )
        (
        4
        −
        8
        (
        
          
            1
            2
          
        
        (
        v
        +
        1
        )
        )
        )
        =
        (
        1
        −
        v
        
          )
          
            2
          
        
        .
      
    
    {\displaystyle \phi (v)=C[f^{-1}(v)]+(1-f^{-1}(v))C'[f^{-1}(v)]=4({\frac {1}{2}}(v+1))(1-{\frac {1}{2}}(v+1))+(1-{\frac {1}{2}}(v+1))(4-8({\frac {1}{2}}(v+1)))=(1-v)^{2}.}
  

The square loss function is both convex and smooth.  However, the square loss function tends to penalize outliers excessively, leading to slower convergence rates (with regards to sample complexity) than for the logistic loss or hinge loss functions.  In addition, functions which yield high values of 
  
    
      
        f
        (
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle f({\vec {x}})}
  
 for some 
  
    
      
        x
        ∈
        X
      
    
    {\displaystyle x\in X}
  
 will perform poorly with the square loss function, since high values of 
  
    
      
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle yf({\vec {x}})}
  
 will be penalized severely, regardless of whether the signs of 
  
    
      
        y
      
    
    {\displaystyle y}
  
 and 
  
    
      
        f
        (
        
          
            
              x
              →
            
          
        
        )
      
    
    {\displaystyle f({\vec {x}})}
  
 match.
A benefit of the square loss function is that its structure lends itself to easy cross validation of regularization parameters.  Specifically for Tikhonov regularization, one can solve for the regularization parameter using leave-one-out cross-validation in the same time as it would take to solve a single problem.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the square loss function can be directly found from equation (1) as

  
    
      
        
          f
          
            Square
          
          
            ∗
          
        
        =
        2
        η
        −
        1
        =
        2
        p
        (
        1
        ∣
        x
        )
        −
        1.
      
    
    {\displaystyle f_{\text{Square}}^{*}=2\eta -1=2p(1\mid x)-1.}
  


== Logistic loss ==
The logistic loss function can be generated using (2) and Table-I as follows

  
    
      
        
          
            
              
                ϕ
                (
                v
                )
              
              
                
                =
                C
                [
                
                  f
                  
                    −
                    1
                  
                
                (
                v
                )
                ]
                +
                
                  (
                  
                    1
                    −
                    
                      f
                      
                        −
                        1
                      
                    
                    (
                    v
                    )
                  
                  )
                
                
                
                  C
                  ′
                
                
                  [
                  
                    
                      f
                      
                        −
                        1
                      
                    
                    (
                    v
                    )
                  
                  ]
                
              
            
            
              
              
                
                =
                
                  
                    1
                    
                      log
                      ⁡
                      (
                      2
                      )
                    
                  
                
                
                  [
                  
                    
                      
                        
                          −
                          
                            e
                            
                              v
                            
                          
                        
                        
                          1
                          +
                          
                            e
                            
                              v
                            
                          
                        
                      
                    
                    log
                    ⁡
                    
                      
                        
                          e
                          
                            v
                          
                        
                        
                          1
                          +
                          
                            e
                            
                              v
                            
                          
                        
                      
                    
                    −
                    
                      (
                      
                        1
                        −
                        
                          
                            
                              e
                              
                                v
                              
                            
                            
                              1
                              +
                              
                                e
                                
                                  v
                                
                              
                            
                          
                        
                      
                      )
                    
                    log
                    ⁡
                    
                      (
                      
                        1
                        −
                        
                          
                            
                              e
                              
                                v
                              
                            
                            
                              1
                              +
                              
                                e
                                
                                  v
                                
                              
                            
                          
                        
                      
                      )
                    
                  
                  ]
                
                +
                
                  (
                  
                    1
                    −
                    
                      
                        
                          e
                          
                            v
                          
                        
                        
                          1
                          +
                          
                            e
                            
                              v
                            
                          
                        
                      
                    
                  
                  )
                
                
                  [
                  
                    
                      
                        
                          −
                          1
                        
                        
                          log
                          ⁡
                          (
                          2
                          )
                        
                      
                    
                    log
                    ⁡
                    
                      (
                      
                        
                          
                            
                              e
                              
                                v
                              
                            
                            
                              1
                              +
                              
                                e
                                
                                  v
                                
                              
                            
                          
                          
                            1
                            −
                            
                              
                                
                                  e
                                  
                                    v
                                  
                                
                                
                                  1
                                  +
                                  
                                    e
                                    
                                      v
                                    
                                  
                                
                              
                            
                          
                        
                      
                      )
                    
                  
                  ]
                
              
            
            
              
              
                
                =
                
                  
                    1
                    
                      log
                      ⁡
                      (
                      2
                      )
                    
                  
                
                log
                ⁡
                (
                1
                +
                
                  e
                  
                    −
                    v
                  
                
                )
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\phi (v)&=C[f^{-1}(v)]+\left(1-f^{-1}(v)\right)\,C'\left[f^{-1}(v)\right]\\&={\frac {1}{\log(2)}}\left[{\frac {-e^{v}}{1+e^{v}}}\log {\frac {e^{v}}{1+e^{v}}}-\left(1-{\frac {e^{v}}{1+e^{v}}}\right)\log \left(1-{\frac {e^{v}}{1+e^{v}}}\right)\right]+\left(1-{\frac {e^{v}}{1+e^{v}}}\right)\left[{\frac {-1}{\log(2)}}\log \left({\frac {\frac {e^{v}}{1+e^{v}}}{1-{\frac {e^{v}}{1+e^{v}}}}}\right)\right]\\&={\frac {1}{\log(2)}}\log(1+e^{-v}).\end{aligned}}}
  

The logistic loss is convex and grows linearly for negative values which make it less sensitive to outliers. The logistic loss is used in the LogitBoost algorithm.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the logistic loss function  can be directly found from equation (1) as

  
    
      
        
          f
          
            Logistic
          
          
            ∗
          
        
        =
        log
        ⁡
        
          (
          
            
              η
              
                1
                −
                η
              
            
          
          )
        
        =
        log
        ⁡
        
          (
          
            
              
                p
                (
                1
                ∣
                x
                )
              
              
                1
                −
                p
                (
                1
                ∣
                x
                )
              
            
          
          )
        
        .
      
    
    {\displaystyle f_{\text{Logistic}}^{*}=\log \left({\frac {\eta }{1-\eta }}\right)=\log \left({\frac {p(1\mid x)}{1-p(1\mid x)}}\right).}
  

This function is undefined when 
  
    
      
        p
        (
        1
        ∣
        x
        )
        =
        1
      
    
    {\displaystyle p(1\mid x)=1}
  
 or  
  
    
      
        p
        (
        1
        ∣
        x
        )
        =
        0
      
    
    {\displaystyle p(1\mid x)=0}
  
 (tending toward ∞ and −∞ respectively), but predicts a smooth curve which grows when 
  
    
      
        p
        (
        1
        ∣
        x
        )
      
    
    {\displaystyle p(1\mid x)}
  
 increases and equals 0 when 
  
    
      
        p
        (
        1
        ∣
        x
        )
        =
        0.5
      
    
    {\displaystyle p(1\mid x)=0.5}
  
.
It's easy to check that the logistic loss and binary cross-entropy loss (Log loss) are in fact the same (up to a multiplicative constant 
  
    
      
        
          
            1
            
              log
              ⁡
              (
              2
              )
            
          
        
      
    
    {\displaystyle {\frac {1}{\log(2)}}}
  
). The cross-entropy loss is closely related to the Kullback–Leibler divergence between the empirical distribution and the predicted distribution. The cross-entropy loss is ubiquitous in modern deep neural networks.


== Exponential loss ==
The exponential loss function can be generated using (2) and Table-I as follows.

  
    
      
        ϕ
        (
        v
        )
        =
        C
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        +
        (
        1
        −
        
          f
          
            −
            1
          
        
        (
        v
        )
        )
        
          C
          ′
        
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        =
        2
        
          
            
              (
              
                
                  
                    e
                    
                      2
                      v
                    
                  
                  
                    1
                    +
                    
                      e
                      
                        2
                        v
                      
                    
                  
                
              
              )
            
            
              (
              
                1
                −
                
                  
                    
                      e
                      
                        2
                        v
                      
                    
                    
                      1
                      +
                      
                        e
                        
                          2
                          v
                        
                      
                    
                  
                
              
              )
            
          
        
        +
        
          (
          
            1
            −
            
              
                
                  e
                  
                    2
                    v
                  
                
                
                  1
                  +
                  
                    e
                    
                      2
                      v
                    
                  
                
              
            
          
          )
        
        
          (
          
            
              
                1
                −
                
                  
                    
                      2
                      
                        e
                        
                          2
                          v
                        
                      
                    
                    
                      1
                      +
                      
                        e
                        
                          2
                          v
                        
                      
                    
                  
                
              
              
                
                  
                    
                      e
                      
                        2
                        v
                      
                    
                    
                      1
                      +
                      
                        e
                        
                          2
                          v
                        
                      
                    
                  
                
                (
                1
                −
                
                  
                    
                      e
                      
                        2
                        v
                      
                    
                    
                      1
                      +
                      
                        e
                        
                          2
                          v
                        
                      
                    
                  
                
                )
              
            
          
          )
        
        =
        
          e
          
            −
            v
          
        
      
    
    {\displaystyle \phi (v)=C[f^{-1}(v)]+(1-f^{-1}(v))C'[f^{-1}(v)]=2{\sqrt {\left({\frac {e^{2v}}{1+e^{2v}}}\right)\left(1-{\frac {e^{2v}}{1+e^{2v}}}\right)}}+\left(1-{\frac {e^{2v}}{1+e^{2v}}}\right)\left({\frac {1-{\frac {2e^{2v}}{1+e^{2v}}}}{\sqrt {{\frac {e^{2v}}{1+e^{2v}}}(1-{\frac {e^{2v}}{1+e^{2v}}})}}}\right)=e^{-v}}
  

The exponential loss is convex and grows exponentially for negative values which makes it more sensitive to outliers. The exponentially-weighted 0-1 loss is used in the AdaBoost algorithm implicitly giving rise to the exponential loss.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the exponential loss function can be directly found from equation (1) as

  
    
      
        
          f
          
            Exp
          
          
            ∗
          
        
        =
        
          
            1
            2
          
        
        log
        ⁡
        
          (
          
            
              η
              
                1
                −
                η
              
            
          
          )
        
        =
        
          
            1
            2
          
        
        log
        ⁡
        
          (
          
            
              
                p
                (
                1
                ∣
                x
                )
              
              
                1
                −
                p
                (
                1
                ∣
                x
                )
              
            
          
          )
        
        .
      
    
    {\displaystyle f_{\text{Exp}}^{*}={\frac {1}{2}}\log \left({\frac {\eta }{1-\eta }}\right)={\frac {1}{2}}\log \left({\frac {p(1\mid x)}{1-p(1\mid x)}}\right).}
  


== Savage loss ==
The Savage loss  can be generated using (2) and Table-I as follows

  
    
      
        ϕ
        (
        v
        )
        =
        C
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        +
        (
        1
        −
        
          f
          
            −
            1
          
        
        (
        v
        )
        )
        
          C
          ′
        
        [
        
          f
          
            −
            1
          
        
        (
        v
        )
        ]
        =
        
          (
          
            
              
                e
                
                  v
                
              
              
                1
                +
                
                  e
                  
                    v
                  
                
              
            
          
          )
        
        
          (
          
            1
            −
            
              
                
                  e
                  
                    v
                  
                
                
                  1
                  +
                  
                    e
                    
                      v
                    
                  
                
              
            
          
          )
        
        +
        
          (
          
            1
            −
            
              
                
                  e
                  
                    v
                  
                
                
                  1
                  +
                  
                    e
                    
                      v
                    
                  
                
              
            
          
          )
        
        
          (
          
            1
            −
            
              
                
                  2
                  
                    e
                    
                      v
                    
                  
                
                
                  1
                  +
                  
                    e
                    
                      v
                    
                  
                
              
            
          
          )
        
        =
        
          
            1
            
              (
              1
              +
              
                e
                
                  v
                
              
              
                )
                
                  2
                
              
            
          
        
        .
      
    
    {\displaystyle \phi (v)=C[f^{-1}(v)]+(1-f^{-1}(v))C'[f^{-1}(v)]=\left({\frac {e^{v}}{1+e^{v}}}\right)\left(1-{\frac {e^{v}}{1+e^{v}}}\right)+\left(1-{\frac {e^{v}}{1+e^{v}}}\right)\left(1-{\frac {2e^{v}}{1+e^{v}}}\right)={\frac {1}{(1+e^{v})^{2}}}.}
  

The Savage loss is quasi-convex and is bounded for large negative values which makes it less sensitive to outliers. The Savage loss has been used in gradient boosting and the SavageBoost algorithm.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the Savage loss function  can be directly found from equation (1) as

  
    
      
        
          f
          
            Savage
          
          
            ∗
          
        
        =
        log
        ⁡
        
          (
          
            
              η
              
                1
                −
                η
              
            
          
          )
        
        =
        log
        ⁡
        
          (
          
            
              
                p
                (
                1
                ∣
                x
                )
              
              
                1
                −
                p
                (
                1
                ∣
                x
                )
              
            
          
          )
        
        .
      
    
    {\displaystyle f_{\text{Savage}}^{*}=\log \left({\frac {\eta }{1-\eta }}\right)=\log \left({\frac {p(1\mid x)}{1-p(1\mid x)}}\right).}
  


== Tangent loss ==
The Tangent loss can be generated using (2) and Table-I as follows

  
    
      
        
          
            
              
                ϕ
                (
                v
                )
              
              
                
                =
                C
                [
                
                  f
                  
                    −
                    1
                  
                
                (
                v
                )
                ]
                +
                
                  (
                  
                    1
                    −
                    
                      f
                      
                        −
                        1
                      
                    
                    (
                    v
                    )
                  
                  )
                
                
                  C
                  ′
                
                [
                
                  f
                  
                    −
                    1
                  
                
                (
                v
                )
                ]
              
            
            
              
              
                
                =
                4
                
                  (
                  
                    arctan
                    ⁡
                    (
                    v
                    )
                    +
                    
                      
                        1
                        2
                      
                    
                  
                  )
                
                
                  (
                  
                    1
                    −
                    
                      (
                      
                        arctan
                        ⁡
                        (
                        v
                        )
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                  
                  )
                
                +
                
                  (
                  
                    1
                    −
                    
                      (
                      
                        arctan
                        ⁡
                        (
                        v
                        )
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                  
                  )
                
                
                  (
                  
                    4
                    −
                    8
                    
                      (
                      
                        arctan
                        ⁡
                        (
                        v
                        )
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                  
                  )
                
              
            
            
              
              
                
                =
                
                  
                    (
                    
                      2
                      arctan
                      ⁡
                      (
                      v
                      )
                      −
                      1
                    
                    )
                  
                  
                    2
                  
                
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\phi (v)&=C[f^{-1}(v)]+\left(1-f^{-1}(v)\right)C'[f^{-1}(v)]\\&=4\left(\arctan(v)+{\frac {1}{2}}\right)\left(1-\left(\arctan(v)+{\frac {1}{2}}\right)\right)+\left(1-\left(\arctan(v)+{\frac {1}{2}}\right)\right)\left(4-8\left(\arctan(v)+{\frac {1}{2}}\right)\right)\\&=\left(2\arctan(v)-1\right)^{2}.\end{aligned}}}
  

The Tangent loss is quasi-convex and is bounded for large negative values which makes it less sensitive to outliers. Interestingly, the Tangent loss also assigns a bounded penalty to data points that have been classified "too correctly". This can help prevent over-training on the data set.   The Tangent loss has been used in gradient boosting, the TangentBoost algorithm and Alternating Decision Forests.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the Tangent loss function  can be directly found from equation (1) as

  
    
      
        
          f
          
            Tangent
          
          
            ∗
          
        
        =
        tan
        ⁡
        
          (
          
            η
            −
            
              
                1
                2
              
            
          
          )
        
        =
        tan
        ⁡
        
          (
          
            p
            
              (
              
                1
                ∣
                x
              
              )
            
            −
            
              
                1
                2
              
            
          
          )
        
        .
      
    
    {\displaystyle f_{\text{Tangent}}^{*}=\tan \left(\eta -{\frac {1}{2}}\right)=\tan \left(p\left(1\mid x\right)-{\frac {1}{2}}\right).}
  


== Hinge loss ==

The hinge loss function is defined with 
  
    
      
        ϕ
        (
        υ
        )
        =
        max
        (
        0
        ,
        1
        −
        υ
        )
        =
        [
        1
        −
        υ
        
          ]
          
            +
          
        
      
    
    {\displaystyle \phi (\upsilon )=\max(0,1-\upsilon )=[1-\upsilon ]_{+}}
  
, where 
  
    
      
        [
        a
        
          ]
          
            +
          
        
        =
        max
        (
        0
        ,
        a
        )
      
    
    {\displaystyle [a]_{+}=\max(0,a)}
  
 is the positive part function.

  
    
      
        V
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        ,
        y
        )
        =
        max
        (
        0
        ,
        1
        −
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
        =
        [
        1
        −
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        
          ]
          
            +
          
        
        .
      
    
    {\displaystyle V(f({\vec {x}}),y)=\max(0,1-yf({\vec {x}}))=[1-yf({\vec {x}})]_{+}.}
  

The hinge loss provides a relatively tight, convex upper bound on the 0–1 indicator function.  Specifically, the hinge loss equals the 0–1 indicator function when 
  
    
      
        sgn
        ⁡
        (
        f
        (
        
          
            
              x
              →
            
          
        
        )
        )
        =
        y
      
    
    {\displaystyle \operatorname {sgn} (f({\vec {x}}))=y}
  
 and 
  
    
      
        
          |
        
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        
          |
        
        ≥
        1
      
    
    {\displaystyle |yf({\vec {x}})|\geq 1}
  
.  In addition, the empirical risk minimization of this loss is equivalent to the classical formulation for support vector machines (SVMs).  Correctly classified points lying outside the margin boundaries of the support vectors are not penalized, whereas points within the margin boundaries or on the wrong side of the hyperplane are penalized in a linear fashion compared to their distance from the correct boundary.
While the hinge loss function is both convex and continuous, it is not smooth (is not differentiable) at 
  
    
      
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        =
        1
      
    
    {\displaystyle yf({\vec {x}})=1}
  
.  Consequently, the hinge loss function cannot be used with gradient descent methods or stochastic gradient descent methods which rely on differentiability over the entire domain.  However, the hinge loss does have a subgradient at 
  
    
      
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        =
        1
      
    
    {\displaystyle yf({\vec {x}})=1}
  
, which allows for the utilization of subgradient descent methods.  SVMs utilizing the hinge loss function can also be solved using quadratic programming.
The minimizer of 
  
    
      
        I
        [
        f
        ]
      
    
    {\displaystyle I[f]}
  
 for the hinge loss function is

  
    
      
        
          f
          
            Hinge
          
          
            ∗
          
        
        (
        
          
            
              x
              →
            
          
        
        )
        
        =
        
        
          
            {
            
              
                
                  1
                
                
                  
                    if 
                  
                  p
                  (
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                  >
                  p
                  (
                  −
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                
              
              
                
                  −
                  1
                
                
                  
                    if 
                  
                  p
                  (
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                  <
                  p
                  (
                  −
                  1
                  ∣
                  
                    
                      
                        x
                        →
                      
                    
                  
                  )
                
              
            
            
          
        
      
    
    {\displaystyle f_{\text{Hinge}}^{*}({\vec {x}})\;=\;{\begin{cases}1&{\text{if }}p(1\mid {\vec {x}})>p(-1\mid {\vec {x}})\\-1&{\text{if }}p(1\mid {\vec {x}})<p(-1\mid {\vec {x}})\end{cases}}}
  

when 
  
    
      
        p
        (
        1
        ∣
        x
        )
        ≠
        0.5
      
    
    {\displaystyle p(1\mid x)\neq 0.5}
  
, which matches that of the 0–1 indicator function.  This conclusion makes the hinge loss quite attractive, as bounds can be placed on the difference between expected risk and the sign of hinge loss function. The Hinge loss cannot be derived from (2) since 
  
    
      
        
          f
          
            Hinge
          
          
            ∗
          
        
      
    
    {\displaystyle f_{\text{Hinge}}^{*}}
  
  is not invertible.


== Generalized smooth hinge loss ==
The generalized smooth hinge loss function with parameter 
  
    
      
        α
      
    
    {\displaystyle \alpha }
  
 is defined as

  
    
      
        
          f
          
            α
          
          
            ∗
          
        
        (
        z
        )
        
        =
        
        
          
            {
            
              
                
                  
                    
                      α
                      
                        α
                        +
                        1
                      
                    
                  
                  −
                  z
                
                
                  
                    if 
                  
                  z
                  ≤
                  0
                
              
              
                
                  
                    
                      1
                      
                        α
                        +
                        1
                      
                    
                  
                  
                    z
                    
                      α
                      +
                      1
                    
                  
                  −
                  z
                  +
                  
                    
                      α
                      
                        α
                        +
                        1
                      
                    
                  
                
                
                  
                    if 
                  
                  0
                  <
                  z
                  <
                  1
                
              
              
                
                  0
                
                
                  
                    if 
                  
                  z
                  ≥
                  1
                
              
            
            
          
        
        ,
      
    
    {\displaystyle f_{\alpha }^{*}(z)\;=\;{\begin{cases}{\frac {\alpha }{\alpha +1}}-z&{\text{if }}z\leq 0\\{\frac {1}{\alpha +1}}z^{\alpha +1}-z+{\frac {\alpha }{\alpha +1}}&{\text{if }}0<z<1\\0&{\text{if }}z\geq 1\end{cases}},}
  

where

  
    
      
        z
        =
        y
        f
        (
        
          
            
              x
              →
            
          
        
        )
        .
      
    
    {\displaystyle z=yf({\vec {x}}).}
  

It is monotonically decreasing and reaches 0 when 
  
    
      
        z
        =
        1
      
    
    {\displaystyle z=1}
  
.


== See also ==
Differentiable programming
Scoring function


== References ==