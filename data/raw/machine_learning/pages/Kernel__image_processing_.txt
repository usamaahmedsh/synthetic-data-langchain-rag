In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image. Or more simply, when each pixel in the output image is a function of the nearby pixels (including itself) in the input image, the kernel is that function.


== Details ==
The general expression of a convolution is

  
    
      
        
          g
          
            x
            ,
            y
          
        
        =
        ω
        ∗
        
          f
          
            x
            ,
            y
          
        
        =
        
          ∑
          
            i
            =
            −
            a
          
          
            a
          
        
        
          
            ∑
            
              j
              =
              −
              b
            
            
              b
            
          
          
            
              ω
              
                i
                ,
                j
              
            
            
              f
              
                x
                −
                i
                ,
                y
                −
                j
              
            
          
        
        ,
      
    
    {\displaystyle g_{x,y}=\omega *f_{x,y}=\sum _{i=-a}^{a}{\sum _{j=-b}^{b}{\omega _{i,j}f_{x-i,y-j}}},}
  

where 
  
    
      
        g
        (
        x
        ,
        y
        )
      
    
    {\displaystyle g(x,y)}
  
 is the filtered image, 
  
    
      
        f
        (
        x
        ,
        y
        )
      
    
    {\displaystyle f(x,y)}
  
 is the original image, 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
 is the filter kernel. Every element of the filter kernel is considered by  
  
    
      
        −
        a
        ≤
        i
        ≤
        a
      
    
    {\displaystyle -a\leq i\leq a}
  
 and 
  
    
      
        −
        b
        ≤
        j
        ≤
        b
      
    
    {\displaystyle -b\leq j\leq b}
  
.
Depending on the element values, a kernel can cause a wide range of effects:

The above are just a few examples of effects achievable by convolving kernels and images.


=== Origin ===
The origin is the position of the kernel which is above (conceptually) the current output pixel. This could be outside of the actual kernel, though usually it corresponds to one of the kernel elements. For a symmetric kernel, the origin is usually the center element.


== Convolution ==

Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution. The matrix operation being performed—convolution—is not traditional matrix multiplication, despite being similarly denoted by *.
For example, if we have two three-by-three matrices, the first a kernel, and the second an image piece, convolution is the process of flipping both the rows and columns of the kernel and multiplying locally similar entries and summing. The element at coordinates [2, 2] (that is, the central element) of the resulting image would be a weighted combination of all the entries of the image matrix, with weights given by the kernel:

  
    
      
        
          (
          
            
              
                [
                
                  
                    
                      a
                    
                    
                      b
                    
                    
                      c
                    
                  
                  
                    
                      d
                    
                    
                      e
                    
                    
                      f
                    
                  
                  
                    
                      g
                    
                    
                      h
                    
                    
                      i
                    
                  
                
                ]
              
            
            ∗
            
              
                [
                
                  
                    
                      1
                    
                    
                      2
                    
                    
                      3
                    
                  
                  
                    
                      4
                    
                    
                      5
                    
                    
                      6
                    
                  
                  
                    
                      7
                    
                    
                      8
                    
                    
                      9
                    
                  
                
                ]
              
            
          
          )
        
        [
        2
        ,
        2
        ]
        =
      
    
    {\displaystyle \left({\begin{bmatrix}a&b&c\\d&e&f\\g&h&i\end{bmatrix}}*{\begin{bmatrix}1&2&3\\4&5&6\\7&8&9\end{bmatrix}}\right)[2,2]=}
  

  
    
      
        (
        i
        ⋅
        1
        )
        +
        (
        h
        ⋅
        2
        )
        +
        (
        g
        ⋅
        3
        )
        +
        (
        f
        ⋅
        4
        )
        +
        (
        e
        ⋅
        5
        )
        +
        (
        d
        ⋅
        6
        )
        +
        (
        c
        ⋅
        7
        )
        +
        (
        b
        ⋅
        8
        )
        +
        (
        a
        ⋅
        9
        )
        .
      
    
    {\displaystyle (i\cdot 1)+(h\cdot 2)+(g\cdot 3)+(f\cdot 4)+(e\cdot 5)+(d\cdot 6)+(c\cdot 7)+(b\cdot 8)+(a\cdot 9).}
  

The other entries would be similarly weighted, where we position the center of the kernel on each of the boundary points of the image, and compute a weighted sum.
The values of a given pixel in the output image are calculated by multiplying each kernel value by the corresponding input image pixel values. This can be described algorithmically with the following pseudo-code:

for each image row in input image:
    for each pixel in image row:

        set accumulator to zero

        for each kernel row in kernel:
            for each element in kernel row:

                if element position  corresponding* to pixel position then
                    multiply element value  corresponding* to pixel value
                    add result to accumulator
                endif

         set output image pixel to accumulator

*corresponding input image pixels are found relative to the kernel's origin.
If the kernel is symmetric then place the center (origin) of the kernel on the current pixel. The kernel will overlap the neighboring pixels around the origin. Each kernel element should be multiplied with the pixel value it overlaps with and all of the obtained values should be summed. This resultant sum will be the new value for the current pixel currently overlapped with the center of the kernel.
If the kernel is not symmetric, it has to be flipped both around its horizontal and vertical axis before calculating the convolution as above.
The general form for matrix convolution is

  
    
      
        
          
            [
            
              
                
                  
                    x
                    
                      11
                    
                  
                
                
                  
                    x
                    
                      12
                    
                  
                
                
                  ⋯
                
                
                  
                    x
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    x
                    
                      21
                    
                  
                
                
                  
                    x
                    
                      22
                    
                  
                
                
                  ⋯
                
                
                  
                    x
                    
                      2
                      n
                    
                  
                
              
              
                
                  ⋮
                
                
                  ⋮
                
                
                  ⋱
                
                
                  ⋮
                
              
              
                
                  
                    x
                    
                      m
                      1
                    
                  
                
                
                  
                    x
                    
                      m
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    x
                    
                      m
                      n
                    
                  
                
              
            
            ]
          
        
        ∗
        
          
            [
            
              
                
                  
                    y
                    
                      11
                    
                  
                
                
                  
                    y
                    
                      12
                    
                  
                
                
                  ⋯
                
                
                  
                    y
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    y
                    
                      21
                    
                  
                
                
                  
                    y
                    
                      22
                    
                  
                
                
                  ⋯
                
                
                  
                    y
                    
                      2
                      n
                    
                  
                
              
              
                
                  ⋮
                
                
                  ⋮
                
                
                  ⋱
                
                
                  ⋮
                
              
              
                
                  
                    y
                    
                      m
                      1
                    
                  
                
                
                  
                    y
                    
                      m
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    y
                    
                      m
                      n
                    
                  
                
              
            
            ]
          
        
        =
        
          ∑
          
            i
            =
            0
          
          
            m
            −
            1
          
        
        
          ∑
          
            j
            =
            0
          
          
            n
            −
            1
          
        
        
          x
          
            (
            m
            −
            i
            )
            (
            n
            −
            j
            )
          
        
        
          y
          
            (
            1
            +
            i
            )
            (
            1
            +
            j
            )
          
        
      
    
    {\displaystyle {\begin{bmatrix}x_{11}&x_{12}&\cdots &x_{1n}\\x_{21}&x_{22}&\cdots &x_{2n}\\\vdots &\vdots &\ddots &\vdots \\x_{m1}&x_{m2}&\cdots &x_{mn}\\\end{bmatrix}}*{\begin{bmatrix}y_{11}&y_{12}&\cdots &y_{1n}\\y_{21}&y_{22}&\cdots &y_{2n}\\\vdots &\vdots &\ddots &\vdots \\y_{m1}&y_{m2}&\cdots &y_{mn}\\\end{bmatrix}}=\sum _{i=0}^{m-1}\sum _{j=0}^{n-1}x_{(m-i)(n-j)}y_{(1+i)(1+j)}}
  


=== Edge handling ===

Kernel convolution usually requires values from pixels outside of the image boundaries. There are a variety of methods for handling image edges.

Extend
The nearest border pixels are conceptually extended as far as necessary to provide values for the convolution. Corner pixels are extended in 90° wedges. Other edge pixels are extended in lines.
Wrap
The image is conceptually wrapped (or tiled) and values are taken from the opposite edge or corner.
Mirror
The image is conceptually mirrored at the edges.  For example, attempting to read a pixel 3 units outside an edge reads one 3 units inside the edge instead.
Crop / Avoid overlap
Any pixel in the output image which would require values from beyond the edge is skipped. This method can result in the output image being slightly smaller, with the edges having been cropped. Move kernel so that values from outside of image is never required. Machine learning mainly uses this approach. Example: Kernel size 10x10, image size 32x32, result image is 23x23.
Kernel Crop
Any pixel in the kernel that extends past the input image isn't used and the normalizing is adjusted to compensate.
Constant
Use constant value for pixels outside of image. Usually black or sometimes gray is used. Generally this depends on application.


=== Normalization ===
Normalization is defined as the division of each element in the kernel by the sum of all kernel elements, so that the sum of the elements of a normalized kernel is unity. This will ensure the average pixel in the modified image is as bright as the average pixel in the original image.


=== Optimization ===
Fast convolution algorithms include:

separable convolution


==== Separable convolution ====
2D convolution with an M × N kernel requires M × N multiplications for each sample (pixel). If the kernel is separable, then the computation can be reduced to M + N multiplications. Using separable convolutions can significantly decrease the computation by doing 1D convolution twice instead of one 2D convolution.


=== Implementation ===
Here a concrete convolution implementation done with the GLSL shading language :


== See also ==
Convolution in mathematics 
Multidimensional discrete convolution


== References ==


== Sources ==
Ludwig, Jamie (n.d.). Image Convolution (PDF). Portland State University.
Lecarme, Olivier; Delvare, Karine (January 2013). The Book of GIMP: A Complete Guide to Nearly Everything. No Starch Press. p. 429. ISBN 978-1593273835.
Gumster, Jason van; Shimonski, Robert (March 2012). GIMP Bible. John Wiley & Sons. pp. 438–442. ISBN 978-0470523971.
Shapiro, Linda G.; Stockman, George C. (February 2001). Computer Vision. Prentice Hall. pp. 53–54. ISBN 978-0130307965.


== External links ==
Implementing 2d convolution on FPGA
vImage Programming Guide: Performing Convolution Operations
Image Processing using  2D-Convolution
GNU Image Manipulation Program - User Manual - 8.2. Convolution Matrix
GLSL Demonstration of 3x3 Convolution Kernels
Complete C++ open source project