In statistics and combinatorial mathematics, group testing is any procedure that breaks up the task of identifying objects into tests on groups of items, rather than testing each item individually. First studied by Robert Dorfman in 1943, group testing is a relatively new field of mathematics that can be applied to a wide range of practical applications and is an active area of research today.
A familiar example of group testing involves a string of light bulbs connected in series, where exactly one of the bulbs is known to be broken. The objective is to find the broken bulb using the smallest number of tests (where a test is when some of the bulbs are connected to a power supply). A simple approach is to test each bulb individually. However, when there are a large number of bulbs it would be much more efficient to pool the bulbs into groups. For example, by connecting the first half of the bulbs at once, it can be determined which half the broken bulb is in, ruling out half of the bulbs in just one test.
Schemes for carrying out group testing can be simple or complex and the tests involved at each stage may be different. Schemes in which the tests for the next stage depend on the results of the previous stages are called adaptive procedures, while schemes designed so that all the tests are known beforehand are called non-adaptive procedures. The structure of the scheme of the tests involved in a non-adaptive procedure is known as a pooling design.
Group testing has many applications, including statistics, biology, computer science, medicine, engineering and cyber security. Modern interest in these testing schemes has been rekindled by the Human Genome Project.


== Basic description and terms ==
Unlike many areas of mathematics, the origins of group testing can be traced back to a single report written by a single person: Robert Dorfman. The motivation arose during the Second World War when the United States Public Health Service and the Selective service embarked upon a large-scale project to weed out all syphilitic men called up for induction. Testing an individual for syphilis involves drawing a blood sample from them and then analysing the sample to determine the presence or absence of syphilis. At the time, performing this test was expensive, and testing every soldier individually would have been very expensive and inefficient.
Supposing there are 
  
    
      
        n
      
    
    {\displaystyle n}
  
 soldiers, this method of testing leads to 
  
    
      
        n
      
    
    {\displaystyle n}
  
 separate tests. If a large proportion of the people are infected then this method would be reasonable. However, in the more likely case that only a very small proportion of the men are infected, a much more efficient testing scheme can be achieved. The feasibility of a more effective testing scheme hinges on the following property: the soldiers can be pooled into groups, and in each group the blood samples can be combined. The combined sample can then be tested to check if at least one soldier in the group has syphilis. This is the central idea behind group testing. If one or more of the soldiers in this group has syphilis, then a test is wasted (more tests need to be performed to find which soldier(s) it was). On the other hand, if no one in the pool has syphilis then many tests are saved, since every soldier in that group can be eliminated with just one test.
The items that cause a group to test positive are generally called defective items (these are the broken lightbulbs, syphilitic men, etc.). Often, the total number of items is denoted as 
  
    
      
        n
      
    
    {\displaystyle n}
  
 and 
  
    
      
        d
      
    
    {\displaystyle d}
  
 represents the number of defectives if it is assumed to be known.


=== Classification of group-testing problems ===
There are two independent classifications for group-testing problems; every group-testing problem is either adaptive or non-adaptive, and either probabilistic or combinatorial.
In probabilistic models, the defective items are assumed to follow some probability distribution and the aim is to minimise the expected number of tests needed to identify the defectiveness of every item. On the other hand, with combinatorial group testing, the goal is to minimise the number of tests needed in a 'worst-case scenario' – that is, create a minmax algorithm – and no knowledge of the distribution of defectives is assumed.
The other classification, adaptivity, concerns what information can be used when choosing which items to group into a test. In general, the choice of which items to test can depend on the results of previous tests, as in the above lightbulb problem. An algorithm that proceeds by performing a test, and then using the result (and all past results) to decide which next test to perform, is called adaptive. Conversely, in non-adaptive algorithms, all tests are decided in advance. This idea can be generalised to multistage algorithms, where tests are divided into stages, and every test in the next stage must be decided in advance, with only the knowledge of the results of tests in previous stages.
Although adaptive algorithms offer much more freedom in design, it is known that adaptive group-testing algorithms do not improve upon non-adaptive ones by more than a constant factor in the number of tests required to identify the set of defective items. In addition to this, non-adaptive methods are often useful in practice because one can proceed with successive tests without first analysing the results of all previous tests, allowing for the effective distribution of the testing process.


=== Variations and extensions ===
There are many ways to extend the problem of group testing. One of the most important is called noisy group testing, and deals with a big assumption of the original problem: that testing is error-free. A group-testing problem is called noisy when there is some chance that the result of a group test is erroneous (e.g. comes out positive when the test contained no defectives). The Bernoulli noise model assumes this probability is some constant, 
  
    
      
        q
      
    
    {\displaystyle q}
  
, but in general it can depend on the true number of defectives in the test and the number of items tested. For example, the effect of dilution can be modelled by saying a positive result is more likely when there are more defectives (or more defectives as a fraction of the number tested), present in the test. A noisy algorithm will always have a non-zero probability of making an error (that is, mislabeling an item).
Group testing can be extended by considering scenarios in which there are more than two possible outcomes of a test. For example, a test may have the outcomes 
  
    
      
        0
        ,
        1
      
    
    {\displaystyle 0,1}
  
 and 
  
    
      
        
          2
          
            +
          
        
      
    
    {\displaystyle 2^{+}}
  
, corresponding to there being no defectives, a single defective, or an unknown number of defectives larger than one. More generally, it is possible to consider the outcome-set of a test to be 
  
    
      
        
          0
          ,
          1
          ,
          …
          ,
          
            k
            
              +
            
          
        
      
    
    {\displaystyle {0,1,\ldots ,k^{+}}}
  
 for some 
  
    
      
        k
        ∈
        
          N
        
      
    
    {\displaystyle k\in \mathbb {N} }
  
.
Another extension is to consider geometric restrictions on which sets can be tested. The above lightbulb problem is an example of this kind of restriction: only bulbs that appear consecutively can be tested. Similarly, the items may be arranged in a circle, or in general, a net, where the tests are available paths on the graph. Another kind of geometric restriction would be on the maximum number of items that can be tested in a group, or the group sizes might have to be even and so on. In a similar way, it may be useful to consider the restriction that any given item can only appear in a certain number of tests.
There are endless ways to continue remixing the basic formula of group testing. The following elaborations will give an idea of some of the more exotic variants. In the 'good–mediocre–bad' model, each item is one of 'good', 'mediocre' or 'bad', and the result of a test is the type of the 'worst' item in the group. In threshold group testing, the result of a test is positive if the number of defective items in the group is greater than some threshold value or proportion. Group testing with inhibitors is a variant with applications in molecular biology. Here, there is a third class of items called inhibitors, and the result of a test is positive if it contains at least one defective and no inhibitors.


== History and development ==


=== Invention and initial progress ===
The concept of group testing was first introduced by Robert Dorfman in 1943 in a short report published in the Notes section of Annals of Mathematical Statistics. Dorfman's report – as with all the early work on group testing – focused on the probabilistic problem, and aimed to use the novel idea of group testing to reduce the expected number of tests needed to weed out all syphilitic men in a given pool of soldiers. The method was simple: put the soldiers into groups of a given size, and use individual testing (testing items in groups of size one) on the positive groups to find which were infected. Dorfman tabulated the optimum group sizes for this strategy against the prevalence rate of defectiveness in the population.
Stephen Samuels

found a closed-form solution for the optimal group size as a function of the prevalence rate.
After 1943, group testing remained largely untouched for a number of years. Then in 1957, Sterrett produced an improvement on Dorfman's procedure. This newer process starts by again performing individual testing on the positive groups, but stopping as soon as a defective is identified. Then, the remaining items in the group are tested together, since it is very likely that none of them are defective.
The first thorough treatment of group testing was given by Sobel and Groll in their formative 1959 paper on the subject. They described five new procedures – in addition to generalisations for when the prevalence rate is unknown – and for the optimal one, they provided an explicit formula for the expected number of tests it would use. The paper also made the connection between group testing and information theory for the first time, as well as discussing several generalisations of the group-testing problem and providing some new applications of the theory.
The fundamental result by Peter Ungar in 1960 shows that if the prevalence rate 
  
    
      
        p
        >
        
          p
          
            u
          
        
      
    
    {\displaystyle p>p_{u}}
  
, where 
  
    
      
        
          p
          
            u
          
        
        =
        (
        3
        −
        
          
            5
          
        
        )
        
          /
        
        2
        ≈
        0.38
      
    
    {\displaystyle p_{u}=(3-{\sqrt {5}})/2\approx 0.38}
  
, then individual testing is the optimal group testing procedure with respect to the expected number of tests, and if 
  
    
      
        p
        <
        
          p
          
            u
          
        
      
    
    {\displaystyle p<p_{u}}
  
, then it is not optimal. However, it is important to note that despite 80 years' worth of research effort, the optimal procedure is yet unknown for 
  
    
      
        p
        <
        
          p
          
            u
          
        
      
    
    {\displaystyle p<p_{u}}
  
 and a general population size 
  
    
      
        n
        >
        2
      
    
    {\displaystyle n>2}
  
.


=== Combinatorial group testing ===
Group testing was first studied in the combinatorial context by Li in 1962, with the introduction of Li’s 
  
    
      
        s
      
    
    {\displaystyle s}
  
-stage algorithm. Li proposed an extension of
Dorfman's '2-stage algorithm' to an arbitrary number of stages that required no more
than 
  
    
      
        t
        =
        
          
            e
            
              
                log
                
                  2
                
              
              ⁡
              (
              e
              )
            
          
        
        d
        
          log
          
            2
          
        
        ⁡
        (
        n
        )
      
    
    {\displaystyle t={\frac {e}{\log _{2}(e)}}d\log _{2}(n)}
  
 tests to be guaranteed to find 
  
    
      
        d
      
    
    {\displaystyle d}
  
 or fewer defectives among 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items.
The idea was to remove all the items in negative tests, and divide the remaining items into groups as was done with the initial pool. This was to be done 
  
    
      
        s
        −
        1
      
    
    {\displaystyle s-1}
  
 times before performing individual testing.
Combinatorial group testing in general was later studied more fully by Katona in 1973. Katona introduced the matrix representation of non-adaptive group-testing and produced a procedure for finding the defective in the non-adaptive 1-defective case in no more than 
  
    
      
        t
        =
        ⌈
        
          log
          
            2
          
        
        ⁡
        (
        n
        )
        ⌉
      
    
    {\displaystyle t=\lceil \log _{2}(n)\rceil }
  
tests, which he also proved to be optimal.
In general, finding optimal algorithms for adaptive combinatorial group testing is difficult, and although the computational complexity of group testing has not been determined, it is suspected to be hard in some complexity class. However, an important breakthrough occurred in 1972, with the introduction of the generalised binary-splitting algorithm. The generalised binary-splitting algorithm works by performing a binary search on groups that test positive, and is a simple algorithm that finds a single defective in no more than the information-lower-bound number of tests.
In scenarios where there are two or more defectives, the generalised binary-splitting algorithm still produces near-optimal results, requiring at most 
  
    
      
        d
        −
        1
      
    
    {\displaystyle d-1}
  
 tests above the information lower bound where 
  
    
      
        d
      
    
    {\displaystyle d}
  
 is the number of defectives. Considerable improvements to this were made in 2013 by Allemann, getting the required number of tests to less than 
  
    
      
        0.187
        d
        +
        0.5
        
          log
          
            2
          
        
        ⁡
        (
        d
        )
        +
        5.5
      
    
    {\displaystyle 0.187d+0.5\log _{2}(d)+5.5}
  
 above the information lower bound when 
  
    
      
        n
        
          /
        
        d
        ≥
        38
      
    
    {\displaystyle n/d\geq 38}
  
 and 
  
    
      
        d
        ≥
        10
      
    
    {\displaystyle d\geq 10}
  
. This was achieved by changing the binary search in the binary-splitting algorithm to a complex set of sub-algorithms with overlapping test groups. As such, the problem of adaptive combinatorial group testing – with a known number or upper bound on the number of defectives – has essentially been solved, with little room for further improvement.
There is an open question as to when individual testing is minmax. Hu, Hwang and Wang showed in 1981 that individual testing is minmax when 
  
    
      
        n
        ≤
        ⌊
        (
        5
        d
        +
        1
        )
        
          /
        
        2
        ⌋
      
    
    {\displaystyle n\leq \lfloor (5d+1)/2\rfloor }
  
, and that it is not minmax when 
  
    
      
        n
        >
        3
        d
      
    
    {\displaystyle n>3d}
  
. It is currently conjectured that this bound is sharp: that is, individual testing is minmax if and only if 
  
    
      
        n
        ≤
        3
        d
      
    
    {\displaystyle n\leq 3d}
  
. Some progress was made in 2000 by Riccio and Colbourn, who showed that for large 
  
    
      
        n
      
    
    {\displaystyle n}
  
, individual testing is minmax when 
  
    
      
        d
        ≥
        n
        
          /
        
        
          log
          
            3
            
              /
            
            2
          
        
        ⁡
        (
        3
        )
        ≈
        0.369
        n
      
    
    {\displaystyle d\geq n/\log _{3/2}(3)\approx 0.369n}
  
.


=== Non-adaptive and probabilistic testing ===
One of the key insights in non-adaptive group testing is that significant gains can be made by eliminating the requirement that the group-testing procedure be certain to succeed (the "combinatorial" problem), but rather permit it to have some low but non-zero probability of mis-labelling each item (the "probabilistic" problem). It is known that as the number of defective items approaches the total number of items, exact combinatorial solutions require significantly more tests than probabilistic solutions — even probabilistic solutions permitting only an asymptotically small probability of error.
In this vein, Chan et al. (2011) introduced COMP, a probabilistic algorithm that requires no more than 
  
    
      
        t
        =
        e
        d
        (
        1
        +
        δ
        )
        ln
        ⁡
        (
        n
        )
      
    
    {\displaystyle t=ed(1+\delta )\ln(n)}
  
 tests to find up to 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives in 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items with a probability of error no more than 
  
    
      
        
          n
          
            −
            δ
          
        
      
    
    {\displaystyle n^{-\delta }}
  
. This is within a constant factor of the 
  
    
      
        t
        =
        O
        (
        d
        
          log
          
            2
          
        
        ⁡
        n
        )
      
    
    {\displaystyle t=O(d\log _{2}n)}
  
 lower bound.
Chan et al. (2011) also provided a generalisation of COMP to a simple noisy model, and similarly produced an explicit performance bound, which was again only a constant (dependent on the likelihood of a failed test) above the corresponding lower bound. In general, the number of tests required in the Bernoulli noise case is a constant factor larger than in the noiseless case.
Aldridge, Baldassini and Johnson (2014) produced an extension of the COMP algorithm that added additional post-processing steps. They showed that the performance of this new algorithm, called DD, strictly exceeds that of COMP, and that DD is 'essentially optimal' in scenarios where 
  
    
      
        
          d
          
            2
          
        
        ≥
        n
      
    
    {\displaystyle d^{2}\geq n}
  
, by comparing it to a hypothetical algorithm that defines a reasonable optimum. The performance of this hypothetical algorithm suggests that there is room for improvement when 
  
    
      
        
          d
          
            2
          
        
        <
        n
      
    
    {\displaystyle d^{2}<n}
  
, as well as suggesting how much improvement this might be.


== Formalisation of combinatorial group testing ==
This section formally defines the notions and terms relating to group testing.

The input vector, 
  
    
      
        
          x
        
        =
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        …
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle \mathbf {x} =(x_{1},x_{2},\dots ,x_{n})}
  
, is defined to be a binary vector of length 
  
    
      
        n
      
    
    {\displaystyle n}
  
 (that is, 
  
    
      
        
          x
        
        ∈
        {
        0
        ,
        1
        
          }
          
            n
          
        
      
    
    {\displaystyle \mathbf {x} \in \{0,1\}^{n}}
  
), with the j-th item being called defective if and only if 
  
    
      
        
          x
          
            j
          
        
        =
        1
      
    
    {\displaystyle x_{j}=1}
  
. Further, any non-defective item is called a 'good' item.

  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 is intended to describe the (unknown) set of defective items. The key property of 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 is that it is an implicit input. That is to say, there is no direct knowledge of what the entries of 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 are, other than that which can be inferred via some series of 'tests'. This leads on to the next definition.

Let 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 be an input vector. A set, 
  
    
      
        S
        ⊆
        {
        1
        ,
        2
        ,
        …
        ,
        n
        }
      
    
    {\displaystyle S\subseteq \{1,2,\dots ,n\}}
  
 is called a test. When testing is noiseless, the result of a test is positive when there exists 
  
    
      
        j
        ∈
        S
      
    
    {\displaystyle j\in S}
  
 such that 
  
    
      
        
          x
          
            j
          
        
        =
        1
      
    
    {\displaystyle x_{j}=1}
  
, and the result is negative otherwise.
Therefore, the goal of group testing is to come up with a method for choosing a 'short' series of tests that allow 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 to be determined, either exactly or with a high degree of certainty.

A group-testing algorithm is said to make an error if it incorrectly labels an item (that is, labels any defective item as non-defective or vice versa). This is not the same thing as the result of a group test being incorrect. An algorithm is called zero-error if the probability that it makes an error is zero.

  
    
      
        t
        (
        d
        ,
        n
        )
      
    
    {\displaystyle t(d,n)}
  
 denotes the minimum number of tests required to always find 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives among 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items with zero probability of error by any group-testing algorithm. For the same quantity but with the restriction that the algorithm is non-adaptive, the notation 
  
    
      
        
          
            
              t
              ¯
            
          
        
        (
        d
        ,
        n
        )
      
    
    {\displaystyle {\bar {t}}(d,n)}
  
 is used.


=== General bounds ===
Since it is always possible to resort to individual testing by setting 
  
    
      
        
          S
          
            j
          
        
        =
        {
        j
        }
      
    
    {\displaystyle S_{j}=\{j\}}
  
 for each 
  
    
      
        1
        ≤
        j
        ≤
        n
      
    
    {\displaystyle 1\leq j\leq n}
  
, it must be that that 
  
    
      
        
          
            
              t
              ¯
            
          
        
        (
        d
        ,
        n
        )
        ≤
        n
      
    
    {\displaystyle {\bar {t}}(d,n)\leq n}
  
. Also, since any non-adaptive testing procedure can be written as an adaptive algorithm by simply performing all the tests without regard to their outcome, 
  
    
      
        t
        (
        d
        ,
        n
        )
        ≤
        
          
            
              t
              ¯
            
          
        
        (
        d
        ,
        n
        )
      
    
    {\displaystyle t(d,n)\leq {\bar {t}}(d,n)}
  
. Finally, when 
  
    
      
        0
        ≠
        d
        ≠
        n
      
    
    {\displaystyle 0\neq d\neq n}
  
, there is at least one item whose defectiveness must be determined (by at least one test), and so 
  
    
      
        1
        ≤
        t
        (
        d
        ,
        n
        )
      
    
    {\displaystyle 1\leq t(d,n)}
  
.
In summary (when assuming 
  
    
      
        0
        ≠
        d
        ≠
        n
      
    
    {\displaystyle 0\neq d\neq n}
  
), 
  
    
      
        1
        ≤
        t
        (
        d
        ,
        n
        )
        ≤
        
          
            
              t
              ¯
            
          
        
        (
        d
        ,
        n
        )
        ≤
        n
      
    
    {\displaystyle 1\leq t(d,n)\leq {\bar {t}}(d,n)\leq n}
  
.


==== Information lower bound ====
A lower bound on the number of tests needed can be described using the notion of sample space, denoted 
  
    
      
        
          
            S
          
        
      
    
    {\displaystyle {\mathcal {S}}}
  
, which is simply the set of possible placements of defectives. For any group testing problem with sample space 
  
    
      
        
          
            S
          
        
      
    
    {\displaystyle {\mathcal {S}}}
  
 and any group-testing algorithm, it can be shown that 
  
    
      
        t
        ≥
        ⌈
        
          log
          
            2
          
        
        ⁡
        
          
            |
          
          
            
              S
            
          
          
            |
          
        
        ⌉
      
    
    {\displaystyle t\geq \lceil \log _{2}{|{\mathcal {S}}|}\rceil }
  
, where 
  
    
      
        t
      
    
    {\displaystyle t}
  
 is the minimum number of tests required to identify all defectives with a zero probability of error. This is called the information lower bound. This bound is derived from the fact that after each test, 
  
    
      
        
          
            S
          
        
      
    
    {\displaystyle {\mathcal {S}}}
  
 is split into two disjoint subsets, each corresponding to one of the two possible outcomes of the test.
However, the information lower bound itself is usually unachievable, even for small problems. This is because the splitting of 
  
    
      
        
          
            S
          
        
      
    
    {\displaystyle {\mathcal {S}}}
  
 is not arbitrary, since it must be realisable by some test.
In fact, the information lower bound can be generalised to the case where there is a non-zero probability that the algorithm makes an error. In this form, the theorem gives us an upper bound on the probability of success based on the number of tests. For any group-testing algorithm that performs 
  
    
      
        t
      
    
    {\displaystyle t}
  
 tests, the probability of success, 
  
    
      
        
          P
        
        (
        
          
            success
          
        
        )
      
    
    {\displaystyle \mathbb {P} ({\textrm {success}})}
  
, satisfies 
  
    
      
        
          P
        
        (
        
          
            success
          
        
        )
        ≤
        t
        
          /
        
        
          log
          
            2
          
        
        ⁡
        
          
            
              (
            
            
              n
              d
            
            
              )
            
          
        
      
    
    {\displaystyle \mathbb {P} ({\textrm {success}})\leq t/\log _{2}{n \choose d}}
  
. This can be strengthened to: 
  
    
      
        
          P
        
        (
        
          
            success
          
        
        )
        ≤
        
          
            
              2
              
                t
              
            
            
              
                (
              
              
                n
                d
              
              
                )
              
            
          
        
      
    
    {\displaystyle \mathbb {P} ({\textrm {success}})\leq {\frac {2^{t}}{n \choose d}}}
  
.


=== Representation of non-adaptive algorithms ===

Algorithms for non-adaptive group testing consist of two distinct phases. First, it is decided how many tests to perform and which items to include in each test.  In the second phase, often called the decoding step, the results of each group test are analysed to determine which items are likely to be defective. The first phase is usually encoded in a matrix as follows.

Suppose a non-adaptive group testing procedure for 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items consists of the tests 
  
    
      
        
          S
          
            1
          
        
        ,
        
          S
          
            2
          
        
        ,
        …
        ,
        
          S
          
            t
          
        
      
    
    {\displaystyle S_{1},S_{2},\dots ,S_{t}}
  
 for some 
  
    
      
        t
        ∈
        
          
            N
          
          
            ≥
            0
          
        
      
    
    {\displaystyle t\in \mathbb {N} _{\geq 0}}
  
. The testing matrix for this scheme is the 
  
    
      
        t
        ×
        n
      
    
    {\displaystyle t\times n}
  
 binary matrix, 
  
    
      
        M
      
    
    {\displaystyle M}
  
, where 
  
    
      
        (
        M
        
          )
          
            i
            j
          
        
        =
        1
      
    
    {\displaystyle (M)_{ij}=1}
  
 if and only if 
  
    
      
        j
        ∈
        
          S
          
            i
          
        
      
    
    {\displaystyle j\in S_{i}}
  
 (and is zero otherwise).
Thus each column of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 represents an item and each row represents a test, with a 
  
    
      
        1
      
    
    {\displaystyle 1}
  
 in the 
  
    
      
        (
        i
        ,
        j
        )
        
          
            -th
          
        
      
    
    {\displaystyle (i,j){\textrm {-th}}}
  
 entry indicating that the 
  
    
      
        i
        
          
            -th
          
        
      
    
    {\displaystyle i{\textrm {-th}}}
  
 test included the 
  
    
      
        j
        
          
            -th
          
        
      
    
    {\displaystyle j{\textrm {-th}}}
  
 item and a 
  
    
      
        0
      
    
    {\displaystyle 0}
  
 indicating otherwise.
As well as the vector 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 (of length 
  
    
      
        n
      
    
    {\displaystyle n}
  
) that describes the unknown defective set, it is common to introduce the result vector, which describes the results of each test.

Let 
  
    
      
        t
      
    
    {\displaystyle t}
  
 be the number of tests performed by a non-adaptive algorithm. The result vector, 
  
    
      
        
          y
        
        =
        (
        
          y
          
            1
          
        
        ,
        
          y
          
            2
          
        
        ,
        …
        ,
        
          y
          
            t
          
        
        )
      
    
    {\displaystyle \mathbf {y} =(y_{1},y_{2},\dots ,y_{t})}
  
, is a binary vector of length 
  
    
      
        t
      
    
    {\displaystyle t}
  
 (that is, 
  
    
      
        
          y
        
        ∈
        {
        0
        ,
        1
        
          }
          
            t
          
        
      
    
    {\displaystyle \mathbf {y} \in \{0,1\}^{t}}
  
) such that 
  
    
      
        
          y
          
            i
          
        
        =
        1
      
    
    {\displaystyle y_{i}=1}
  
 if and only if the result of the 
  
    
      
        i
        
          
            -th
          
        
      
    
    {\displaystyle i{\textrm {-th}}}
  
 test was positive (i.e. contained at least one defective).
With these definitions, the non-adaptive problem can be reframed as follows: first a testing matrix is chosen, 
  
    
      
        M
      
    
    {\displaystyle M}
  
, after which the vector 
  
    
      
        
          y
        
      
    
    {\displaystyle \mathbf {y} }
  
 is returned. Then the problem is to analyse 
  
    
      
        
          y
        
      
    
    {\displaystyle \mathbf {y} }
  
 to find some estimate for 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
.
In the simplest noisy case, where there is a constant probability, 
  
    
      
        q
      
    
    {\displaystyle q}
  
, that a group test will have an erroneous result, one considers a random binary vector, 
  
    
      
        
          v
        
      
    
    {\displaystyle \mathbf {v} }
  
, where each entry has a probability 
  
    
      
        q
      
    
    {\displaystyle q}
  
 of being 
  
    
      
        1
      
    
    {\displaystyle 1}
  
, and is 
  
    
      
        0
      
    
    {\displaystyle 0}
  
 otherwise. The vector that is returned is then 
  
    
      
        
          
            
              
                y
              
              ^
            
          
        
        =
        
          y
        
        +
        
          v
        
      
    
    {\displaystyle {\hat {\mathbf {y} }}=\mathbf {y} +\mathbf {v} }
  
, with the usual addition on 
  
    
      
        (
        
          Z
        
        
          /
        
        2
        
          Z
        
        
          )
          
            n
          
        
      
    
    {\displaystyle (\mathbb {Z} /2\mathbb {Z} )^{n}}
  
 (equivalently this is the element-wise XOR operation). A noisy algorithm must estimate 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 using 
  
    
      
        
          
            
              
                y
              
              ^
            
          
        
      
    
    {\displaystyle {\hat {\mathbf {y} }}}
  
 (that is, without direct knowledge of 
  
    
      
        
          y
        
      
    
    {\displaystyle \mathbf {y} }
  
).


=== Bounds for non-adaptive algorithms ===
The matrix representation makes it possible to prove some bounds on non-adaptive group testing. The approach mirrors that of many deterministic designs, where 
  
    
      
        d
      
    
    {\displaystyle d}
  
-separable matrices are considered, as defined below.

A binary matrix, 
  
    
      
        M
      
    
    {\displaystyle M}
  
, is called 
  
    
      
        d
      
    
    {\displaystyle d}
  
-separable if every Boolean sum (logical OR) of any 
  
    
      
        d
      
    
    {\displaystyle d}
  
 of its columns is distinct. Additionally, the notation 
  
    
      
        
          
            
              d
              ¯
            
          
        
      
    
    {\displaystyle {\bar {d}}}
  
-separable indicates that every sum of any of up to 
  
    
      
        d
      
    
    {\displaystyle d}
  
 of 
  
    
      
        M
      
    
    {\displaystyle M}
  
's columns is distinct. (This is not the same as 
  
    
      
        M
      
    
    {\displaystyle M}
  
 being 
  
    
      
        k
      
    
    {\displaystyle k}
  
-separable for every 
  
    
      
        k
        ≤
        d
      
    
    {\displaystyle k\leq d}
  
.)
When 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is a testing matrix, the property of being 
  
    
      
        d
      
    
    {\displaystyle d}
  
-separable (
  
    
      
        
          
            
              d
              ¯
            
          
        
      
    
    {\displaystyle {\bar {d}}}
  
-separable) is equivalent to being able to distinguish between (up to) 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives. However, it does not guarantee that this will be straightforward. A stronger property, called disjunctness does.

A binary matrix, 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is called 
  
    
      
        d
      
    
    {\displaystyle d}
  
-disjunct if the Boolean sum of any 
  
    
      
        d
      
    
    {\displaystyle d}
  
 columns does not contain any other column. (In this context, a column A is said to contain a column B if for every index where B has a 1, A also has a 1.)
A useful property of 
  
    
      
        d
      
    
    {\displaystyle d}
  
-disjunct testing matrices is that, with up to 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives, every non-defective item will appear in at least one test whose outcome is negative. This means there is a simple procedure for finding the defectives: just remove every item that appears in a negative test.
Using the properties of 
  
    
      
        d
      
    
    {\displaystyle d}
  
-separable and 
  
    
      
        d
      
    
    {\displaystyle d}
  
-disjunct matrices the following can be shown for the problem of identifying 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives among 
  
    
      
        n
      
    
    {\displaystyle n}
  
 total items.

The number of tests needed for an asymptotically small average probability of error scales as 
  
    
      
        O
        (
        d
        
          log
          
            2
          
        
        ⁡
        n
        )
      
    
    {\displaystyle O(d\log _{2}n)}
  
.
The number of tests needed for an asymptotically small maximum probability of error scales as 
  
    
      
        O
        (
        
          d
          
            2
          
        
        
          log
          
            2
          
        
        ⁡
        n
        )
      
    
    {\displaystyle O(d^{2}\log _{2}n)}
  
.
The number of tests needed for a zero probability of error scales as 
  
    
      
        O
        
          (
          
            
              
                
                  d
                  
                    2
                  
                
                
                  log
                  
                    2
                  
                
                ⁡
                n
              
              
                
                  log
                  
                    2
                  
                
                ⁡
                d
              
            
          
          )
        
      
    
    {\displaystyle O\left({\frac {d^{2}\log _{2}n}{\log _{2}d}}\right)}
  
.


== Generalised binary-splitting algorithm ==

The generalised binary-splitting algorithm is an essentially-optimal adaptive group-testing algorithm that finds 
  
    
      
        d
      
    
    {\displaystyle d}
  
 or fewer defectives among 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items as follows:

If 
  
    
      
        n
        ≤
        2
        d
        −
        2
      
    
    {\displaystyle n\leq 2d-2}
  
, test the 
  
    
      
        n
      
    
    {\displaystyle n}
  
 items individually. Otherwise, set 
  
    
      
        l
        =
        n
        −
        d
        +
        1
      
    
    {\displaystyle l=n-d+1}
  
 and 
  
    
      
        α
        =
        ⌊
        
          log
          
            2
          
        
        ⁡
        
          l
          
            /
          
          d
        
        ⌋
      
    
    {\displaystyle \alpha =\lfloor \log _{2}{l/d}\rfloor }
  
.
Test a group of size 
  
    
      
        
          2
          
            α
          
        
      
    
    {\displaystyle 2^{\alpha }}
  
. If the outcome is negative, every item in the group is declared to be non-defective; set 
  
    
      
        n
        :=
        n
        −
        
          2
          
            α
          
        
      
    
    {\displaystyle n:=n-2^{\alpha }}
  
 and go to step 1. Otherwise, use a binary search to identify one defective and an unspecified number, called 
  
    
      
        x
      
    
    {\displaystyle x}
  
, of non-defective items; set 
  
    
      
        n
        :=
        n
        −
        1
        −
        x
      
    
    {\displaystyle n:=n-1-x}
  
 and 
  
    
      
        d
        :=
        d
        −
        1
      
    
    {\displaystyle d:=d-1}
  
. Go to step 1.
The generalised binary-splitting algorithm requires no more than 
  
    
      
        T
      
    
    {\displaystyle T}
  
 tests where

  
    
      
        T
        =
        
          
            {
            
              
                
                  n
                
                
                  n
                  ≤
                  2
                  d
                  −
                  2
                
              
              
                
                  (
                  α
                  +
                  2
                  )
                  d
                  +
                  p
                  −
                  1
                
                
                  n
                  ≥
                  2
                  d
                  −
                  1
                
              
            
            
          
        
      
    
    {\displaystyle T={\begin{cases}n&n\leq 2d-2\\(\alpha +2)d+p-1&n\geq 2d-1\end{cases}}}
  
.
For 
  
    
      
        n
        
          /
        
        d
      
    
    {\displaystyle n/d}
  
 large, it can be shown that 
  
    
      
        T
        →
        d
        
          log
          
            2
          
        
        ⁡
        (
        n
        
          /
        
        d
        )
      
    
    {\displaystyle T\rightarrow d\log _{2}(n/d)}
  
, which compares favorably to the 
  
    
      
        t
        =
        
          
            e
            
              
                log
                
                  2
                
              
              ⁡
              e
            
          
        
        d
        
          log
          
            2
          
        
        ⁡
        
          (
          
            
              n
              d
            
          
          )
        
      
    
    {\displaystyle t={\frac {e}{\log _{2}e}}d\log _{2}\left({\frac {n}{d}}\right)}
  
 tests required for Li's 
  
    
      
        s
      
    
    {\displaystyle s}
  
-stage algorithm. In fact, the generalised binary-splitting algorithm is close to optimal in the following sense. When 
  
    
      
        d
        ≥
        2
      
    
    {\displaystyle d\geq 2}
  
 it can be shown that 
  
    
      
        T
        −
        
          B
          
            I
          
        
        (
        d
        ,
        n
        )
        ≤
        (
        d
        −
        1
        )
      
    
    {\displaystyle T-B_{I}(d,n)\leq (d-1)}
  
, where 
  
    
      
        
          B
          
            I
          
        
        (
        d
        ,
        n
        )
        =
        
          ⌈
          
            
              log
              
                2
              
            
            ⁡
            
              ∑
              
                i
                =
                0
              
              
                d
              
            
            
              
                
                  (
                
                
                  n
                  i
                
                
                  )
                
              
            
          
          ⌉
        
      
    
    {\displaystyle B_{I}(d,n)=\left\lceil \log _{2}\sum _{i=0}^{d}{n \choose i}\right\rceil }
  
 is the information lower bound.


== Non-adaptive algorithms ==
Non-adaptive group-testing algorithms tend to assume that the number of defectives, or at least a good upper bound on them, is known. This quantity is denoted 
  
    
      
        d
      
    
    {\displaystyle d}
  
 in this section. If no bounds are known, there are non-adaptive algorithms with low query complexity that can help estimate 
  
    
      
        d
      
    
    {\displaystyle d}
  
.


=== Combinatorial orthogonal matching pursuit (COMP) ===

Combinatorial Orthogonal Matching Pursuit, or COMP, is a simple non-adaptive group-testing algorithm that forms the basis for the more complicated algorithms that follow in this section.
First, each entry of the testing matrix is chosen i.i.d. to be 
  
    
      
        1
      
    
    {\displaystyle 1}
  
 with probability 
  
    
      
        1
        
          /
        
        d
      
    
    {\displaystyle 1/d}
  
 and 
  
    
      
        0
      
    
    {\displaystyle 0}
  
 otherwise.
The decoding step proceeds column-wise (i.e. by item). If every test in which an item appears is positive, then the item is declared defective; otherwise the item is assumed to be non-defective. Or equivalently, if an item appears in any test whose outcome is negative, the item is declared non-defective; otherwise the item is assumed to be defective. An important property of this algorithm is that it never creates false negatives, though a false positive occurs when all locations with ones in the j-th column of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 (corresponding to a non-defective item j) are "hidden" by the ones of other columns corresponding to defective items.
The COMP algorithm requires no more than 
  
    
      
        e
        d
        (
        1
        +
        δ
        )
        ln
        ⁡
        (
        n
        )
      
    
    {\displaystyle ed(1+\delta )\ln(n)}
  
 tests to have an error probability less than or equal to 
  
    
      
        
          n
          
            −
            δ
          
        
      
    
    {\displaystyle n^{-\delta }}
  
. This is within a constant factor of the lower bound for the average probability of error above.
In the noisy case, one relaxes the requirement in the original COMP algorithm that the set of locations of ones in any column of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 corresponding to a positive item be entirely contained in the set of locations of ones in the result vector. Instead, one allows for a certain number of “mismatches” – this number of mismatches depends on both the number of ones in each column, and also the noise parameter, 
  
    
      
        q
      
    
    {\displaystyle q}
  
. This noisy COMP algorithm requires no more than 
  
    
      
        4.36
        (
        
          
            δ
          
        
        +
        
          
            1
            +
            δ
          
        
        
          )
          
            2
          
        
        (
        1
        −
        2
        q
        
          )
          
            −
            2
          
        
        d
        
          log
          
            2
          
        
        ⁡
        
          n
        
      
    
    {\displaystyle 4.36({\sqrt {\delta }}+{\sqrt {1+\delta }})^{2}(1-2q)^{-2}d\log _{2}{n}}
  
 tests to achieve an error probability at most 
  
    
      
        
          n
          
            −
            δ
          
        
      
    
    {\displaystyle n^{-\delta }}
  
.


=== Definite defectives (DD) ===
The definite defectives method (DD) is an extension of the COMP algorithm that attempts to remove any false positives. Performance guarantees for DD have been shown to strictly exceed those of COMP.
The decoding step uses a useful property of the COMP algorithm: that every item that COMP declares non-defective is certainly non-defective (that is, there are no false negatives). It proceeds as follows.

First the COMP algorithm is run, and any non-defectives that it detects are removed. All remaining items are now "possibly defective".
Next the algorithm looks at all the positive tests. If an item appears as the only "possible defective" in a test, then it must be defective, so the algorithm declares it to be defective.
All other items are assumed to be non-defective. The justification for this last step comes from the assumption that the number of defectives is much smaller than the total number of items.
Note that steps 1 and 2 never make a mistake, so the algorithm can only make a mistake if it declares a defective item to be non-defective. Thus the DD algorithm can only create false negatives.


=== Sequential COMP (SCOMP) ===
SCOMP (Sequential COMP) is an algorithm that makes use of the fact that DD makes no mistakes until the last step, where it is assumed that the remaining items are non-defective. Let the set of declared defectives be 
  
    
      
        K
      
    
    {\displaystyle K}
  
. A positive test is called explained by 
  
    
      
        K
      
    
    {\displaystyle K}
  
 if it contains at least one item in 
  
    
      
        K
      
    
    {\displaystyle K}
  
. The key observation with SCOMP is that the set of defectives found by DD may not explain every positive test, and that every unexplained test must contain a hidden defective.
The algorithm proceeds as follows.

Carry out steps 1 and 2 of the DD algorithm to obtain 
  
    
      
        K
      
    
    {\displaystyle K}
  
, an initial estimate for the set of defectives.
If 
  
    
      
        K
      
    
    {\displaystyle K}
  
 explains every positive test, terminate the algorithm: 
  
    
      
        K
      
    
    {\displaystyle K}
  
 is the final estimate for the set of defectives.
If there are any unexplained tests, find the "possible defective" that appears in the largest number of unexplained tests, and declare it to be defective (that is, add it to the set 
  
    
      
        K
      
    
    {\displaystyle K}
  
). Go to step 2.
In simulations, SCOMP has been shown to perform close to optimally.


=== Polynomial Pools (PP) ===
Polynomial Pools (PP) is a deterministic algorithm that is guaranteed to exactly
identify up to 
  
    
      
        d
      
    
    {\displaystyle d}
  
 positives. The algorithm is for the construction of the pooling matrix 
  
    
      
        M
      
    
    {\displaystyle M}
  
, which can be straightforwardly used
to decode the observations in 
  
    
      
        y
      
    
    {\displaystyle y}
  
. Similar to
COMP, a sample is decoded according to the relation:

  
    
      
        
          x
          
            i
          
        
        =
        1
         
         
        
           if 
        
         
         
        M
        (
        :
        ,
        i
        )
         
        .
        ∗
         
        y
        =
        M
        (
        :
        ,
        i
        )
      
    
    {\displaystyle x_{i}=1~~{\text{ if }}~~M(:,i)~.*~y=M(:,i)}
  
, where 
  
    
      
        .
        ∗
      
    
    {\displaystyle .*}
  
 represents element wise multiplication and 
  
    
      
        M
        (
        :
        ,
        i
        )
      
    
    {\displaystyle M(:,i)}
  
 is the 
  
    
      
        i
      
    
    {\displaystyle i}
  
th column of 
  
    
      
        M
      
    
    {\displaystyle M}
  
. Since the decoding step is not difficult, PP is specialized for generating 
  
    
      
        M
      
    
    {\displaystyle M}
  
.


==== Forming groups ====

A group/pool 
  
    
      
        ℓ
      
    
    {\displaystyle \ell }
  
 is
generated using a polynomial relation that specifies the indices of the samples contained in each pool. A set of input parameters determines the algorithm. For a prime number 
  
    
      
        p
        >
        1
      
    
    {\displaystyle p>1}
  
 and an integer 
  
    
      
        n
        ≥
        1
      
    
    {\displaystyle n\geq 1}
  
 any prime power is defined by 
  
    
      
        q
        =
        
          p
          
            n
          
        
      
    
    {\displaystyle q=p^{n}}
  
. For a dimension parameter 
  
    
      
        c
        ≥
        2
      
    
    {\displaystyle c\geq 2}
  
 the total number of samples is 
  
    
      
        n
        =
        
          q
          
            c
          
        
      
    
    {\displaystyle n=q^{c}}
  
 and the number of samples per pool is 
  
    
      
        
          q
          
            c
            −
            1
          
        
      
    
    {\displaystyle q^{c-1}}
  
.
Further, the
Finite field of order 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is denoted by 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
  
 
(i.e., the integers 
  
    
      
        {
        0
        ,
        1
        ,
        2
        ,
        …
        ,
        q
        −
        1
        }
      
    
    {\displaystyle \{0,1,2,\ldots ,q-1\}}
  
 defined by special arithmetic operations that ensure that addition and multiplication in 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
  
 remains in 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
  
).
The method arranges each sample in a grid and represents it by coordinates 
  
    
      
        x
        =
        (
        u
        ,
        v
        )
      
    
    {\displaystyle x=(u,v)}
  
. The coordinates are computed according to a polynomial relation using the integers

  
    
      
        1
        ≤
        l
        ≤
        c
        −
        1
      
    
    {\displaystyle 1\leq l\leq c-1}
  
, 
  
    
      
        0
        ≤
        
          u
          
            
              i
              
                l
              
            
          
        
        ≤
        q
        −
        1
      
    
    {\displaystyle 0\leq u_{i_{l}}\leq q-1}
  

  
    
      
        v
         
        =
         
        
          a
          
            c
            −
            1
          
        
         
        
          u
          
            
              i
              
                c
                −
                1
              
            
          
        
        +
        ⋯
        +
        a
         
        
          u
          
            
              i
              
                1
              
            
          
        
        +
        b
        ,
        
        a
        ,
        b
        ,
        
          u
          
            
              i
              
                l
              
            
          
        
        ∈
        
          
            F
          
          
            q
          
        
        .
      
    
    {\displaystyle v~=~a^{c-1}~u_{i_{c-1}}+\cdots +a~u_{i_{1}}+b,\quad a,b,u_{i_{l}}\in \mathbb {F} _{q}.}
  

The combination of looping through the 
  
    
      
        
          u
          
            
              i
              
                l
              
            
          
        
      
    
    {\displaystyle u_{i_{l}}}
  
 values is represented by a set with 
  
    
      
        
          q
          
            c
            −
            1
          
        
      
    
    {\displaystyle q^{c-1}}
  
 elements of a sequence of 
  
    
      
        d
        −
        1
      
    
    {\displaystyle d-1}
  
 integers, i.e.,

  
    
      
        
          u
          
            
              i
              
                1
              
            
          
        
        ×
        ⋯
        ×
        
          u
          
            
              i
              
                c
                −
                1
              
            
          
        
        =
        {
        (
        
          i
          
            1
          
        
        ,
        …
        ,
        
          i
          
            c
            −
            1
          
        
        )
        }
      
    
    {\displaystyle u_{i_{1}}\times \cdots \times u_{i_{c-1}}=\{(i_{1},\ldots ,i_{c-1})\}}
  
, where

  
    
      
        0
        ≤
        
          i
          
            l
          
        
        ≤
        q
        −
        1
      
    
    {\displaystyle 0\leq i_{l}\leq q-1}
  
. Without loss of generality, the combination is such that

  
    
      
        
          i
          
            d
            −
            1
          
        
      
    
    {\displaystyle i_{d-1}}
  
 cycles every 
  
    
      
        q
      
    
    {\displaystyle q}
  
 times, 
  
    
      
        
          i
          
            d
            −
            2
          
        
      
    
    {\displaystyle i_{d-2}}
  
 cycles every 
  
    
      
        
          q
          
            2
          
        
      
    
    {\displaystyle q^{2}}
  
 times until

  
    
      
        
          i
          
            1
          
        
      
    
    {\displaystyle i_{1}}
  
 cycles only once.
Formulas that compute the sample indices, and thus the corresponding pools, for fixed 
  
    
      
        a
      
    
    {\displaystyle a}
  
 and 
  
    
      
        b
      
    
    {\displaystyle b}
  
, are given by

  
    
      
        
          
            
              
                
                  u
                  
                    i
                  
                
              
              
                
                =
                
                  ∑
                  
                    l
                    =
                    1
                  
                  
                    c
                    −
                    1
                  
                
                 
                
                  q
                  
                    d
                    −
                    1
                    −
                    l
                  
                
                 
                
                  i
                  
                    l
                  
                
              
            
            
              
                
                  v
                  
                    
                      u
                      
                        i
                      
                    
                  
                
              
              
                
                =
                
                  ∑
                  
                    l
                    =
                    1
                  
                  
                    c
                    −
                    1
                  
                
                 
                
                  a
                  
                    l
                  
                
                 
                
                  i
                  
                    l
                  
                
                +
                b
                
                (
                
                  computed in 
                
                
                  
                    F
                  
                  
                    q
                  
                
                )
              
            
            
              
                
                  x
                  
                    q
                    
                      u
                      
                        i
                      
                    
                    +
                    
                      v
                      
                        
                          u
                          
                            i
                          
                        
                      
                    
                  
                
              
              
                
                =
                (
                
                  u
                  
                    i
                  
                
                ,
                
                  v
                  
                    
                      u
                      
                        i
                      
                    
                  
                
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}u_{i}&=\sum _{l=1}^{c-1}~q^{d-1-l}~i_{l}\\v_{u_{i}}&=\sum _{l=1}^{c-1}~a^{l}~i_{l}+b\quad ({\text{computed in }}\mathbb {F} _{q})\\x_{qu_{i}+v_{u_{i}}}&=(u_{i},v_{u_{i}})\end{aligned}}}
  

The computations in 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
  
 can be implemented with publicly available software libraries for finite fields, when 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is a prime power. When 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is a prime number then the computations in 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
  
 simplify to modulus arithmetics, i.e., 
  
    
      
        
          v
          
            
              u
              
                i
              
            
          
        
        =
        (
        
          ∑
          
            l
            =
            1
          
          
            c
            −
            1
          
        
        
          a
          
            l
          
        
        
          i
          
            l
          
        
        +
        b
        )
         
        
          mod
        
         
        q
      
    
    {\displaystyle v_{u_{i}}=(\sum _{l=1}^{c-1}a^{l}i_{l}+b)~{\text{mod}}~q}
  
. An example of how to generate one pool 
  
    
      
        ℓ
      
    
    {\displaystyle \ell }
  
 when

  
    
      
        a
        =
        1
        ,
        b
        =
        0
        ,
        c
        =
        2
      
    
    {\displaystyle a=1,b=0,c=2}
  
 is displayed in the table below, while the corresponding selection of samples is shown in the figure above.

This method uses 
  
    
      
        q
        (
        c
        −
        1
        )
        (
        d
        +
        1
        )
      
    
    {\displaystyle q(c-1)(d+1)}
  
 tests to exactly identify up to 
  
    
      
        d
      
    
    {\displaystyle d}
  
 positives among 
  
    
      
        n
        =
        
          q
          
            c
          
        
      
    
    {\displaystyle n=q^{c}}
  
 samples.
Because of this PP is particularly effective for large sample sizes, since the number of tests grows only linearly with respect to 
  
    
      
        c
      
    
    {\displaystyle c}
  
 while the samples grow exponentially with this parameter. However PP can also be effective for small sample sizes.


== Example applications ==
The generality of the theory of group testing lends it to many diverse applications, including clone screening, locating electrical shorts; high speed computer networks; medical examination, quantity searching, statistics; machine learning, DNA sequencing; cryptography; and data forensics. This section provides a brief overview of a small selection of these applications.


=== Multiaccess channels ===

A multiaccess channel is a communication channel that connects many users at once. Every user can listen and transmit on the channel, but if more than one user transmits at the same time, the signals collide, and are reduced to unintelligible noise. Multiaccess channels are important for various real-world applications, notably wireless computer networks and phone networks.
A prominent problem with multiaccess channels is how to assign transmission times to the users so that their messages do not collide. A simple method is to give each user their own time slot in which to transmit, requiring 
  
    
      
        n
      
    
    {\displaystyle n}
  
 slots. (This is called time division multiplexing, or TDM.) However, this is very inefficient, since it will assign transmission slots to users that may not have a message, and it is usually assumed that only a few users will want to transmit at any given time – otherwise a multiaccess channel is not practical in the first place.
In the context of group testing, this problem is usually tackled by dividing time into 'epochs' in the following way. A user is called 'active' if they have a message at the start of an epoch. (If a message is generated during an epoch, the user only becomes active at the start of the next one.) An epoch ends when every active user has successfully transmitted their message. The problem is then to find all the active users in a given epoch, and schedule a time for them to transmit (if they have not already done so successfully). Here, a test on a set of users corresponds to those users attempting a transmission. The results of the test are the number of users that attempted to transmit, 
  
    
      
        0
        ,
        1
        ,
      
    
    {\displaystyle 0,1,}
  
 and 
  
    
      
        
          2
          
            +
          
        
      
    
    {\displaystyle 2^{+}}
  
, corresponding respectively to no active users, exactly one active user (message successful) or more than one active user (message collision). Therefore, using an adaptive group testing algorithm with outcomes 
  
    
      
        {
        0
        ,
        1
        ,
        
          2
          
            +
          
        
        }
      
    
    {\displaystyle \{0,1,2^{+}\}}
  
, it can be determined which users wish to transmit in the epoch. Then, any user that has not yet made a successful transmission can now be assigned a slot to transmit, without wastefully assigning times to inactive users.


=== Machine learning and compressed sensing ===
Machine learning is a field of computer science that has many software applications such as DNA classification, fraud detection and targeted advertising. One of the main subfields of machine learning is the 'learning by examples' problem, where the task is to approximate some unknown function when given its value at a number of specific points. As outlined in this section, this function learning problem can be tackled with a group-testing approach.
In a simple version of the problem, there is some unknown function, 
  
    
      
        f
        :
        {
        0
        ,
        1
        
          }
          
            N
          
        
        →
        {
        0
        ,
        1
        }
      
    
    {\displaystyle f:\{0,1\}^{N}\to \{0,1\}}
  
 where 
  
    
      
        f
        (
        
          
            x
          
        
        )
        =
        
          
            a
          
        
        ⋅
        
          
            x
          
        
      
    
    {\displaystyle f({\textbf {x}})={\textbf {a}}\cdot {\textbf {x}}}
  
, and 
  
    
      
        
          
            a
          
        
        ∈
        {
        0
        ,
        1
        
          }
          
            N
          
        
      
    
    {\displaystyle {\textbf {a}}\in \{0,1\}^{N}}
  
 (using logical arithmetic: addition is logical OR and multiplication is logical AND). Here 
  
    
      
        
          
            a
          
        
      
    
    {\displaystyle {\textbf {a}}}
  
 is '
  
    
      
        d
      
    
    {\displaystyle d}
  
 sparse', which means that at most 
  
    
      
        d
        ≪
        N
      
    
    {\displaystyle d\ll N}
  
 of its entries are 
  
    
      
        1
      
    
    {\displaystyle 1}
  
. The aim is to construct an approximation to 
  
    
      
        f
      
    
    {\displaystyle f}
  
 using 
  
    
      
        t
      
    
    {\displaystyle t}
  
 point evaluations, where 
  
    
      
        t
      
    
    {\displaystyle t}
  
 is as small as possible. (Exactly recovering 
  
    
      
        f
      
    
    {\displaystyle f}
  
 corresponds to zero-error algorithms, whereas 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is approximated by algorithms that have a non-zero probability of error.)
In this problem, recovering 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is equivalent to finding 
  
    
      
        
          
            a
          
        
      
    
    {\displaystyle {\textbf {a}}}
  
. Moreover, 
  
    
      
        f
        (
        
          
            p
          
        
        )
        =
        1
      
    
    {\displaystyle f({\textbf {p}})=1}
  
 if and only if there is some index, 
  
    
      
        n
      
    
    {\displaystyle n}
  
, where 
  
    
      
        
          
            
              a
            
          
          
            n
          
        
        =
        
          
            
              p
            
          
          
            n
          
        
        =
        1
      
    
    {\displaystyle {\textbf {a}}_{n}={\textbf {p}}_{n}=1}
  
. Thus this problem is analogous to a group-testing problem with 
  
    
      
        d
      
    
    {\displaystyle d}
  
 defectives and 
  
    
      
        n
      
    
    {\displaystyle n}
  
 total items. The entries of 
  
    
      
        
          
            a
          
        
      
    
    {\displaystyle {\textbf {a}}}
  
 are the items, which are defective if they are 
  
    
      
        1
      
    
    {\displaystyle 1}
  
, 
  
    
      
        
          
            p
          
        
      
    
    {\displaystyle {\textbf {p}}}
  
 specifies a test, and a test is positive if and only if 
  
    
      
        f
        (
        
          
            p
          
        
        )
        =
        1
      
    
    {\displaystyle f({\textbf {p}})=1}
  
.
In reality, one will often be interested in functions that are more complicated, such as 
  
    
      
        f
        :
        
          
            C
          
          
            N
          
        
        →
        
          C
        
      
    
    {\displaystyle f:\mathbb {C} ^{N}\to \mathbb {C} }
  
, again where 
  
    
      
        f
        (
        
          
            x
          
        
        )
        =
        
          
            a
          
        
        ⋅
        
          
            x
          
        
      
    
    {\displaystyle f({\textbf {x}})={\textbf {a}}\cdot {\textbf {x}}}
  
. Compressed sensing, which is closely related to group testing, can be used to solve this problem.
In compressed sensing, the goal is to reconstruct a signal, 
  
    
      
        
          
            v
          
        
        ∈
        
          
            C
          
          
            N
          
        
      
    
    {\displaystyle {\textbf {v}}\in \mathbb {C} ^{N}}
  
, by taking a number of measurements. These measurements are modelled as taking the dot product of 
  
    
      
        
          
            v
          
        
      
    
    {\displaystyle {\textbf {v}}}
  
 with a chosen vector. The aim is to use a small number of measurements, though this is typically not possible unless something is assumed about the signal. One such assumption (which is common) is that only a small number of entries of 
  
    
      
        
          
            v
          
        
      
    
    {\displaystyle {\textbf {v}}}
  
 are significant, meaning that they have a large magnitude. Since the measurements are dot products of 
  
    
      
        
          
            v
          
        
      
    
    {\displaystyle {\textbf {v}}}
  
, the equation 
  
    
      
        M
        
          
            v
          
        
        =
        
          
            q
          
        
      
    
    {\displaystyle M{\textbf {v}}={\textbf {q}}}
  
 holds, where 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is a 
  
    
      
        t
        ×
        N
      
    
    {\displaystyle t\times N}
  
 matrix that describes the set of measurements that have been chosen and 
  
    
      
        
          q
        
      
    
    {\displaystyle \mathbf {q} }
  
 is the set of measurement results. This construction shows that compressed sensing is a kind of 'continuous' group testing.
The primary difficulty in compressed sensing is identifying which entries are significant. Once that is done, there are a variety of methods to estimate the actual values of the entries. This task of identification can be approached with a simple application of group testing. Here a group test produces a complex number: the sum of the entries that are tested. The outcome of a test is called  positive if it produces a complex number with a large magnitude, which, given the assumption that the significant entries are sparse, indicates that at least one significant entry is contained in the test.
There are explicit deterministic constructions for this type of combinatorial search algorithm, requiring 
  
    
      
        d
        
          2
          
            (
            
              log
              
                2
              
            
            ⁡
            
              log
              
                2
              
            
            ⁡
            N
            
              )
              
                O
                (
                1
                )
              
            
          
        
      
    
    {\displaystyle d2^{(\log _{2}\log _{2}N)^{O(1)}}}
  
 measurements. However, as with group-testing, these are sub-optimal, and random constructions (such as COMP) can often recover 
  
    
      
        f
      
    
    {\displaystyle f}
  
 sub-linearly in 
  
    
      
        N
      
    
    {\displaystyle N}
  
.


=== Multiplex assay design for COVID19 testing ===
During a pandemic such as the COVID-19 outbreak in 2020, virus detection assays are sometimes run using nonadaptive group testing designs. 
One example was provided by the Origami Assays project which released open source group testing designs to run on a laboratory standard 96 well plate.

In a laboratory setting, one challenge of group testing is the construction of the mixtures can be time-consuming and difficult to do accurately by hand.  Origami assays provided a workaround for this construction problem by providing paper templates to guide the technician on how to allocate patient samples across the test wells.
Using the largest group testing designs (XL3) it was possible to test 1120 patient samples in 94 assay wells.  If the true positive rate was low enough, then no additional testing was required.


=== Data forensics ===
Data forensics is a field dedicated to finding methods for compiling digital evidence of a crime. Such crimes typically involve an adversary modifying the data, documents or databases of a victim, with examples including the altering of tax records, a virus hiding its presence, or an identity thief modifying personal data.
A common tool in data forensics is the one-way cryptographic hash. This is a function that takes the data, and through a difficult-to-reverse procedure, produces a unique number called a hash. Hashes, which are often much shorter than the data, allow us to check if the data has been changed without having to wastefully store complete copies of the information: the hash for the current data can be compared with a past hash to determine if any changes have occurred. An unfortunate property of this method is that, although it is easy to tell if the data has been modified, there is no way of determining how: that is, it is impossible to recover which part of the data has changed.
One way to get around this limitation is to store more hashes – now of subsets of the data structure – to narrow down where the attack has occurred. However, to find the exact location of the attack with a naive approach, a hash would need to be stored for every datum in the structure, which would defeat the point of the hashes in the first place. (One may as well store a regular copy of the data.) Group testing can be used to dramatically reduce the number of hashes that need to be stored. A test becomes a comparison between the stored and current hashes, which is positive when there is a mismatch. This indicates that at least one edited datum (which is taken as defectiveness in this model) is contained in the group that generated the current hash.
In fact, the amount of hashes needed is so low that they, along with the testing matrix they refer to, can even be stored within the organisational structure of the data itself. This means that as far as memory is concerned the test can be performed 'for free'. (This is true with the exception of a master-key/password that is used to secretly determine the hashing function.)


== Notes ==


== References ==


=== Citations ===


=== General references ===
Ding-Zhu, Du; Hwang, Frank K. (1993). Combinatorial group testing and its applications. Singapore: World Scientific. ISBN 978-9810212933.
Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2007), Lectures 7.
Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2010), Lectures 10, 11, 28,  29
Du, D.; Hwang, F. (2006). Pooling Designs and Nonadaptive Group Testing. World Scientific. ISBN 9789814477864.
Aldridge, M.; Johnson, O.; Scarlett, J. (2019). "Group Testing: An Information Theory Perspective" (PDF). Foundations and Trends in Communications and Information Theory. 15 (3–4): 196–392. arXiv:1902.06002. doi:10.1561/0100000099. S2CID 62841593.
Porat, E.; Rothschild, A. (2011). "Explicit nonadaptive combinatorial group testing schemes". IEEE Transactions on Information Theory. 57 (12): 7982–89. arXiv:0712.3876. Bibcode:2011ITIT...57.7982P. doi:10.1109/TIT.2011.2163296. S2CID 8815474.
Kagan, Eugene; Ben-gal, Irad (2014), "A group testing algorithm with online informational learning", IIE Transactions, 46 (2): 164–184, doi:10.1080/0740817X.2013.803639, ISSN 0740-817X, S2CID 18588494


== See also ==
Balance puzzle