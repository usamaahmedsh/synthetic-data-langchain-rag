Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a data set.  MDS is used to translate distances between each pair of 
  
    
      
        n
      
    
    {\textstyle n}
  
 objects in a set into a configuration of 
  
    
      
        n
      
    
    {\textstyle n}
  
 points mapped into an abstract Cartesian space.
More technically, MDS refers to a set of related ordination techniques used in information visualization, in particular to display the information contained in a distance matrix. It is a form of non-linear dimensionality reduction.
Given a distance matrix with the distances between each pair of objects in a set, and a chosen number of dimensions, N, an MDS algorithm places each object into N-dimensional space (a lower-dimensional representation) such that the between-object distances are preserved as well as possible. For N = 1, 2, and 3, the resulting points can be visualized on a scatter plot.
Core theoretical contributions to MDS were made by James O. Ramsay of McGill University, who is also regarded as the founder of functional data analysis.


== Types ==
MDS algorithms fall into a taxonomy, depending on the meaning of the input matrix:


=== Classical multidimensional scaling ===
It is also known as Principal Coordinates Analysis (PCoA), Torgerson Scaling or Torgerson–Gower scaling. It takes an input matrix giving dissimilarities between pairs of items and outputs a coordinate matrix whose configuration minimizes a loss function called strain, which is given by

  
    
      
        
          
            Strain
          
          
            D
          
        
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        )
        =
        
          
            (
          
        
        
          
            
              
                ∑
                
                  i
                  ,
                  j
                
              
              
                
                  (
                
              
              
                b
                
                  i
                  j
                
              
              −
              
                x
                
                  i
                
                
                  T
                
              
              
                x
                
                  j
                
              
              
                
                  
                    )
                  
                
                
                  2
                
              
            
            
              
                ∑
                
                  i
                  ,
                  j
                
              
              
                b
                
                  i
                  j
                
                
                  2
                
              
            
          
        
        
          
            
              )
            
          
          
            1
            
              /
            
            2
          
        
        ,
      
    
    {\displaystyle {\text{Strain}}_{D}(x_{1},x_{2},...,x_{n})={\Biggl (}{\frac {\sum _{i,j}{\bigl (}b_{ij}-x_{i}^{T}x_{j}{\bigr )}^{2}}{\sum _{i,j}b_{ij}^{2}}}{\Biggr )}^{1/2},}
  
 
where 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 denote vectors in N-dimensional space, 
  
    
      
        
          x
          
            i
          
          
            T
          
        
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{i}^{T}x_{j}}
  
 denotes the scalar product between 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 and 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
, and 
  
    
      
        
          b
          
            i
            j
          
        
      
    
    {\displaystyle b_{ij}}
  
 are the elements of the matrix 
  
    
      
        B
      
    
    {\displaystyle B}
  
 defined on step 2 of the following algorithm, which are computed from the distances.

Steps of a Classical MDS algorithm:
Classical MDS uses the fact that the coordinate matrix 
  
    
      
        X
      
    
    {\displaystyle X}
  
 can be derived by eigenvalue decomposition from 
  
    
      
        B
        =
        X
        
          X
          ′
        
      
    
    {\textstyle B=XX'}
  
. And the matrix 
  
    
      
        B
      
    
    {\textstyle B}
  
 can be computed from proximity matrix 
  
    
      
        D
      
    
    {\textstyle D}
  
 by using double centering.
Set up the squared proximity matrix 
  
    
      
        
          D
          
            (
            2
            )
          
        
        =
        [
        
          d
          
            i
            j
          
          
            2
          
        
        ]
      
    
    {\textstyle D^{(2)}=[d_{ij}^{2}]}
  

Apply double centering: 
  
    
      
        B
        =
        −
        
          
            1
            2
          
        
        C
        
          D
          
            (
            2
            )
          
        
        C
      
    
    {\textstyle B=-{\frac {1}{2}}CD^{(2)}C}
  
 using the centering matrix 
  
    
      
        C
        =
        I
        −
        
          
            1
            n
          
        
        
          J
          
            n
          
        
      
    
    {\textstyle C=I-{\frac {1}{n}}J_{n}}
  
, where 
  
    
      
        n
      
    
    {\textstyle n}
  
 is the number of objects, 
  
    
      
        I
      
    
    {\textstyle I}
  
 is the 
  
    
      
        n
        ×
        n
      
    
    {\textstyle n\times n}
  
 identity matrix, and 
  
    
      
        
          J
          
            n
          
        
      
    
    {\textstyle J_{n}}
  
 is an 
  
    
      
        n
        ×
        n
      
    
    {\textstyle n\times n}
  
 matrix of all ones.
Determine the 
  
    
      
        m
      
    
    {\textstyle m}
  
 largest eigenvalues 
  
    
      
        
          λ
          
            1
          
        
        ,
        
          λ
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          λ
          
            m
          
        
      
    
    {\textstyle \lambda _{1},\lambda _{2},...,\lambda _{m}}
  
 and corresponding eigenvectors 
  
    
      
        
          e
          
            1
          
        
        ,
        
          e
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          e
          
            m
          
        
      
    
    {\textstyle e_{1},e_{2},...,e_{m}}
  
 of 
  
    
      
        B
      
    
    {\textstyle B}
  
 (where 
  
    
      
        m
      
    
    {\textstyle m}
  
 is the number of dimensions desired for the output).
Now, 
  
    
      
        X
        =
        
          E
          
            m
          
        
        
          Λ
          
            m
          
          
            1
            
              /
            
            2
          
        
      
    
    {\textstyle X=E_{m}\Lambda _{m}^{1/2}}
  
 , where 
  
    
      
        
          E
          
            m
          
        
      
    
    {\textstyle E_{m}}
  
 is the matrix of 
  
    
      
        m
      
    
    {\textstyle m}
  
 eigenvectors and 
  
    
      
        
          Λ
          
            m
          
        
      
    
    {\textstyle \Lambda _{m}}
  
 is the diagonal matrix of 
  
    
      
        m
      
    
    {\textstyle m}
  
 eigenvalues of 
  
    
      
        B
      
    
    {\textstyle B}
  
.
Classical MDS assumes metric distances. So this is not applicable for direct dissimilarity ratings.


=== Metric multidimensional scaling (mMDS) ===
It is a superset of classical MDS that generalizes the optimization procedure to a variety of loss functions and input matrices of known distances with weights and so on.  A useful loss function in this context is called stress, which is often minimized using a procedure called stress majorization. Metric MDS minimizes the cost function called “stress” which is a residual sum of squares:
  
    
      
        
          
            Stress
          
          
            D
          
        
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        )
        =
        
          
            
              ∑
              
                i
                ≠
                j
                =
                1
                ,
                .
                .
                .
                ,
                n
              
            
            
              
                (
              
            
            
              d
              
                i
                j
              
            
            −
            ‖
            
              x
              
                i
              
            
            −
            
              x
              
                j
              
            
            ‖
            
              
                
                  )
                
              
              
                2
              
            
          
        
        .
      
    
    {\displaystyle {\text{Stress}}_{D}(x_{1},x_{2},...,x_{n})={\sqrt {\sum _{i\neq j=1,...,n}{\bigl (}d_{ij}-\|x_{i}-x_{j}\|{\bigr )}^{2}}}.}
  

Metric scaling uses a power transformation with a user-controlled exponent 
  
    
      
        p
      
    
    {\textstyle p}
  
: 
  
    
      
        
          d
          
            i
            j
          
          
            p
          
        
      
    
    {\textstyle d_{ij}^{p}}
  
 and 
  
    
      
        −
        
          d
          
            i
            j
          
          
            2
            p
          
        
      
    
    {\textstyle -d_{ij}^{2p}}
  
 for distance. In classical scaling 
  
    
      
        p
        =
        1.
      
    
    {\textstyle p=1.}
  
 Non-metric scaling is defined by the use of isotonic regression to nonparametrically estimate a transformation of the dissimilarities.


=== Non-metric multidimensional scaling (NMDS) ===
In contrast to metric MDS, non-metric MDS finds both a non-parametric monotonic relationship between the dissimilarities in the item-item matrix and the Euclidean distances between items, and the location of each item in the low-dimensional space. 
Let 
  
    
      
        
          d
          
            i
            j
          
        
      
    
    {\displaystyle d_{ij}}
  
 be the dissimilarity between points 
  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
  
. Let 
  
    
      
        
          
            
              
                d
                ^
              
            
          
          
            i
            j
          
        
        =
        ‖
        
          x
          
            i
          
        
        −
        
          x
          
            j
          
        
        ‖
      
    
    {\displaystyle {\hat {d}}_{ij}=\|x_{i}-x_{j}\|}
  
 be the Euclidean distance between embedded points 
  
    
      
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{i},x_{j}}
  
.
Now, for each choice of the embedded points 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 and is a monotonically increasing function 
  
    
      
        f
      
    
    {\displaystyle f}
  
, define the "stress" function:

  
    
      
        S
        (
        
          x
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        ;
        f
        )
        =
        
          
            
              
                
                  ∑
                  
                    i
                    <
                    j
                  
                
                
                  
                    (
                  
                
                f
                (
                
                  d
                  
                    i
                    j
                  
                
                )
                −
                
                  
                    
                      
                        d
                        ^
                      
                    
                  
                  
                    i
                    j
                  
                
                
                  
                    
                      )
                    
                  
                  
                    2
                  
                
              
              
                
                  ∑
                  
                    i
                    <
                    j
                  
                
                
                  
                    
                      
                        d
                        ^
                      
                    
                  
                  
                    i
                    j
                  
                  
                    2
                  
                
              
            
          
        
        .
      
    
    {\displaystyle S(x_{1},...,x_{n};f)={\sqrt {\frac {\sum _{i<j}{\bigl (}f(d_{ij})-{\hat {d}}_{ij}{\bigr )}^{2}}{\sum _{i<j}{\hat {d}}_{ij}^{2}}}}.}
  

The factor of 
  
    
      
        
          ∑
          
            i
            <
            j
          
        
        
          
            
              
                d
                ^
              
            
          
          
            i
            j
          
          
            2
          
        
      
    
    {\displaystyle \sum _{i<j}{\hat {d}}_{ij}^{2}}
  
 in the denominator is necessary to prevent a "collapse". Suppose we define instead 
  
    
      
        S
        =
        
          
            
              ∑
              
                i
                <
                j
              
            
            
              
                (
              
            
            f
            (
            
              d
              
                i
                j
              
            
            )
            −
            
              
                
                  
                    d
                    ^
                  
                
              
              
                i
                j
              
            
            
              )
              
                2
              
            
          
        
      
    
    {\displaystyle S={\sqrt {\sum _{i<j}{\bigl (}f(d_{ij})-{\hat {d}}_{ij})^{2}}}}
  
, then it can be trivially minimized by setting 
  
    
      
        f
        =
        0
      
    
    {\displaystyle f=0}
  
, then collapse every point to the same point.
A few variants of this cost function exist. MDS programs automatically minimize stress in order to obtain the MDS solution.
The core of a non-metric MDS algorithm is a twofold optimization process. First the optimal monotonic transformation of the proximities has to be found. Secondly, the points of a configuration have to be optimally arranged, so that their distances match the scaled proximities as closely as possible. 
NMDS needs to optimize two objectives simultaneously. This is usually done iteratively:

Initialize 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 randomly, e. g. by sampling from a normal distribution.
Do until a stopping criterion (for example, 
  
    
      
        S
        <
        ϵ
      
    
    {\displaystyle S<\epsilon }
  
)
Solve for 
  
    
      
        f
        =
        arg
        ⁡
        
          min
          
            f
          
        
        S
        (
        
          x
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        ;
        f
        )
      
    
    {\displaystyle f=\arg \min _{f}S(x_{1},...,x_{n};f)}
  
 by isotonic regression.
Solve for 
  
    
      
        
          x
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        =
        arg
        ⁡
        
          min
          
            
              x
              
                1
              
            
            ,
            .
            .
            .
            ,
            
              x
              
                n
              
            
          
        
        S
        (
        
          x
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        ;
        f
        )
      
    
    {\displaystyle x_{1},...,x_{n}=\arg \min _{x_{1},...,x_{n}}S(x_{1},...,x_{n};f)}
  
 by gradient descent or other methods.
Return 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 and 
  
    
      
        f
      
    
    {\displaystyle f}
  

Louis Guttman's smallest space analysis (SSA) is an example of a non-metric MDS procedure.


=== Generalized multidimensional scaling (GMD) ===

An extension of metric multidimensional scaling, in which the target space is an arbitrary smooth non-Euclidean space. In cases where the dissimilarities are distances on a surface and the target space is another surface, GMDS allows finding the minimum-distortion embedding of one surface into another.


=== Super multidimensional scaling (SMDS) ===
An extension of MDS, known as Super MDS, incorporates both distance and angle information for improved source localization. Unlike traditional MDS, which uses only distance measurements, Super MDS processes both distance and angle-of-arrival (AOA) data algebraically (without iteration) to achieve better accuracy.
The method proceeds in the following steps:

Construct the Reduced Edge Gram Kernel: For a network of 
  
    
      
        N
      
    
    {\displaystyle N}
  
 sources in an 
  
    
      
        η
      
    
    {\displaystyle \eta }
  
-dimensional space, define the edge vectors as 
  
    
      
        
          v
          
            i
          
        
        =
        
          x
          
            m
          
        
        −
        
          x
          
            n
          
        
      
    
    {\displaystyle v_{i}=x_{m}-x_{n}}
  
. The dissimilarity is given by 
  
    
      
        
          k
          
            i
            ,
            j
          
        
        =
        ⟨
        
          v
          
            i
          
        
        ,
        
          v
          
            j
          
        
        ⟩
      
    
    {\displaystyle k_{i,j}=\langle v_{i},v_{j}\rangle }
  
. Assemble these into the full kernel 
  
    
      
        K
        =
        V
        
          V
          
            T
          
        
      
    
    {\displaystyle K=VV^{T}}
  
, and then form the reduced kernel using the 
  
    
      
        N
        −
        1
      
    
    {\displaystyle N-1}
  
 independent vectors: 
  
    
      
        
          
            
              K
              ¯
            
          
        
        =
        [
        V
        
          ]
          
            (
            N
            −
            1
            )
            ×
            η
          
        
         
        [
        V
        
          ]
          
            (
            N
            −
            1
            )
            ×
            η
          
          
            T
          
        
      
    
    {\displaystyle {\bar {K}}=[V]_{(N-1)\times \eta }\ [V]_{(N-1)\times \eta }^{T}}
  
,
Eigen-Decomposition: Compute the eigen-decomposition of 
  
    
      
        
          
            
              K
              ¯
            
          
        
      
    
    {\displaystyle {\bar {K}}}
  
,
Estimate Edge Vectors: Recover the edge vectors as 
  
    
      
        
          
            
              V
              ^
            
          
        
        =
        
          
            (
          
        
        
          U
          
            M
            ×
            η
          
        
        
        
          Λ
          
            η
            ×
            η
          
          
            ⊙
            
              
                1
                2
              
            
          
        
        
          
            
              )
            
          
          
            T
          
        
      
    
    {\displaystyle {\hat {V}}={\Bigl (}U_{M\times \eta }\,\Lambda _{\eta \times \eta }^{\odot {\frac {1}{2}}}{\Bigr )}^{T}}
  
,
Procrustes Alignment:  Retrieve 
  
    
      
        
          
            
              V
              ^
            
          
        
      
    
    {\displaystyle {\hat {V}}}
  
 from 
  
    
      
        V
      
    
    {\displaystyle V}
  
 via Procrustes Transformation,
Compute Coordinates: Solve the following linear equations to compute the coordinate estimates 
  
    
      
        
          
            (
            
              
                
                  1
                  
                    
                      
                        |
                      
                    
                  
                  
                    
                      0
                    
                    
                      1
                      ×
                      N
                      −
                      1
                    
                  
                
              
              
                
                  
                    
                      [
                      C
                      ]
                    
                    
                      N
                      −
                      1
                      ×
                      N
                    
                  
                
              
            
            )
          
        
        ⋅
        
          
            (
            
              
                
                  
                    
                      x
                    
                    
                      1
                    
                  
                
              
              
                
                  [
                  
                    X
                  
                  
                    ]
                    
                      N
                      −
                      1
                      ×
                      η
                    
                  
                
              
            
            )
          
        
        =
        
          
            (
            
              
                
                  
                    
                      x
                    
                    
                      1
                    
                  
                
              
              
                
                  [
                  
                    V
                  
                  
                    ]
                    
                      N
                      −
                      1
                      ×
                      η
                    
                  
                
              
            
            )
          
        
        ,
      
    
    {\displaystyle {\begin{pmatrix}1\vline \mathbf {0} _{1\times N-1}\\\hline \mathbf {[C]} _{N-1\times N}\end{pmatrix}}\cdot {\begin{pmatrix}\mathbf {x} _{1}\\\hline [\mathbf {X} ]_{N-1\times \eta }\end{pmatrix}}={\begin{pmatrix}\mathbf {x} _{1}\\\hline [\mathbf {V} ]_{N-1\times \eta }\end{pmatrix}},}
  

This concise approach reduces the need for multiple anchors and enhances localization precision by leveraging angle constraints.


== Details ==
The data to be analyzed is a collection of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 objects (colors, faces, stocks, . . .) on which a distance function is defined,

  
    
      
        
          d
          
            i
            ,
            j
          
        
        :=
      
    
    {\displaystyle d_{i,j}:=}
  
 distance between 
  
    
      
        i
      
    
    {\displaystyle i}
  
-th and 
  
    
      
        j
      
    
    {\displaystyle j}
  
-th objects.
These distances are the entries of the dissimilarity matrix

  
    
      
        D
        :=
        
          
            (
            
              
                
                  
                    d
                    
                      1
                      ,
                      1
                    
                  
                
                
                  
                    d
                    
                      1
                      ,
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    d
                    
                      1
                      ,
                      M
                    
                  
                
              
              
                
                  
                    d
                    
                      2
                      ,
                      1
                    
                  
                
                
                  
                    d
                    
                      2
                      ,
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    d
                    
                      2
                      ,
                      M
                    
                  
                
              
              
                
                  ⋮
                
                
                  ⋮
                
                
                
                  ⋮
                
              
              
                
                  
                    d
                    
                      M
                      ,
                      1
                    
                  
                
                
                  
                    d
                    
                      M
                      ,
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    d
                    
                      M
                      ,
                      M
                    
                  
                
              
            
            )
          
        
        .
      
    
    {\displaystyle D:={\begin{pmatrix}d_{1,1}&d_{1,2}&\cdots &d_{1,M}\\d_{2,1}&d_{2,2}&\cdots &d_{2,M}\\\vdots &\vdots &&\vdots \\d_{M,1}&d_{M,2}&\cdots &d_{M,M}\end{pmatrix}}.}
  

The goal of MDS is, given 
  
    
      
        D
      
    
    {\displaystyle D}
  
, to find 
  
    
      
        M
      
    
    {\displaystyle M}
  
 vectors 

  
    
      
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            M
          
        
        ∈
        
          
            R
          
          
            N
          
        
      
    
    {\displaystyle x_{1},\ldots ,x_{M}\in \mathbb {R} ^{N}}
  
 such that

  
    
      
        ‖
        
          x
          
            i
          
        
        −
        
          x
          
            j
          
        
        ‖
        ≈
        
          d
          
            i
            ,
            j
          
        
      
    
    {\displaystyle \|x_{i}-x_{j}\|\approx d_{i,j}}
  
 for all 
  
    
      
        i
        ,
        j
        ∈
        
          1
          ,
          …
          ,
          M
        
      
    
    {\displaystyle i,j\in {1,\dots ,M}}
  
,
where 
  
    
      
        ‖
        ⋅
        ‖
      
    
    {\displaystyle \|\cdot \|}
  
 is a vector norm.  In classical MDS, this norm is the Euclidean distance, but, in a broader sense, it may be a metric or arbitrary distance function.  For example, when dealing with mixed-type data that contain numerical as well as categorical descriptors, Gower's distance is a common alternative.
In other words, MDS attempts to find a mapping from the 
  
    
      
        M
      
    
    {\displaystyle M}
  
 objects into 
  
    
      
        
          
            R
          
          
            N
          
        
      
    
    {\displaystyle \mathbb {R} ^{N}}
  
 such that distances are preserved.  If the dimension 
  
    
      
        N
      
    
    {\displaystyle N}
  
 is chosen to be 2 or 3, we may plot the vectors 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 to obtain a visualization of the similarities between the 
  
    
      
        M
      
    
    {\displaystyle M}
  
 objects.  Note that the vectors 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 are not unique: With the Euclidean distance, they may be arbitrarily translated, rotated, and reflected, since these transformations do not change the pairwise distances 
  
    
      
        ‖
        
          x
          
            i
          
        
        −
        
          x
          
            j
          
        
        ‖
      
    
    {\displaystyle \|x_{i}-x_{j}\|}
  
.
(Note: The symbol 
  
    
      
        
          R
        
      
    
    {\displaystyle \mathbb {R} }
  
 indicates the set of real numbers, and the notation 
  
    
      
        
          
            R
          
          
            N
          
        
      
    
    {\displaystyle \mathbb {R} ^{N}}
  
 refers to the Cartesian product of 
  
    
      
        N
      
    
    {\displaystyle N}
  
 copies of 
  
    
      
        
          R
        
      
    
    {\displaystyle \mathbb {R} }
  
, which is an 
  
    
      
        N
      
    
    {\displaystyle N}
  
-dimensional vector space over the field of the real numbers.)
There are various approaches to determining the vectors 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
.  Usually, MDS is formulated as an optimization problem, where 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            M
          
        
        )
      
    
    {\displaystyle (x_{1},\ldots ,x_{M})}
  
 is found as a minimizer of some cost function, for example,

  
    
      
        
          
            
              a
              r
              g
              m
              i
              n
            
            
              
                x
                
                  1
                
              
              ,
              …
              ,
              
                x
                
                  M
                
              
            
          
        
        
          ∑
          
            i
            <
            j
          
        
        (
        ‖
        
          x
          
            i
          
        
        −
        
          x
          
            j
          
        
        ‖
        −
        
          d
          
            i
            ,
            j
          
        
        
          )
          
            2
          
        
        .
        
      
    
    {\displaystyle {\underset {x_{1},\ldots ,x_{M}}{\mathrm {argmin} }}\sum _{i<j}(\|x_{i}-x_{j}\|-d_{i,j})^{2}.\,}
  

A solution may then be found by numerical optimization techniques.  For some particularly chosen cost functions, minimizers can be stated analytically in terms of matrix eigendecompositions.


== Procedure ==
There are several steps in conducting MDS research:

Formulating the problem – What variables do you want to compare?  How many variables do you want to compare? What purpose is the study to be used for?
Obtaining input data – For example, :- Respondents are asked a series of questions. For each product pair, they are asked to rate similarity (usually on a 7-point Likert scale from very similar to very dissimilar). The first question could be for Coke/Pepsi for example, the next for Coke/Hires rootbeer, the next for Pepsi/Dr Pepper, the next for Dr Pepper/Hires rootbeer, etc. The number of questions is a function of the number of brands and can be calculated as 
  
    
      
        Q
        =
        N
        (
        N
        −
        1
        )
        
          /
        
        2
      
    
    {\displaystyle Q=N(N-1)/2}
  
 where Q is the number of questions and N is the number of brands. This approach is referred to as the “Perception data : direct approach”. There are two other approaches. There is the “Perception data : derived approach” in which products are decomposed into attributes that are rated on a semantic differential scale. The other is the “Preference data approach” in which respondents are asked their preference rather than similarity.
Running the MDS statistical program – Software for running the procedure is available in many statistical software packages.  Often there is a choice between Metric MDS (which deals with interval or ratio level data), and Nonmetric MDS (which deals with ordinal data).
Decide number of dimensions – The researcher must decide on the number of dimensions they want the computer to create. Interpretability of the MDS solution is often important, and lower dimensional solutions will typically be easier to interpret and visualize. However, dimension selection is also an issue of balancing underfitting and overfitting. Lower dimensional solutions may underfit by leaving out important dimensions of the dissimilarity data. Higher dimensional solutions may overfit to noise in the dissimilarity measurements. Model selection tools like AIC, BIC, Bayes factors, or cross-validation can thus be useful to select the dimensionality that balances underfitting and overfitting.
Mapping the results and defining the dimensions – The statistical program (or a related module) will map the results. The map will plot each product (usually in two-dimensional space). The proximity of products to each other indicate either how similar they are or how preferred they are, depending on which approach was used. How the dimensions of the embedding actually correspond to dimensions of system behavior, however, are not necessarily obvious. Here, a subjective judgment about the correspondence can be made (see perceptual mapping).
Test the results for reliability and validity – Compute R-squared to determine what proportion of variance of the scaled data can be accounted for by the MDS procedure. An R-square of 0.6 is considered the minimum acceptable level.  An R-square of 0.8 is considered good for metric scaling and .9 is considered good for non-metric scaling. Other possible tests are Kruskal’s Stress, split data tests, data stability tests (i.e., eliminating one brand), and test-retest reliability.
Report the results comprehensively – Along with the mapping, at least distance measure (e.g., Sorenson index, Jaccard index) and reliability (e.g., stress value) should be given. It is also very advisable to give the algorithm (e.g., Kruskal, Mather), which is often defined by the program used (sometimes replacing the algorithm report), if you have given a start configuration or had a random choice, the number of runs, the assessment of dimensionality, the Monte Carlo method results, the number of iterations, the assessment of stability, and the proportional variance of each axis (r-square).


== Implementations ==
ELKI includes two MDS implementations.
MATLAB includes two MDS implementations (for classical (cmdscale) and non-classical (mdscale) MDS respectively).
The R programming language offers several MDS implementations, e.g. base cmdscale function, packages smacof (mMDS and nMDS), and vegan (weighted MDS).
scikit-learn contains function sklearn.manifold.MDS.


== See also ==

Data clustering
t-distributed stochastic neighbor embedding
Factor analysis
Discriminant analysis
Dimensionality reduction
Distance geometry
Cayley–Menger determinant
Sammon mapping
Iconography of correlations


== References ==


== Bibliography ==