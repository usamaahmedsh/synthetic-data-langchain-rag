The zero page or base page is the block of memory at the very beginning of a computer's address space; that is, the page whose starting address is zero. The size of a page depends on the context, and the significance of zero page memory versus higher addressed memory is highly dependent on machine architecture. For example, the Motorola 6800 and MOS Technology 6502 processor families treat the first 256 bytes of memory specially, whereas many other processors do not.
Unlike more modern hardware, in the 1970s computer RAM speed was similar to that of  CPUs. Thus it made sense to have few registers and use the main memory as an extended pool of extra registers. In machines with a relatively wide 16-bit address bus and comparatively narrow 8-bit data bus, calculating an address in memory could take several cycles. The zero page's one-byte address was smaller and therefore faster to read and calculate than other locations, making the zero page useful for high-performance code.
Zero page addressing now has mostly historical significance, since the developments in integrated circuit technology have made adding more registers to a CPU less expensive and CPU operations much faster than RAM accesses.


== Size ==
The actual size of the zero page in bytes is determined by the microprocessor design and in older designs, is often equal to the largest value that can be referenced by the processor's indexing registers. For example, the aforementioned 8-bit processors have 8-bit index registers and a page size of 256 bytes. Therefore, their zero page extends from address 0 to address 255.


== Computers with few CPU registers ==
In early computers, such as the PDP-8, the zero page had a special fast addressing mode, which facilitated its use for temporary storage of data and compensated for the paucity of CPU registers.  The PDP-8 had only one register, so zero page addressing was essential.  In the original PDP-10 KA-10 models, the available registers are simply the first 16 words, 36-bits long, of main memory.  Those locations can be accessed as both registers and memory locations.
Unlike more modern hardware, 1970s-era computer RAM was as fast as the CPU.  Thus, it made sense to have few registers and use the main memory as an extended pool of extra registers.  In machines with a 16-bit address bus and 8-bit data bus, accessing zero page locations could be faster than accessing other locations.  Since zero page locations could be addressed by a single byte, the instructions accessing them could be shorter and hence faster-loading.
For example, the MOS Technology 6502 family has only one general purpose register: the accumulator.  To offset this limitation and gain a performance advantage, the 6502 is designed to make special use of the zero page, providing instructions whose operands are eight bits, instead of 16, thus requiring fewer memory fetch cycles.  Many instructions are coded differently for zero page and non-zero page addresses; this is called zero-page addressing in 6502 terminology (it is called direct addressing in Motorola 6800 terminology; the Western Design Center 65C816 also refers to zero page addressing as direct page addressing):

In 6502 assembly language, the above two instructions both accomplish the same thing: they load the value of memory location $12 into the .A (accumulator) register ($ is Motorola/MOS Technology assembly language notation for a hexadecimal number).  However, the first instruction is only two bytes long and requires three clock cycles to complete.  The second instruction is three bytes in length and requires four clock cycles to execute.  This difference in execution time could become significant in repetitive code.
Some processors, such as the Motorola 6809 and the aforementioned WDC 65C816, implement a “direct page register” (DP) that tells the processor the starting address in RAM of what is considered to be zero page.  In this context, zero page addressing is notional; the actual access would not be to the physical zero page if DP is loaded with some address other than $00 (or $0000 in the case of the 65C816).


== Interrupt vectors ==
Some computer architectures still reserve the beginning of address space for other purposes, though; for instance, Intel x86 systems reserve the first 256 double-words of address space for the interrupt vector table (IVT) if they run in real mode.
A similar technique of using the zero page for hardware related vectors was employed in the ARM architecture. In badly written programs this could lead to "ofla" behaviour, where a program tries to read information from an unintended memory area, and treats executable code as data or vice versa. This is especially problematic if the zero page area is used to store system jump vectors and the firmware is tricked into overwriting them.


== CP/M ==

In 8-bit CP/M, the zero page is used for communication between the running program and the operating system.


== Page addressing ==
In some processor architectures, like that of the Intel 4004 4-bit processor, memory was divided into (256 byte) pages and special precautions had to be taken when the control flow crossed page boundaries, as some machine instructions exhibited different behaviour if located in the last few instructions of a page, so that only few instructions were recommended to jump between pages.


== Null pointers ==
Contrary to the zero page's original preferential use, some modern operating systems such as FreeBSD, Linux, Solaris,  macOS, and Microsoft Windows actually make the zero page inaccessible to trap uses of null pointers. Such pointer values may legitimately indicate uninitialized values or sentinel nodes, but they do not point to valid objects. Buggy code may try to access an object via a null pointer, and this can be trapped at the operating system level as a memory access violation. By making invalid the whole page, instead of just the singular zero-valued null pointer, the Operating System can trap on code that, for example, has a null pointer pointing to a structure, and accesses a member of the structure at an offset from the null pointer.


== See also ==
Low memory – the first 64 KB of memory (segment 0) in DOS
Page boundary relocation


== References ==


== Further reading ==
Bray, Andrew C.; Dickens, Adrian C.; Holmes, Mark A. (1983). The Advanced User Guide for the BBC Microcomputer (3 ed.). The Cambridge Microcomputer Centre. ISBN 0-946827-00-1.
Roth, Richard L. (February 1978) [1977]. "Relocation Is Not Just Moving Programs". Dr. Dobb's. Vol. 3, no. 2. Ridgefield, CA, USA: People's Computer Company. pp. 14–20 (70–76). ISBN 0-8104-5490-4. #22. Archived from the original on 2019-04-20. Retrieved 2019-04-19.
"1. Introduction: Segment Alignment". 8086 Family Utilities - User's Guide for 8080/8085-Based Development Systems (PDF). Revision E (A620/5821 6K DD ed.). Santa Clara, California, USA: Intel Corporation. May 1982 [1980, 1978]. p. 1-6. Order Number: 9800639-04. Archived (PDF) from the original on 2020-02-29. Retrieved 2020-02-29.