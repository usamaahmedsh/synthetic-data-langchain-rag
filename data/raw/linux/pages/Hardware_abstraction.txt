A hardware abstraction is software that provides access to hardware in a way that hides details that might otherwise make using the hardware difficult. Typically, access is provided via an interface that allows devices that share a level of compatibility to be accessed via the same software interface even though the devices provide different hardware interfaces. A hardware abstraction can support the development of cross-platform applications. 
Early software was developed without a hardware abstraction which required a developer to understand multiple devices in order to provide compatibility. With hardware abstraction, the software leverages the abstraction to access significantly different hardware via the same interface. The abstraction (often implemented in the operating system) which then generates hardware-dependent instructions. This allows software to be compatible with all devices supported by the abstraction.
Consider the joystick device, of which there are many physical implementations. It could be accessible via an application programming interface (API) that support many different joysticks to support common operations such as moving, firing, configuring sensitivity and so on. A Joystick abstraction hides details (e.g., register format, I2C address) so that a programmer using the abstraction, does not need to understand the details of the device's physical interface. This also allows code reuse since the same code can process standardized messages from any kind of implementation which supplies the joystick abstraction. For example, a "nudge forward" can be from a potentiometer or from a capacitive touch sensor that recognizes "swipe" gestures, as long as they both provide a signal related to "movement".
As physical limitations may vary with hardware, an API can do little to hide that, other than by assuming a "least common denominator" model. Thus, certain deep architectural decisions from the implementation may become relevant to users of a particular instantiation of an abstraction.
A good metaphor is the abstraction of transportation. Both bicycling and driving a car are transportation. They both have commonalities (e.g., you must steer) and physical differences (e.g., power source). One can always specify the abstraction "drive to" and let the implementor decide whether bicycling or driving a car is best. The "wheeled terrestrial transport" function is abstracted and the details of "how to drive" are encapsulated.


== Programming ==
A high-level programming language provides for hardware abstraction by allowing a programmer write an algorithm without using instructions that are unique to a 
central processing unit (CPU) or its instruction set architecture (ISA) â€“ the primitive operations of a CPU. For example, a compiler generates the CPU-specific instructions for a particular ISA. In this way, source code can support portability across multiple platforms.


== Hardware abstraction layer ==
A hardware abstraction layer (HAL) is an abstraction layer, implemented in software, between the physical hardware of a computer and the software that runs on that computer. Its function is to hide differences in hardware from most of the operating system kernel, so that most of the kernel-mode code does not need to be changed to run on systems with different hardware. On Microsoft Windows, HAL can basically be considered to be the driver for the motherboard and allows instructions from higher level computer languages to communicate with lower level components, but prevents direct access to the hardware.
CP/M (CP/M BIOS), DOS (DOS BIOS), Solaris, Linux, BSD, macOS, and some other portable operating systems also have a HAL, even if it is not explicitly designated as such. Some operating systems, such as Linux, have the ability to insert one while running, like Adeos. The NetBSD operating system is widely known as having a clean hardware abstraction layer which allows it to be highly portable. As part of this system are uvm(9)/pmap(9), bus_space(9), bus_dma(9) and other subsystems. Popular buses which are used on more than one architecture are also abstracted, such as ISA, EISA, PCI, PCIe, etc., allowing drivers to also be highly portable with a minimum of code modification.
Operating systems having a defined HAL are more easily portable across different hardware. This is especially important for embedded systems that run on dozens of different platforms.
In a software stack, the HAL resides below the application programming interface (API), whereas the application layer (often written in a high-level language) resides above the API and communicates with the hardware by calling functions in the API.


=== Microsoft Windows ===

The Windows NT kernel has a HAL in the kernel space between hardware and the executive services that are contained in the file NTOSKRNL.EXE under %WINDOWS%\system32\hal.dll. This allows portability of the Windows NT kernel-mode code to a variety of processors, with different memory management unit architectures, and a variety of systems with different I/O bus architectures; most of that code runs without change on those systems, when compiled for the instruction set applicable to those systems. For example, the SGI Intel x86-based workstations were not IBM PC compatible workstations, but due to the HAL, Windows 2000 was able to run on them.
Since Windows Vista and Windows Server 2008, the HAL used is automatically determined during startup.


=== AS/400 ===
An "extreme" example of a HAL can be found in the System/38 and AS/400 architectures, currently implemented in the IBM i operating system. Most compilers for those systems generate an abstract machine code; the Licensed Internal Code, or LIC, translates this virtual machine code into native code for the processor on which it is running and executes the resulting native code. (The exceptions are compilers that generate the LIC itself; those compilers are not available outside IBM.) This was so successful that application software and operating system software above the LIC layer that were compiled on the original S/38 run without modification and without recompilation on the latest AS/400 systems, despite the fact that the underlying hardware has been changed dramatically; at least three different types of processors have been in use.


=== Android ===
Android introduced a HAL known as the "vendor interface" (codenamed "Project Treble") on version 8.0 "Oreo". It abstracts low-level code from the Android OS framework, and they must be made forward compatible to support future versions of Android to ease the development of firmware updates. Before Project Treble, Android relied on various non-standardized legacy HALs.
Halium is an Android-based HAL used by several mobile operating systems such as Ubuntu Touch and LuneOS to run on smartphones with Android pre-installed.


== See also ==
Basic Input/Output System
Unified Extensible Firmware Interface
Firmware
Advanced Configuration and Power Interface
Device tree
Board support package
DeviceKit
Haiku Device Kit
HAL (software)
Hardware-dependent software
Nanokernel
Picokernel
Protection ring


== References ==


== Further reading ==
"Advanced RISC Computing Specification" (PDF). MIPS Technologies. p. 23. Retrieved 26 February 2013.
Silberschatz, Abraham; Galvin, Peter Bear; Gagne, Greg (2002). Operating System Concepts (6 ed.). ISBN 0-471-41743-2.