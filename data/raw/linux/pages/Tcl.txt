Tcl (pronounced "tickle" or "TCL"; originally Tool Command Language) is a high-level, general-purpose, interpreted, dynamic programming language. It was designed with the goal of being very simple but powerful. Tcl casts everything into the mold of a command, even programming constructs like variable assignment and procedure definition. Tcl supports multiple programming paradigms, including object-oriented, imperative, functional, and procedural styles.
It is commonly embedded into C applications for rapid prototyping, scripted applications, GUIs, and testing. Tcl interpreters are available for many operating systems, allowing Tcl code to run on a wide variety of systems. Because Tcl is a very compact language, it is used on embedded systems platforms, both in its full form and in several other small-footprint versions.
The popular combination of Tcl with the Tk extension is referred to as Tcl/Tk (pronounced "tickle teak" or "tickle TK") and enables building a graphical user interface (GUI) natively in Tcl. Tcl/Tk is included in the standard Python installation in the form of Tkinter.


== History ==
The Tcl programming language was created in the spring of 1988 by John Ousterhout while he was working at the University of California, Berkeley. Originally "born out of frustration", according to the author, with programmers devising their own languages for extending electronic design automation (EDA) software and, more specifically, the VLSI design tool Magic, which was a professional focus for John at the time. Later Tcl gained acceptance on its own. Ousterhout was awarded the ACM Software System Award in 1997 for Tcl/Tk.
The name originally comes from "Tool Command Language", but is conventionally written Tcl rather than TCL.

Tcl conferences and workshops are held in both the United States and Europe. Several corporations, including FlightAware use Tcl as part of their products.


== Features ==

Tcl's features include

All operations are commands, including language structures. They are written in prefix notation.
Commands commonly accept a variable number of arguments (are variadic).
Everything can be dynamically redefined and overridden. Actually, there are no keywords, so even control structures can be added or changed, although this is not advisable.
All data types can be manipulated as strings, including source code. Internally, variables have types like integer and double, but converting is purely automatic.
Variables are not declared, but assigned to. Use of a non-defined variable results in an error.
Fully dynamic, class-based object system, TclOO, including advanced features such as meta-classes, filters, and mixins.
Event-driven interface to sockets and files. Time-based and user-defined events are also possible.
Variable visibility restricted to lexical (static) scope by default, but uplevel and upvar allowing procs to interact with the enclosing functions' scopes.
All commands defined by Tcl itself generate error messages on incorrect usage.
Extensibility, via C, C++, Java, Python, and Tcl.
Interpreted language using bytecode
Full Unicode (3.1 in the beginning, regularly updated) support, first released 1999.
Regular expressions
Cross-platform: Windows API; Unix, Linux, Macintosh etc.
Close, cross-platform integration with windowing (GUI) interface Tk.
Multiple distribution mechanisms exist:
Full development version (for Windows e.g. ActiveState Tcl, see [1])
Tclkits (single file executable containing a complete scripting runtime, only about 4 megabytes in size), Starkits (wrapping mechanism for delivering an application in a self-contained, installation-free, and highly portable way) and Starpacks (combine Starkit with Tclkit to produce a Starpack â€“ a single platform specific executable file, ideal for easy deployment)
The Jim Interpreter, a small footprint Tcl implementation
Freely distributable source code under a BSD license.


=== Safe-Tcl ===
Safe-Tcl is a subset of Tcl that has restricted features so that Tcl scripts cannot harm their hosting machine or application. File system access is limited and arbitrary system commands are prevented from execution. It uses a dual interpreter model with the untrusted interpreter running code in an untrusted script. It was designed by Nathaniel Borenstein and Marshall Rose to include active messages in e-mail. Safe-Tcl can be included in e-mail when the application/safe-tcl and multipart/enabled-mail are supported. The functionality of Safe-Tcl has since been incorporated as part of the standard Tcl/Tk releases.


== Syntax and fundamental semantics ==
The syntax and semantics of Tcl are covered by twelve rules known as the Dodekalogue.
A Tcl script consists of a series of command invocations. A command invocation is a list of words separated by whitespace and terminated by a newline or semicolon. The first word is the name of a command, which may be built into the language, found in an available library, or defined in the script itself. The subsequent words serve as arguments to the command:

commandName argument1 argument2 ... argumentN

The following example uses the puts (short for "put string") command to display a string of text on the host console:

This sends the string "Hello, World!" to the standard output device along with an appended newline character.
Variables and the results of other commands can be substituted into strings, such as in this example which uses the set and expr commands to store the result of a calculation in a variable (note that Tcl does not use = as an assignment operator), and then uses puts to print the result together with some explanatory text:

The # character introduces a comment. Comments can appear anywhere the interpreter is expecting a command name.

As seen in these examples, there is one basic construct in the language: the command. Quoting mechanisms and substitution rules determine how the arguments to each command are processed.
One special substitution occurs before the parsing of any commands or arguments. If the final character on a line (i.e., immediately before a newline) is a backslash, then the backslash-newline combination (and any spaces or tabs immediately following the newline) are replaced by a single space. This provides a line continuation mechanism, whereby long lines in the source code can be wrapped to the next line for the convenience of readers.
Continuing with normal argument processing, a word that begins with a double-quote character (") extends to the next double-quote character. Such a word can thus contain whitespace and semicolons without those characters being interpreted as having any special meaning (i.e., they are treated as normal text characters). A word that begins with an opening curly-brace character ({) extends to the next closing curly-brace character (}). Inside curly braces all forms of substitution are suppressed except the previously mentioned backslash-newline elimination. Words not enclosed in either construct are known as bare words.
In bare and double-quoted words, three types of substitution may occur:

Command substitution replaces the contents of balanced square brackets with the result of evaluating the script contained inside. For example, [expr 1+2+3] is replaced by the result of evaluating the contained expression (in this case 6).
Variable substitution replaces the name of a variable prefixed with a dollar sign with the contents (or value) of the variable. For example, $foo is replaced by the contents of the variable called "foo". The variable name may be surrounded by curly braces to separate it from subsequent text in otherwise ambiguous cases (e.g., ${foo}ing).
Backslash substitution replaces a backslash followed by a letter with another character. For example, \n is replaced by a newline.
Substitution proceeds left-to-right in a single scan through each word. Any substituted text will not be scanned again for possible further substitutions. However, any number of substitutions can appear in a single word.
From Tcl 8.5 onwards, any word may be prefixed by {*}, which causes the word to be split apart into its constituent sub-words for the purposes of building the command invocation (similar to the ,@ sequence of Lisp's quasiquote feature).
As a consequence of these rules, the result of any command may be used as an argument to any other command. Note that, unlike in Unix command shells, Tcl does not reparse any string unless explicitly directed to do so, which makes interactive use more cumbersome, but scripted use more predictable (e.g., the presence of spaces in filenames does not cause difficulties).
The single equality sign (=) serves no special role in the language at all. The double equality sign (==) is the test for equality which is used in expression contexts such as the expr command and in the first argument to if. (Both commands are part of the standard library; they have no special place in the library and can be replaced if desired.)
The majority of Tcl commands, especially in the standard library, are variadic, and the proc (the constructor for scripted command procedures) allows one to define default values for unspecified arguments and a catch-all argument to allow the code to process arbitrary numbers of arguments.
Tcl is not statically typed: each variable may contain integers, floats, strings, lists, command names, dictionaries, or any other value; values are reinterpreted (subject to syntactic constraints) as other types on demand. However, values are immutable and operations that appear to change them actually just return a new value instead.


=== Basic commands ===
The most important commands that refer to program execution and data operations are:

set writes a new value to a variable (creates a variable if did not exist). If used only with one argument, it returns the value of the given variable (it must exist in this case).
proc defines a new command, whose execution results in executing a given Tcl script, written as a set of commands. return can be used to immediately return control to the caller.
The usual execution control commands are:

if executes given script body (second argument), if the condition (first argument) is satisfied. It can be followed by additional arguments starting from elseif with the alternative condition and body, or else with the complementary block.
while repeats executing given script body, as long as the condition (first argument) remains satisfied
foreach executes given body where the control variable is assigned list elements one by one.
for shortcut for initializing the control variable, condition (as in while) and the additional "next iteration" statement (command executed after executing the body)
switch simplifies conditional code evaluation. It compares its argument to multiple cases and executes code associated with the matching case. It supports string comparison, regular expressions and glob-style comparison.
Those above looping commands can be additionally controlled by the following commands:

break interrupts the body execution and returns from the looping command
continue interrupts the body execution, but the control is still given back to the looping command. For while it means to loop again, for for and foreach, pick up the next iteration.
return interrupts the execution of the current body no matter how deep inside a procedure, until reaching the procedure boundary, and returns given value to the caller.


=== Advanced commands ===
expr passes the argument to a separate expression interpreter and returns the evaluated value. Note that the same interpreter is used also for "conditional" expression for if and looping commands.
list creates a list comprising all the arguments, or an empty string if no argument is specified. The lindex command may be used on the result to re-extract the original arguments.
array manipulates array variables.
dict manipulates dictionary (since 8.5), which are lists with an even number of elements where every two elements are interpreted as a key/value pair.
regexp matches a regular expression against a string.
regsub Performs substitutions based on regular expression pattern matching.
uplevel is a command that allows a command script to be executed in a scope other than the current innermost scope on the stack.
upvar creates a link to variable in a different stack frame.
namespace lets you create, access, and destroy separate contexts for commands and variables.
apply applies an anonymous function (since 8.5).
coroutine, yield, and yieldto create and produce values from coroutines (since 8.6).
try lets you trap and process errors and exceptions (since 8.6).
catch lets you trap exceptional returns.
zlib provides access to the compression and checksumming facilities of the Zlib library (since 8.6).


=== Uplevel ===
uplevel allows a command script to be executed in a scope other than the current innermost scope on the stack. Because the command script may itself call procedures that use the uplevel command, this has the net effect of transforming the call stack into a call tree.
It was originally implemented to permit Tcl procedures to reimplement built-in commands (like for, if or while) and still have the ability to manipulate local variables. For example, the following Tcl script is a reimplementation of the for command (omitting exception handling):


=== Upvar ===
upvar arranges for one or more local variables in the current procedure to refer to variables in an enclosing procedure call or to global variables. The upvar command simplifies the implementation of call-by-name procedure calling and also makes it easier to build new control constructs as Tcl procedures.
A decr command that works like the built-in incr command except it subtracts the value from the variable instead of adding it:


=== Tailcall ===
Recursion is supported in Tcl and simplified by the tailcall command. The command reuses the current stack frame for the next invocation, thereby safeguarding against stack overflow problems.
This is an example computing the Collatz sequence:

The tailcall command is not limited to the caller and can be used to invoke other functions as well.


=== Object-oriented ===

Tcl 8.6 added a built-in dynamic object system, TclOO, in 2012. It includes features such as:

Class-based object system. This is what most programmers expect from OO.
Allows per-object customization and dynamic redefinition of classes.
Meta-classes
Filters
Mixins
A system for implementing methods in custom ways, so that package authors that want significantly different ways of doing a method implementation may do so fairly simply.

Tcl did not have object oriented (OO) syntax until 2012, so various extension packages emerged to enable object-oriented programming. They are widespread in existing Tcl source code. Popular extensions include:

incr Tcl
XOTcl
Itk
Snit
STOOOP
TclOO was not only added to build a strong object oriented system, but also to enable extension packages to build object oriented abstractions using it as a foundation. After the release of TclOO, incr Tcl was updated to use TclOO as its foundation.


== Web application development ==
Tcl Web Server is a pure-Tcl implementation of an HTTP protocol server. It runs as a script on top of a vanilla Tcl interpreter.
Apache Rivet is an open source programming system for Apache HTTP Server that allows developers to use Tcl as a scripting language for creating dynamic web applications. Rivet is similar to PHP, ASP, and JSP. Rivet was primarily developed by Damon Courtney, David Welton, Massimo Manghi, Harald Oehlmann and Karl Lehenbauer. Rivet can use any of the thousands of publicly available Tcl packages that offer countless features such as database interaction (Oracle, PostgreSQL, MySQL, SQLite, etc.), or interfaces to popular applications such as the GD Graphics Library.


== Interfacing with other languages ==
Tcl interfaces natively with the C language. This is because it was originally written to be a framework for providing a syntactic front-end to commands written in C, and all commands in the language (including things that might otherwise be keywords, such as if or while) are implemented this way. Each command implementation function is passed an array of values that describe the (already substituted) arguments to the command, and is free to interpret those values as it sees fit.
Digital logic simulators often include a Tcl scripting interface for simulating Verilog, VHDL and SystemVerilog hardware languages.
Tools exist (e.g. SWIG, Ffidl) to automatically generate the necessary code to connect arbitrary C functions and the Tcl runtime, and Critcl does the reverse, allowing embedding of arbitrary C code inside a Tcl script and compiling it at runtime into a DLL.


== Extension packages ==
The Tcl language has always allowed for extension packages, which provide additional functionality, such as a GUI, terminal-based application automation, database access, and so on. Commonly used extensions include:

Tk
The most popular Tcl extension is the Tk toolkit, which provides a graphical user interface library for a variety of operating systems. Each GUI consists of one or more frames. Each frame has a layout manager.
Expect
One of the other very popular Tcl extensions is Expect extension. The early close relationship of Expect with Tcl is largely responsible for the popularity of Tcl in prolific areas of use such as in Unix testing, where Expect was (and still is today) employed very successfully to automate telnet, ssh, and serial sessions to perform many repetitive tasks (i.e., scripting of formerly interactive-only applications). Tcl was the only way to run Expect, so Tcl became very popular in these areas of industry.
Tile/Ttk
Tile/Ttk is a styles and theming widget collection that can replace most of the widgets in Tk with variants that are truly platform native through calls to an operating system's API. Themes covered in this way are Windows XP, Windows Classic, Qt (that hooks into the X11 KDE environment libraries) and Aqua (Mac OS X). A theme can also be constructed without these calls using widget definitions supplemented with image pixmaps. Themes created this way include Classic Tk, Step, Alt/Revitalized, Plastik and Keramik. Under Tcl 8.4, this package is known as Tile, while in Tcl 8.5 it has been folded into the core distribution of Tk (as Ttk).
Tix
Tix, the Tk Interface eXtension, is a set of user interface components that expand the capabilities of Tcl/Tk and Python applications. It is an open source software package maintained by volunteers in the Tix Project Group and released under a BSD-style license.
Itcl/IncrTcl
Itcl is an object system for Tcl, and is normally named as [incr Tcl] (that being the way to increment in Tcl, similar in fashion to the name C++).
Tcllib
Tcllib is a set of scripted packages for Tcl that can be used with no compilation steps.
Tklib
Tklib is a collection of utility modules for Tk, and a companion to Tcllib.
tDOM
tDOM is a Tcl extension for parsing XML, based on the  Expat parser
TclTLS
TclTLS is OpenSSL extension to Tcl.
TclUDP
The TclUDP extension provides a simple library to support User Datagram Protocol (UDP) sockets in Tcl.
TWAPI
TWAPI (Tcl Windows API) is an extension to Tcl providing  bindings to the Windows API.
Databases
Tcl Database Connectivity (TDBC), part of Tcl 8.6, is a common database access interface for Tcl scripts. It currently supports drivers for accessing MySQL, ODBC, PostgreSQL and SQLite databases. More are planned for the future. Access to databases is also supported through database-specific extensions, of which there are many available.


== See also ==

Eggdrop
Expect
TclX
Tkdesk
Comparison of Tcl integrated development environments
Comparison of programming languages
List of programming languages
Environment Modules


== References ==


== Further reading ==


== External links ==

Official website 
Tcl Sources, main Tcl and Tk source code download website
Tcler's Wiki
TCL Script Archive
TkDocs