cron is a shell command for scheduling a job (i.e. command or shell script) to run periodically at a fixed time, date, or interval. As scheduled, it is known as a cron job, Although typically used to automate system maintenance and administration it can be used to automate any task. cron is most suitable for scheduling repetitive tasks as scheduling a one-time task can be accomplished via at.
The command name originates from Chronos, the Greek word for time.
The command is generally available on Unix-like operating systems.


== Overview ==
The actions of cron are driven by a crontab (cron table) file. The crontab files are stored where the lists of jobs and other instructions to the cron daemon are kept. Users can have their own individual crontab files and often there is a system-wide crontab file (usually in /etc or a subdirectory of /etc e.g. /etc/cron.d) that only system administrators can edit.
Each line of a crontab file represents a job, and looks like this:

  * * * * * <command to execute>
# | | | | |
# | | | | day of the week (0–6) (Sunday to Saturday; 
# | | | month (1–12)             7 is also Sunday on some systems)
# | | day of the month (1–31)
# | hour (0–23)
# minute (0–59)

The syntax of each line expects a cron expression made of five fields which represent the time to execute the command, followed by a shell command to execute.
While normally the job is executed when the time/date specification fields all match the current time and date, there is one exception: if both "day of month" (field 3) and "day of week" (field 5) are restricted (do not contain "*"), then one or both must match the current day. 
For example, the following clears the Apache error log at one minute past midnight (00:01) every day, assuming that the default shell for the cron user is Bourne shell compliant:

This example runs a shell program called export_dump.sh at 23:45 (11:45 PM) every Saturday.

Note: On some systems it is also possible to specify */n to run for every n-th interval of time. Also, specifying multiple specific time intervals can be done with commas (e.g., 1,2,3). The line below would output "hello world" to the command line every 5th minute of every first, second and third hour (i.e., 01:00, 01:05, 01:10, up until 03:55). 
The configuration file for a user can be edited by calling crontab -e regardless of where the actual implementation stores this file.
Some cron implementations, such as the popular 4th BSD edition written by Paul Vixie and included in many Linux distributions, add a sixth field: an account username that runs the specified job (subject to user existence and permissions). This is allowed only in the system crontabs—not in others, which are each assigned to a single user to configure. The sixth field is alternatively sometimes used for year instead of an account username—the nncron daemon for Windows does this.
The Amazon EventBridge implementation of cron does not use 0 based day of week, instead it is 1-7 SUN-SAT (instead of 0-6), as well as supporting additional expression features such as first-weekday and last-day-of-month.


=== Nonstandard predefined scheduling definitions ===
Some cron implementations support the following non-standard macros:

@reboot configures a job to run once when the daemon is started. Since cron is typically never restarted, this typically corresponds to the machine being booted. This behavior is enforced in some variations of cron, such as that provided in Debian, so that simply restarting the daemon does not re-run @reboot jobs.
@reboot can be useful if there is a need to start up a server or daemon under a particular user, and the user does not have access to configure init to start the program.


=== Cron permissions ===
These two files play an important role:

/etc/cron.allow – If this file exists, it must contain the user's name for that user to be allowed to use cron jobs.
/etc/cron.deny – If the cron.allow file does not exist but the /etc/cron.deny file does exist then, to use cron jobs, users must not be listed in the /etc/cron.deny file.
Note that if neither of these files exists then, depending on site-dependent configuration parameters, either only the super user can use cron jobs, or all users can use cron jobs.


=== Time zone handling ===
Most cron implementations simply interpret crontab entries in the system time zone setting that the cron daemon runs under.  This can be a source of dispute if a large multi-user machine has users in several time zones, especially if the system default time zone includes the potentially confusing DST. Thus, a cron implementation may as a special case recognize lines of the form "CRON_TZ=<time zone>" in user crontabs, interpreting subsequent crontab entries relative to that time zone.


== History ==


=== Early versions ===
The cron in Version 7 Unix was a system service (later called a daemon) invoked from /etc/rc when the operating system entered multi-user mode. Its algorithm was straightforward:

Read /usr/lib/crontab
Determine if any commands must run at the current date and time, and if so, run them as the superuser, root.
Sleep for one minute
Repeat from step 1.
This version of cron was basic and robust but it also consumed resources whether it found any work to do or not. In an experiment at Purdue University in the late 1970s to extend cron's service to all 100 users on a time-shared VAX, it was found to place too much load on the system.


=== Multi-user capability ===
The next version of cron, with the release of Unix System V, was created to extend the capabilities of cron to all users of a Unix system, not just the superuser. Though this may seem trivial today with most Unix and Unix-like systems having powerful processors and small numbers of users, at the time it required a new approach on a one-MIPS system having roughly 100 user accounts.
In the August, 1977 issue of the Communications of the ACM, W. R. Franta and Kurt Maly published an article titled "An efficient data structure for the simulation event set", describing an event queue data structure for discrete event-driven simulation systems that demonstrated "performance superior to that of commonly used simple linked list algorithms", good behavior given non-uniform time distributions, and worst case complexity 
  
    
      
        θ
        
          (
          
            
              n
            
          
          )
        
      
    
    {\displaystyle \theta \left({\sqrt {n}}\right)}
  
, "n" being the number of events in the queue.
A Purdue graduate student, Robert Brown, reviewing this article, recognized the parallel between cron and discrete event simulators, and created an implementation of the Franta–Maly event list manager (ELM) for experimentation.  Discrete event simulators run in virtual time, peeling events off the event queue as quickly as possible and advancing their notion of "now" to the scheduled time of the next event. Running the event simulator in "real time" instead of virtual time created a version of cron that spent most of its time sleeping, waiting for the scheduled time to execute the task at the head of the event list.
The following school year brought new students into the graduate program at Purdue, including Keith Williamson, who joined the systems staff in the Computer Science department. As a "warm up task" Brown asked him to flesh out the prototype cron into a production service, and this multi-user cron went into use at Purdue in late 1979. This version of cron wholly replaced the /etc/cron that was in use on the computer science department's VAX 11/780 running 32/V.
The algorithm used by this cron is as follows:

On start-up, look for a file named .crontab in the home directories of all account holders.
For each crontab file found, determine the next time in the future that each command must run.
Place those commands on the Franta–Maly event list with their corresponding time and their "five field" time specifier.
Enter main loop:
Examine the task entry at the head of the queue, compute how far in the future it must run.
Sleep for that period of time.
On awakening and after verifying the correct time, execute the task at the head of the queue (in background) with the privileges of the user who created it.
Determine the next time in the future to run this command and place it back on the event list at that time value.
Additionally, the daemon responds to SIGHUP signals to rescan modified crontab files and schedules special "wake up events" on the hour and half-hour to look for modified crontab files. Much detail is omitted here concerning the inaccuracies of computer time-of-day tracking, Unix alarm scheduling, explicit time-of-day changes, and process management, all of which account for the majority of the lines of code in this cron. This cron also captured the output of stdout and stderr and e-mailed any output to the crontab owner.
The resources consumed by this cron scale only with the amount of work it is given and do not inherently increase over time, with the exception of periodically checking for changes.
Williamson completed his studies and departed the University with a Masters of Science in Computer Science and joined AT&T Bell Labs in Murray Hill, New Jersey, and took this cron with him. At Bell Labs, he and others incorporated the Unix at command into cron, moved the crontab files out of users' home directories (which were not host-specific) and into a common host-specific spool directory, and of necessity added the crontab command to allow users to copy their crontabs to that spool directory.
This version of cron later appeared largely unchanged in Unix System V and in BSD and their derivatives, Solaris from Sun Microsystems, IRIX from Silicon Graphics, HP-UX from Hewlett-Packard, and AIX from IBM. Technically, the original license for these implementations should be with the Purdue Research Foundation who funded the work, but this took place at a time when little concern was given to such matters.


=== Modern versions ===
With the advent of the GNU Project and Linux, new crons appeared. The most prevalent of these is the Vixie cron, originally coded by Paul Vixie in 1987. Version 3 of Vixie cron was released in late 1993. Version 4.1 was renamed to ISC Cron and was released in January 2004. Version 3, with some minor bugfixes, is used in most distributions of Linux and BSDs.
In 2007, Red Hat forked vixie-cron 4.1 to the cronie project, adding features such as PAM and SELinux support. In 2009, anacron 2.3 was merged into cronie. Anacron is not an independent cron program however; another cron job must call it. 
DragonFly's dcron was made by its founder Matt Dillon, and its maintainership was taken over by Jim Pryor in 2010.
In 2003, Dale Mellor introduced mcron, a cron variant written in Guile which provides cross-compatibility with Vixie cron while also providing greater flexibility as it allows arbitrary scheme code to be used in scheduling calculations and job definitions. Since both the mcron daemon and the crontab files are usually written in scheme (though mcron also accepts traditional Vixie crontabs), the cumulative state of a user's job queue is available to their job code, which may be scheduled to run iff the results of other jobs meet certain criteria. Mcron is deployed by default under the Guix package manager, which includes provisions (services) for the package manager to monadically emit mcron crontabs while both ensuring that packages needed for job execution are installed and that the corresponding crontabs correctly refer to them.
A webcron solution schedules ring tasks to run on a regular basis wherever cron implementations are not available in a web hosting environment.


=== Standardization efforts ===
In 2025, the Open Cron Pattern Specification (OCPS) was published to address fragmentation in cron syntax across different implementations. OCPS 1.0 provides a formal specification of the Vixie cron dialect, codifying the five-field pattern format with explicit rules for previously ambiguous edge cases.
The specification is designed as a backward-compatible superset, with future versions planned to incrementally add features such as predefined schedules, second-level precision, and advanced calendar modifiers while maintaining compatibility with earlier versions.


== Cron expression ==
A cron expression is a string comprising five, six, or seven fields separated by white space that represents a set of times, normally as a schedule to execute some routine.
Comments begin with a comment mark #, and must be on a line by themselves.

The month and weekday abbreviations are not case-sensitive.
In the particular case of the system crontab file (/etc/crontab), a user field inserts itself before the command. It is generally set to 'root'.

Asterisk ( * )
Asterisks (also known as wildcard) represents "all". For example, using "* * * * *" will run every minute. Using "* * * * 1" will run every minute only on Monday. Using six asterisks means every second when seconds are supported.
Comma ( , )
Commas are used to separate items of a list. For example, using "MON,WED,FRI" in the 5th field (day of week) means Mondays, Wednesdays and Fridays.
Hyphen ( - )
Hyphen defines ranges. For example, "2000-2010" indicates every year between 2000 and 2010, inclusive.
Percent ( % )
Percent-signs (%) in the command, unless escaped with backslash (\), are changed into newline characters, and all data after the first % are sent to the command  as standard input.


=== Non-standard characters ===
The following are non-standard characters and exist only in some cron implementations, such as the Quartz Java scheduler.

L
'L' stands for "last". When used in the day-of-week field, it allows specifying constructs such as "the last Friday" ("5L") of a given month. In the day-of-month field, it specifies the last day of the month.
W
The 'W' character is allowed for the day-of-month field. This character is used to specify the weekday (Monday-Friday) nearest the given day. As an example, if "15W" is specified as the value for the day-of-month field, the meaning is: "the nearest weekday to the 15th of the month." So, if the 15th is a Saturday, the trigger fires on Friday the 14th. If the 15th is a Sunday, the trigger fires on Monday the 16th. If the 15th is a Tuesday, then it fires on Tuesday the 15th. However, if "1W" is specified as the value for day-of-month, and the 1st is a Saturday, the trigger fires on Monday the 3rd, as it does not 'jump' over the boundary of a month's days. The 'W' character can be specified only when the day-of-month is a single day, not a range or list of days.
Hash (#)
'#' is allowed for the day-of-week field, and must be followed by a number between one and five. It allows specifying constructs such as "the second Friday" of a given month. For example, entering "5#3" in the day-of-week field corresponds to the third Friday of every month.
Question mark (?)
In some implementations, used instead of '*' for leaving either day-of-month or day-of-week blank. Other cron implementations substitute "?" with the start-up time of the cron daemon, so that ? ? * * * * would be updated to 25 8 * * * * if cron started-up on 8:25am, and would run at this time every day until restarted again.
Slash (/)
In vixie-cron, slashes can be combined with ranges to specify step values. For example, */5 in the minutes field indicates every 5 minutes (see note below about frequencies). It is shorthand for the more verbose POSIX form 5,10,15,20,25,30,35,40,45,50,55,00. POSIX does not define a use for slashes; its rationale (commenting on a BSD extension) notes that the definition is based on System V format but does not exclude the possibility of extensions.
Note that frequencies in general cannot be expressed; only step values which evenly divide their range express accurate frequencies (for minutes and seconds, that's /2, /3, /4, /5, /6, /10, /12, /15, /20 and /30  because 60 is evenly divisible by those numbers; for hours, that's /2, /3, /4, /6, /8 and /12); all other possible "steps" and all other fields yield inconsistent "short" periods at the end of the time-unit before it "resets" to the next minute, second, or day; for example, entering */5 for the day field sometimes executes after 1, 2, or 3 days, depending on the month and leap year; this is because cron is stateless (it does not remember the time of the last execution nor count the difference between it and now, required for accurate frequency counting—instead, cron is a mere pattern-matcher).
Some language-specific libraries offering crontab scheduling ability do not require "strict" ranges 15-59/XX to the left of the slash when ranges are used. In these cases, 15/XX is the same as a vixie-cron schedule of 15-59/10 in the minutes section. Similarly, you can remove the extra -23 from 0-23/XX, -31 from 1-31/XX, and -12 from 1-12/XX for hours, days, and months; respectively.
H
'H' is used in the Jenkins continuous integration system to indicate that a "hashed" value is substituted. Thus instead of a fixed number such as '20 * * * *' which means at 20 minutes after the hour every hour, 'H * * * *' indicates that the task is performed every hour at an unspecified but invariant time for each task. This allows spreading out tasks over time, rather than having all of them start at the same time and compete for resources.


== See also ==
at (command)
Launchd
List of POSIX commands
Scheduling (computing)
systemd – incorporates cron equivalent (called timers)
fcron
Windows Task Scheduler


== Note ==


== References ==


== External links ==

crontab: schedule periodic background work – Shell and Utilities Reference, The Single UNIX Specification, Version 5 from The Open Group
GNU cron (mcron)
ISC Cron 4.1
[1]