Job Control Language (JCL) is a programming language for scripting and launching  batch jobs on IBM mainframe computers. JCL code determines which programs to run, and with which files and devices for input and output. Parameters in the JCL can also provide accounting information for tracking the resources used by a job and can set which machine the job should run on.
There are two major variants based on host platform and associated lineage. One version is available on the platform lineage that starts with DOS/360 and has progressed to z/VSE. The other version starts with OS/360 and continues to z/OS which includes JES extensions, Job Entry Control Language (JECL). The variants share basic syntax and concepts but have significant differences. The VM operating system does not have JCL as such; the CP and CMS components each have command languages.  
Generically, a job control language is any programming language for job control; not just the IBM mainframe one.


== Terminology ==
JCL-specific terminology includes:

Data set
A file; either temporary or permanent; located on a disk drive, tape storage, or other device.

Partitioned data set (PDS)
A collection of files; commonly used to store textual data such as source code, assembler macros (SYS1.MACLIB), system configuration (SYS1.PARMLIB), reusable JCL procedures (SYS1.PROCLIB), etc. As a collection of files, a PDS is like to an archive file (ZIP, TAR, etc.) which in turn is like a file system directory. A PDS can contain executable code (load modules or program objects) which makes a PDS like a Unix-based static library. A member, once stored, cannot be updated although a member can be deleted and replaced, such as via the IEBUPDTE utility. Since the 1989 release of MVS DFP 3.2, an enhanced version, partitioned data set extended (PDSE) has been available.

Member
A file (data set) in a PDS. A member can be accessed by specifying the name of the PDS with the member name in parentheses. For example, the system macro GETMAIN in SYS1.MACLIB can be referenced as SYS1.MACLIB(GETMAIN). 

Unix system services (USS)
A complete Unix environment running as part of the MVS base control program. It allows Unix files, scripts, tasks, and programs to run on a mainframe in a POSIX-compliant Unix environment without virtualization.


== Motivation ==
Originally, mainframe systems were oriented toward batch processing. Many batch jobs require setup, with specific requirements for main storage, and dedicated devices such as magnetic tapes, private disk volumes, and printers set up with special forms. JCL was developed as a means of ensuring that all required resources are available before a job is scheduled to run. For example, many systems, such as Linux allow identification of required datasets to be specified on the command line, and therefore subject to substitution by the shell,  or generated by the program at run-time.
On these systems the operating system job scheduler has little or no idea of the requirements of the job. In contrast, JCL explicitly specifies all required datasets and devices. The scheduler can pre-allocate the resources prior to releasing the job to run. This helps to avoid "deadlock", where job A holds resource R1 and requests resource R2, while concurrently running job B holds resource R2 and requests R1. In such cases the only solution is for the computer operator to terminate one of the jobs, which then needs to be restarted. With job control, if job A is scheduled to run, job B will not be started until job A completes or releases the required resources.


== Features common to DOS and OS JCL ==


=== Jobs, steps and procedures ===
For both DOS and OS the unit of work is the job. A job consists of one or several steps, each of which is a request to run one specific program. For example, before the days of relational databases, a job to produce a printed report for management might consist of the following steps: a user-written program to select the appropriate records and copy them to a temporary file; sort the temporary file into the required order, usually using a general-purpose utility; a user-written program to present the information in a way that is easy for the end-users to read and includes other useful information such as sub-totals; and a user-written program to format selected pages of the end-user information for display on a monitor or terminal.
In both DOS and OS JCL the first "card" must be the JOB card, which: 

Identifies the job.
Usually provides information to enable the computer services department to bill the appropriate user department.
Defines how the job as a whole is to be run, e.g. its priority relative to other jobs in the queue.
Procedures (commonly called procs) are pre-written JCL for steps or groups of steps, inserted into a job. Both JCLs allow such procedures. Procs are used for repeating steps which are used several times in one job, or in several different jobs. They save programmer time and reduce the risk of errors. To run a procedure one simply includes in the JCL file a single "card" which copies the procedure from a specified file, and inserts it into the jobstream. Also, procs can include parameters to customize the procedure for each use.


=== Basic syntax ===
Both DOS and OS JCL have a maximum usable line length of 80 characters, because when DOS/360 and OS/360 were first used the main method of providing new input to a computer system was 80-column punched cards. It later became possible to submit jobs via disk or tape files with longer record lengths, but the operating system's job submission components ignored everything after character 80.
Strictly speaking both operating system families use only 71 characters per line. Characters 73-80 are usually card sequence numbers which the system printed on the end-of-job report and are useful for identifying the locations of any errors reported by the operating system. Character 72 is usually left blank, but it can contain a nonblank character to indicate that the JCL statement is continued onto the next card.
All commands, parameter names and values have to be in capitals, except for USS filenames.
All lines except for in-stream input (see below) have to begin with a slash "/", and all lines which the operating system processes have to begin with two slashes // - always starting in the first column. However, there are two exceptions: the delimiter statement and the comment statement. A delimiter statements begins with a slash and an asterisk (/*), and a comment statement in OS JCL begins with a pair of slashes and asterisk (//*) or an asterisk in DOS JCL.
Many JCL statements are too long to fit within 71 characters, but can be extended on to an indefinite number of continuation cards by:

The structure of the most common types of card is:


=== In-stream input ===
DOS and OS JCL both allow in-stream input, i.e. "cards" which are to be processed by the application program rather than the operating system. Data which is to be kept for a long time will normally be stored on disk, but before the use of interactive terminals became common the only way to create and edit such disk files was by supplying the new data on cards.
DOS and OS JCL have different ways of signaling the start of in-stream input, but both end in-stream input with /* at column 1 of the card following the last in-stream data card. This makes the operating system resume processing JCL in the card following the /* card.

OS JCL: DD statements can be used to describe in-stream data, as well as data sets. A DD statement dealing with in-stream data has an asterisk (*) following the DD identifier, e.g. //SYSIN DD *. JCL statements can be included as part of in-stream data by using the DD DATA statements.
An operand named DLM allowed specifying a delimiter (default is "/*"). Specifying an alternate delimiter allows JCL to be read as data, for example to copy procedures to a library member or to submit a job to the internal reader.
An example, which submits a job to the Internal Reader (INTRDR) and then deletes two files is:

The program called PICALC1K will await (TYPRUN=HOLD) being released manually
The program called IEFBR14 will run NOW and upon completion, the two existing files, PICALC.4DGTS and PICALC.5DGTS will be deleted.
DOS JCL: Simply enter the in-stream data after the EXEC card for the program.


=== Complexity ===
Fred Brooks, who supervised the OS/360 project in which JCL was created, called it "the worst computer programming language ever devised by anybody, anywhere" in The Design of Design, where he used it as the example in the chapter "How Expert Designers Go Wrong". He attributed this to the failure of the designers to realize that JCL is, in fact, a programming language.
Much of the complexity of OS JCL, in particular, derives from the large number of options for specifying dataset information.  While files on Unix-like operating systems are abstracted into ordered streams of bytes, with the task of reading and writing structured data belonging exclusively with user-level programs (which, ultimately, ingest and emit such streams), and the practical details of data storage and access handled in large part by the operating system without the knowledge of user programs; datasets on OS/360 and its successors expose their file types and sizes, record types and lengths, block sizes, device-specific information like magnetic tape density, and label information.  Although there are system defaults for many options, there is still a lot to be specified by the programmer, through a combination of JCL and information coded in the program.  The more information coded in the program, the less flexible it is, since information in the program overrides anything in the JCL; thus, most information is usually supplied through JCL.
For example, to copy a file on Unix operating system, the user would enter a command like:

cp oldFile newFile

The following example, using JCL, might be used to copy a file on OS/360:

A second explanation for the complexity of JCL is the different expectations for running a job from those found in a PC or Unix-like environment.

Low-end System/360 CPUs were less powerful and more expensive than the mid-1980s PCs for which MS-DOS was designed. OS/360 was intended for systems with a minimum memory size of 32 KB and DOS/360 for systems with a minimum of 16 KB. A 360/30 CPU—low-end when System/360 was announced in 1964—processed 1.8K to 34.5K instructions per second. The first IBM PC in 1981 had 16 KB or 64 KB of memory and would process about 330K instructions per second. As a result, JCL had to be easy for the computer to process, and ease of use by programmers was a much lower priority. In this era, programmers were much cheaper than computers.
JCL was designed for batch processing. As such, it has to tell the operating system everything, including what to do depending on the result of a step. For example, DISP=(NEW,CATLG,DELETE) means "if the program runs successfully, create a new file and catalog it; otherwise delete the new file."  Programs run on a PC frequently depend on the user to clean up after processing problems.
System/360 machines were designed to be shared by all the users in an organization. So the JOB card tells the operating system how to bill the user's account (IS198T30500), what predefined amount of storage and other resources may be allocated (CLASS=L), and several other things. //SYSPRINT DD SYSOUT=* tells the computer to print the program's report on the default printer which is loaded with ordinary paper, not on some other printer which might be loaded with blank checks. DISP=SHR tells the operating system that other programs can read OLDFILE at the same time.
Later versions of the DOS/360 and OS/360 operating systems retain most features of the original JCL—although some simplification has been made, to avoid forcing customers to rewrite all their JCL files. Many users save as a procedure any set of JCL statements which is likely to be used more than once or twice.
The syntax of OS JCL is similar to the syntax of macros in System/360 assembly language, and would therefore have been familiar to programmers at a time when many programs were coded in assembly language.


== DOS JCL ==


=== Positional parameters ===

DOS JCL parameters are positional, which makes them harder to read and write, but easier for the system to parse.

The programmer must remember which item goes in which position in every type of statement.
If some optional parameters are omitted but later ones are included, the omitted parameters must be represented by commas with no spaces, as in the TLBL statement above.
DOS JCL to some extent mitigates the difficulties of positional parameters by using more statements with fewer parameters than OS JCL. In the example the ASSGN, DLBL and EXTENT statements do the same work (specifying where a new disk file should be stored) as a single DD statement in OS JCL.


=== Device dependence ===
In the original DOS/360 and in most versions of DOS/VS one had to specify the model number of the device which was to be used for each disk or tape file—even for existing files and for temporary files which would be deleted at the end of the job. This meant that, if a customer upgraded to more modern equipment, many JCL files had to be changed.
Later members of the DOS/360 family reduced the number of situations in which device model numbers were required.


=== Manual file allocation ===
DOS/360 originally required the programmer to specify the location and size of all files on DASD.  The EXTENT card specifies the volume on which the extent resides, the starting absolute track, and the number of tracks. For z/VSE a file can have up to 256 extents on different volumes.


== OS JCL ==
OS JCL consists of three basic statement types:

JOB statement, which identifies the start of the job, and information about the whole job, such as billing, run priority, and time and space limits.
EXEC statement, which identifies the program or procedure to be executed in this step of the job, and information about the step, including CONDitions for running or skipping a step.
DD (Data Definition) statements, which identify a data file to be used in a step, and detailed info about that file. DD statements can be in any order within the step.
Right from the start, JCL for the OS family (up to and including z/OS) was more flexible and easier to use.
The following examples use the old style of syntax which was provided right from the launch of System/360 in 1964. The old syntax is still quite common in jobs that have been running for decades with only minor changes.


=== Rules for coding JCL statements ===
Each JCL statement is divided into five fields:

 Identifier-Field Name-Field Operation-Field Parameter-Field Comments-Field
                 ^          ^               ^               ^
              no space    space           space           space

Identifier-Field should be concatenated with Name-Field, i.e. there should be no spaces between them.

Identifier-Field (//): The identifier field indicates to the system that a statement is a JCL statement rather than data. The identifier field consists of the following:
Columns 1 and 2 of all JCL statements, except the delimiter statement, contain //
Columns 1 and 2 of the delimiter statement contain /*
Columns 1, 2, and 3 of a JCL comment statement contain //*
Name-Field: The name field identifies a particular statement so that other statements and the system can refer to it. For JCL statements, it should be coded as follows:
The name must begin in column 3.
The name is 1 through 8 alphanumeric or national ($, #, @) characters.
The first character must be an alphabetic.
The name must be followed by at least one blank.
Operation-Field: The operation field specifies the type of statement, or, for the command statement, the command. Operation-Field should be coded as follows:
The operation field consists of the characters in the syntax box for the statement.
The operation follows the name field.
The operation must be preceded and followed by at least one blank.
The operation will be one of JOB, EXEC and DD.
Parameter-Field: The parameter field, also sometimes referred to as the operand field, contains parameters separated by commas. Parameter field should be coded as follows:
The parameter field follows the operation field.
The parameter field must be preceded by at least one blank.
The parameter field contains parameters which are keywords that used in the statement to provide information such as the program or dataset name.
Comments-Field: This contains comments. Comments-Field should be coded as Follows:
The comments field follows the parameter field.
The comments field must be preceded by at least one blank.


=== Keyword parameters ===

All of the major parameters of OS JCL statements are identified by keywords and can be presented in any order. A few of these contain two or more sub-parameters, such as SPACE (how much disk space to allocate to a new file) and DCB (detailed specification of a file's layout) in the example above. Sub-parameters are sometimes positional, as in SPACE, but the most complex parameters, such as DCB, have keyword sub-parameters.
Positional parameter must precede keyword parameters. Keyword parameters always assign values to a keyword using the equals sign (=).


=== Data access (DD statement) ===
The DD statement is used to reference data. This statement links a program's internal description of a dataset to the data on external devices: disks, tapes, cards, printers, etc.  The DD may provide information such as a device type (e.g. '181','2400-5','TAPE'), a volume serial number for tapes or disks, and the description of the data file, called the DCB subparameter after the Data Control Block (DCB)  in the program used to identify the file.
Information describing the file can come from three sources: The DD card information, the dataset label information for an existing file stored on tape or disk, and the DCB macro coded in the program.  When the file is opened this data is merged, with the DD information taking precedence over the label information, and the DCB information taking precedence over both.  The updated description is then written back to the dataset label. This can lead to unintended consequences if incorrect DCB information is provided.
Because of the parameters listed above and specific information for various access methods and devices the DD statement is the most complex JCL statement. In one IBM reference manual description of the DD statement occupies over 130 pages—more than twice as much as the JOB and EXEC statements combined.
The DD statement allows inline data to be injected into the job stream.  This is useful for providing control information to utilities such as IDCAMS, SORT, etc. as well as providing input data to programs.


=== Device independence ===
From the very beginning, the JCL for the OS family of operating systems offered a high degree of device independence. Even for new files which were to be kept after the end of the job one could specify the device type in generic terms, e.g., UNIT=DISK, UNIT=TAPE, or UNIT=SYSSQ (tape or disk). Of course, if it mattered one could specify a model number or even a specific device address.


=== Procedures ===
Procedures permit grouping one or more "EXEC PGM=" and DD statements and then invoking them with "EXEC PROC=procname" -or- simply "EXEC procname" 
A facility called a Procedure Library allowed pre-storing procedures.


==== PROC & PEND ====
Procedures can also be included in the job stream by terminating the procedure with a // PEND statement, then invoking it by name the same way as if it were in a procedure library.
For example:


=== Parameterized procedures ===
OS JCL procedures were parameterized from the start, making them rather like macros or even simple subroutines and thus increasing their reusability in a wide range of situations.

In this example, all the values beginning with ampersands "&" are parameters which will be specified when a job requests that the procedure be used. The PROC statement, in addition to giving the procedure a name, allows the programmer to specify default values for each parameter. So one could use the one procedure in this example to create new files of many different sizes and layouts. For example:


=== Referbacks ===
In multi-step jobs, a later step can use a referback instead of specifying in full a file which has already been specified in an earlier step. For example:

Here, MYPR02 uses the file identified as NEWFILE in step MYPR01 (DSN means "dataset name" and specifies the name of the file; a DSN could not exceed 44 characters).
In jobs which contain a mixture of job-specific JCL and procedure calls, a job-specific step can refer back to a file which was fully specified in a procedure, for example:

where DSN=*.STEP01.MYPR01.NEWFILE means "use the file identified as NEWFILE in step MYPR01 of the procedure used by step STEP01 of this job". Using the name of the step which called the procedure rather than the name of the procedure allows a programmer to use the same procedure several times in the same job without confusion about which instance of the procedure is used in the referback.


=== Comments ===
JCL files can be long and complex, and the language is not easy to read. OS JCL allows programmers to include two types of explanatory comment:

On the same line as a JCL statement. They can be extended by placing a continuation character (conventionally "X") in column 72, followed by "// " in columns 1–3 of the next line.
Lines which contain only comment, often used to explain major points about the overall structure of the JCL rather than local details. Comment-only lines are also used to divide long, complex JCL files into sections.


=== Concatenating input files ===
OS JCL allows programmers to concatenate ("chain") input files so that they appear to the program as one file, for example

The 2nd and third statements have no value in the name field, so OS treats them as concatenations. The files must be of the same basic type (almost always sequential), and must have the same record length, however the block length need not be the same.
In early versions of the OS (certainly before OS/360 R21.8) the block length must be in decreasing order, or the user must inspect each instance and append to the named DD statement the maximum block length found, as in, for example,

In later versions of the OS (certainly after OS/MVS R3.7 with the appropriate "selectable units") the OS itself, during allocation, would inspect each instance in a concatenation and would substitute the maximum block length which was found.
A usual fallback was to simply determine the maximum possible block length on the device, and specify that on the named DD statement, as in, for example,

The purpose of this fallback was to ensure that the access method would allocate an input buffer set which was large enough to accommodate any and all of the specified datasets.


=== Conditional processing ===
OS expects programs to set a return code which specifies how successful the program thought it was. The most common conventional values are:

0 = Normal - all OK
4 = Warning - minor errors or problems
8 = Error - significant errors or problems
12 = Severe error - major errors or problems, the results (e.g. files or reports produced) should not be trusted.
16 = Terminal error - very serious problems, do not use the results!
OS JCL refers to the return code as COND ("condition code"), and can use it to decide whether to run subsequent steps. However, unlike most modern programming languages, conditional steps in OS JCL are not executed if the specified condition is true—thus giving rise to the mnemonic, "If it's true, pass on through [without running the code]." To complicate matters further, the condition can only be specified after the step to which it refers. For example:

means:

Run STEP01, and collect its return code.
Don't run STEP02 if the number 4 is greater than STEP01's return code.
Don't run STEP03 if the number 8 is less than or equal to any previous return code.
Run STEP04 only if STEP01 abnormally ended.
Run STEP05, even if STEP03 abnormally ended.
This translates to the following pseudocode:

run STEP01
if STEP01's return code is greater than or equal to  4 then
    run STEP02
end if
if any previous return code is less than  8 then
    run STEP03
end if
if STEP01 abnormally ended then
    run STEP04
end if
if STEP03 abnormally ended then
    run STEP05
else
    run STEP05
end if

Note that by reading the steps containing COND statements backwards, one can understand them fairly easily. This is an example of logical transposition.
However, IBM later introduced IF condition in JCL thereby making coding somewhat easier for programmers while retaining the COND parameter (to avoid making changes to the existing JCLs where COND parm is used).
The COND parameter may also be specified on the JOB statement. If so the system "performs the same return code tests for every step in a job. If a JOB statement return code test is satisfied, the job terminates."


=== Utilities ===
Jobs use a number of IBM utility programs to assist in the processing of data. Utilities are most useful in batch processing. The utilities can be grouped into three sets:

Data Set Utilities - Create, print, copy, move and delete data sets.
System Utilities - Maintain and manage catalogs and other system information.
Access Method Services - Process Virtual Storage Access Method (VSAM) and non-VSAM data sets.


=== Difficulty of use ===
OS JCL is undeniably complex and has been described as "user hostile". As one instructional book on JCL asked, "Why do even sophisticated programmers hesitate when it comes to Job Control Language?"  The book stated that many programmers either copied control cards without really understanding what they did, or "believed the prevalent rumors that JCL was horrible, and only 'die-hard' computer-types ever understood it" and handed the task of figuring out the JCL statements to someone else.  Such an attitude could be found in programming language textbooks, which preferred to focus on the language itself and not how programs in it were run.  As one Fortran IV textbook said when listing possible error messages from the WATFOR compiler: "Have you been so foolish as to try to write your own 'DD' system control cards? Cease and desist forthwith; run, do not walk, for help."
Nevertheless, some books that went into JCL in detail emphasized that once it was learned to an at least somewhat proficient degree, one gained freedom from installation-wide defaults and much better control over how an IBM system processed your workload.  Another book commented on the complexity but said, "take heart. The JCL capability you will gain from [the preceding chapter] is all that most programmers will ever need."


== Job Entry Control Language ==
On IBM mainframe systems Job Entry Control Language or JECL is the set of command language control statements that provide information for the spooling subsystem – JES2 or JES3 on z/OS or VSE/POWER for z/VSE.  JECL statements may "specify on which network computer to run the job, when to run the job, and where to send the resulting output."
JECL is distinct from job control language (JCL), which instructs the operating system how to run the job.
There are different versions of JECL for the three environments.


=== OS/360 ===
An early version of Job Entry Control Language for OS/360 Remote Job Entry (Program Number 360S-RC-536) used the identifier  ..  in columns 1–2 of the input record and consisted of a single control statement: JED (Job Entry Definition).  "Workstation Commands" such as LOGON, LOGOFF, and STATUS also began with  .. .


==== pre-JES JECL ====
Although the term had not yet been developed, HASP did have similar functionality to what would become the JECL of JES, including /* syntax.


=== z/OS ===
For JES2 JECL statements start with /*, for JES3 they start with //*, except for remote  /*SIGNON  and  /*SIGNOFF  commands.  The commands for the two systems are completely different.


==== JES2 JECL ====
The following JES2 JECL statements are used in z/OS 1.2.0.


==== JES3 JECL ====
The following JES3 JECL statements are used in z/OS 1.2.0


=== z/VSE ===
For VSE JECL statements start with '* $$' (note the single space).  The Job Entry Control Language defines the start and end lines of JCL jobs. It advises VSE/POWER how this job is handled. JECL statements define the job name (used by VSE/POWER), the class in which the job is processed, and the disposition of the job (i.e. D, L, K, H).

Example:


== Other systems ==

Other mainframe batch systems had some form of job control language, whether called that or not; their syntax was completely different from IBM versions, but they usually provided similar capabilities.  Such a language would have control cards with a special indicator, such as an initial dollar sign with $JOB being the first such card, interspersed with cards containing program code, data to be run, and so on.
Interactive systems 
include "command languages"—command files (such as PCDOS ".bat" files) can be run non-interactively, but these usually do not provide as robust an environment for running unattended jobs as JCL.  On some computer systems the job control language and the interactive command language may be different.  For example, TSO on z/OS systems uses CLIST or Rexx as command languages along with JCL for batch work.  On other systems these may be the same.


== See also ==
dd (Unix), Unix program inspired by DD
IBM mainframe utility programs
Batch processing
Data set (IBM mainframe)#Generation Data Group


== References ==


== Sources ==
"z/OS V1R6.0 MVS JCL User's Guide" (PDF) (5th ed.). IBM. September 2004. Archived from the original (PDF) on 2013-08-19. Retrieved 2006-10-12.
"z/OS V1R7.0 MVS JCL Reference" (PDF) (11th ed.). IBM. April 2006. Archived from the original (PDF) on 2013-08-19. Retrieved 2006-10-12.
Johnston, Jerry (1 April 2005). "VSE: A Look at the Past 40 Years". z/Journal. Thomas Communications. Archived from the original on 4 March 2009.
"Computer Chronicles: 1972 - 1981". ThinkQuest. Oracle Corporation. 1998. Archived from the original on 21 June 2009.
DeWard Brown, Gary (7 June 2002). zOS JCL (5th ed.). Wiley. ISBN 978-0-471-23635-1.
"JCL Statement Fields". z/OS V1R11.0 MVS JCL Reference z/OS V1R10.0-V1R11.0. IBM. 2010.
IBM Corporation (March 2007). Introduction to the New Mainframe: z/VSE Basics (PDF). IBM, International Technical Support Organization. ISBN 978-0-73-848624-6. Retrieved 2017-12-06.
Ashley, Ruth; Fernandez, Judi N. (1978). Job Control Language: A Self-Teaching Guide. New York: John Wiley & Sons. ISBN 0-471-03205-0.
McQuillen, Kevin (1975). System/360–370 Assembler Language (OS). Fresno, California: Mike Murach & Associates. LCCN 74-29645.
Stern, Nancy; Stern, Robert A. (1980). Structured COBOL Programming (3rd ed.). New York: John Wiley & Sons. ISBN 0-471-04913-1.