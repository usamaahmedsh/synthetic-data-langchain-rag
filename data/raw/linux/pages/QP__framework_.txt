QP (Quantum Platform) is a family of open source real-time embedded frameworks (RTEFs) and runtime environments based on active objects (actors) and hierarchical state machines (UML statecharts). The QP family consists of the lightweight QP/C and QP/C++ frameworks, written in C (C99) and C++ (C++11), respectively.


== Active Objects (Actors) For Real-Time ==
The QP RTEFs are an implementation of the Active Object (Actor) model of computation, specifically tailored for real-time embedded (RTE) systems.
Active Objects (Actors) can be combined with a wide variety of threading models, including real-time kernels (RTOS kernels). In the latter case, the combination, designed for deterministic performance, is called the Real-Time Embedded Framework (RTEF). This framework uses higher level abstractions than Real-Time Operating System (RTOS) in graphical modelling and code generation to embedded systems, which create safer, and more responsive applications.


=== Comparison to RTOS ===
Compared to a (real-time) framework, when using an RTOS, the main part of each individual thread can be written in the application itself and the various RTOS services can be called from there (e.g. a time delay or a semaphore).
When you use a framework, you reuse the overall architecture (such as the event loop for all private threads of Active Objects) and you only write the code that the RTEF calls. This leads to inversion of control, which allows the RTEF to automatically enforce the best practices of concurrent programming. 


== Hierarchical State Machines ==
The behavior of active objects (actors) is specified in QP by means of hierarchical state machines (UML statecharts). The frameworks support manual coding of UML state machines in C or C++ as well as fully automatic code generation by means of the free graphical QM modeling tool.
The QP frameworks and the QM modeling tool are used in medical devices, defense & aerospace, robotics, consumer electronics, wired and wireless telecommunication, industrial automation, transportation, and many more.


== QP architecture and components ==
QP consists of a universal UML-compliant event processor (QEP), a portable, event-driven, real-time framework (QF), a selection of built-in real-time kernels (QV, QK, or QXK), and a software tracing system (QS).

QEP (QP Event Processor) is a universal UML-compliant event processor that enables direct coding of UML state machines (UML state charts) in highly maintainable C or C++, in which every state machine element is mapped to code precisely, unambiguously, and exactly once (traceability). QEP fully supports hierarchical state nesting, which enables reusing behavior across many states instead of repeating the same actions and transitions over and over again.
QF (QP Active Object Framework) is a highly portable, event-driven, real-time application framework for concurrent execution of Active Objects specifically designed for real-time embedded systems.
QV (Cooperative Kernel) is a tiny cooperative kernel designed for executing active objects in a run-to-completion (RTC) fashion.
QK (Preemptive Kernel) is a tiny preemptive non-blocking run-to-completion kernel designed specifically for executing state machines in a run-to-completion (RTC) fashion.
QXK (Dual-Mode Kernel) is a tiny preemptive blocking kernel designed for hybrid applications consisting of active objects and traditional blocking threads.
QS (QP/Spy) is a software tracing system that enables live monitoring of event-driven QP applications with minimal target system resources and without stopping or significantly slowing down the code.


== Standalone (Bare-Metal) Operation ==
The QP RTEFs can run standalone, completely replacing the traditional RTOS. The frameworks contain a selection of built-in real-time kernels, such as the cooperative QV kernel, the preemptive non-blocking QK kernel, and the unique preemptive, dual-mode (blocking/non-blocking) QXK kernel. Standalone QP ports and ready-to-use examples are provided for ARM Cortex-Mas, as well as other CPUs.


== Traditional RTOS Integration ==
The QP RTEFs can also work with many traditional third-party RTOSes. QP ports and ready-to-use examples are provided for several RTOSes (such as Segger Microcontroller Systems#embOS, ThreadX, FreeRTOS, uC/OS-II, etc.)
The most important reason why you might consider using a traditional RTOS kernel for executing event-driven QP applications is compatibility with the existing software. For example, many communication stacks (TCP/IP, USB, CAN, etc.) are designed for a traditional blocking kernel. In addition, a lot of legacy code requires blocking mechanisms, such as semaphores or time-delays. A traditional RTOS allows you to run the existing software components as regular “blocking” threads in parallel to the event-driven QP™ active objects.


== General Purpose OS Integration ==
The QP RTEFs can also work with general purpose OSes, such as Linux (POSIX), Windows, and macOS.
The QP ports to the general purpose operating systems are interested in their own right. For example, the QP port to POSIX supports real-time extensions and works with embedded Linux, and POSIX subsystems of such RTOSes as: QNX, INTEGRITY, VxWorks, etc. Similarly, QP port to Windows can work with Windows IoT or Windows Embedded Compact.
But the OS support can be also interesting for developing of deeply embedded code on the desktop workstations, which is called "dual-targeting".


== Licensing ==
QP framework are dual-licensed under the open source GPLv3 and a selection of traditional, closed-source licenses. Users who wish to distribute QP (e.g. embedded inside devices) can retain the proprietary status of their code by applying for a commercial license.


== See also ==
Embedded operating system
Real-time operating system


== References ==


== External links ==
state-machine.com
QP frameworks on GitHub
QP frameworks on SourceForge
qf4net: Quantum Framework for .Net
qfj: Quantum Framework for Java on SourceForge.net
Miros: a hierarchical state machine module in Python
Miros: a hierarchical state machine module in Lua
State-Oriented Programming (Groovy)
ACCU Overload Journal #64 "Yet Another Hierarchical State Machine"
C/C++ Users Journal "Who Moved My State?"
C/C++ Users Journal "Deja Vu"
Research on Open CNC System Based on Quantum Framework
Active Objects by Schmidt