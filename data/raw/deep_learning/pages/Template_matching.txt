Template matching is a technique in digital image processing for finding small parts of an image which match a template image. It can be used for quality control in manufacturing, navigation of mobile robots, or edge detection in images.
The main challenges in a template matching task are detection of occlusion, when a sought-after object is partly hidden in an image; detection of non-rigid transformations, when an object is distorted or imaged from different angles; sensitivity to illumination and background changes; background clutter; and scale changes.


== Feature-based approach ==

The feature-based approach to template matching relies on the extraction of image features, such as shapes, textures, and colors, that match the target image or frame. This approach is usually achieved using neural networks and deep-learning classifiers such as VGG, AlexNet, and ResNet.Convolutional neural networks (CNNs), which many modern classifiers are based on, process an image by passing it through different hidden layers, producing a vector at each layer with classification information about the image. These vectors are extracted from the network and used as the features of the image. Feature extraction using deep neural networks, like CNNs, has proven extremely effective has become the standard in state-of-the-art template matching algorithms.
This feature-based approach is often more robust than the template-based approach described below. As such, it has become the state-of-the-art method for template matching, as it can match templates with non-rigid and out-of-plane transformations, as well as high background clutter and illumination changes.


== Template-based approach ==

For templates without strong features, or for when the bulk of a template image constitutes the matching image as a whole, a template-based approach may be effective. Since template-based matching may require sampling of a large number of data points, it is often desirable to reduce the number of sampling points by reducing the resolution of search and template images by the same factor before performing the operation on the resultant downsized images. This pre-processing method creates a multi-scale, or pyramid, representation of images, providing a reduced search window of data points within a search image so that the template does not have to be compared with every viable data point. Pyramid representations are a method of dimensionality reduction, a common aim of machine learning on data sets that suffer the curse of dimensionality.


== Common challenges ==
In instances where the template may not provide a direct match, it may be useful to implement eigenspaces to create templates that detail the matching object under a number of different conditions, such as varying perspectives, illuminations, color contrasts, or object poses.  For example, if an algorithm is looking for a face, its template eigenspaces may consist of images (i.e., templates) of faces in different positions to the camera, in different lighting conditions, or with different expressions (i.e., poses).
It is also possible for a matching image to be obscured or occluded by an object. In these cases, it is unreasonable to provide a multitude of templates to cover each possible occlusion. For example, the search object may be a playing card, and in some of the search images, the card is obscured by the fingers of someone holding the card, or by another card on top of it, or by some other object in front of the camera. In cases where the object is malleable or poseable, motion becomes an additional problem, and problems involving both motion and occlusion become ambiguous. In these cases, one possible solution is to divide the template image into multiple sub-images and perform matching on each subdivision.


== Deformable templates in computational anatomy ==

Template matching is a central tool in computational anatomy (CA). In this field, a deformable template model is used to model the space of human anatomies and their orbits under the group of diffeomorphisms, functions which smoothly deform an object. Template matching arises as an approach to finding the unknown diffeomorphism that acts on a template image to match the target image.
Template matching algorithms in CA have come to be called large deformation diffeomorphic metric mappings (LDDMMs). Currently, there are LDDMM template matching algorithms for matching anatomical landmark points, curves, surfaces, volumes.


== Template-based matching explained using cross correlation or sum of absolute differences ==
A basic method of template matching sometimes called "Linear Spatial Filtering" uses an image patch (i.e., the "template image" or "filter mask") tailored to a specific feature of search images to detect. This technique can be easily performed on grey images or edge images, where the additional variable of color is either not present or not relevant. Cross correlation techniques compare the similarities of the search and template images. Their outputs should be highest at places where the image structure matches the template structure, i.e., where large search image values get multiplied by large template image values.
This method is normally implemented by first picking out a part of a search image to use as a template. Let 
  
    
      
        S
        (
        x
        ,
        y
        )
      
    
    {\displaystyle S(x,y)}
  
 represent the value of a search image pixel, where 
  
    
      
        (
        x
        ,
        y
        )
      
    
    {\displaystyle (x,y)}
  
 represents the coordinates of the pixel in the search image. For simplicity, assume pixel values are scalar, as in a greyscale image. Similarly, let 
  
    
      
        T
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
      
    
    {\textstyle T(x_{t},y_{t})}
  
 represent the value of a template pixel, where 
  
    
      
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
      
    
    {\textstyle (x_{t},y_{t})}
  
 represents the coordinates of the pixel in the template image. To apply the filter, simply move the center (or origin) of the template image over each point in the search image and calculate the sum of products, similar to a dot product, between the pixel values in the search and template images over the whole area spanned by the template. More formally, if 
  
    
      
        (
        0
        ,
        0
        )
      
    
    {\displaystyle (0,0)}
  
 is the center (or origin) of the template image, then the cross correlation 
  
    
      
        T
        ⋆
        S
      
    
    {\displaystyle T\star S}
  
 at each point 
  
    
      
        (
        x
        ,
        y
        )
      
    
    {\displaystyle (x,y)}
  
 in the search image can be computed as:
  
    
      
        (
        T
        ⋆
        S
        )
        (
        x
        ,
        y
        )
        =
        
          ∑
          
            (
            
              x
              
                t
              
            
            ,
            
              y
              
                t
              
            
            )
            ∈
            T
          
        
        T
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
        ⋅
        S
        (
        
          x
          
            t
          
        
        +
        x
        ,
        
          y
          
            t
          
        
        +
        y
        )
      
    
    {\displaystyle (T\star S)(x,y)=\sum _{(x_{t},y_{t})\in T}T(x_{t},y_{t})\cdot S(x_{t}+x,y_{t}+y)}
  
For convenience, 
  
    
      
        T
      
    
    {\displaystyle T}
  
 denotes both the pixel values of the template image as well as its domain, the bounds of the template. Note that all possible positions of the template with respect to the search image are considered. Since cross correlation values are greatest when the values of the search and template pixels align, the best matching position 
  
    
      
        (
        
          x
          
            m
          
        
        ,
        
          y
          
            m
          
        
        )
      
    
    {\displaystyle (x_{m},y_{m})}
  
 corresponds to the maximum value of 
  
    
      
        T
        ⋆
        S
      
    
    {\displaystyle T\star S}
  
 over 
  
    
      
        S
      
    
    {\displaystyle S}
  
.
Another way to handle translation problems on images using template matching is to compare the intensities of the pixels, using the sum of absolute differences (SAD) measure. To formulate this, let 
  
    
      
        
          I
          
            S
          
        
        (
        
          x
          
            s
          
        
        ,
        
          y
          
            s
          
        
        )
      
    
    {\displaystyle I_{S}(x_{s},y_{s})}
  
 and 
  
    
      
        
          I
          
            T
          
        
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
      
    
    {\displaystyle I_{T}(x_{t},y_{t})}
  
 denote the light intensity of pixels in the search and template images with coordinates 
  
    
      
        (
        
          x
          
            s
          
        
        ,
        
          y
          
            s
          
        
        )
      
    
    {\displaystyle (x_{s},y_{s})}
  
 and 
  
    
      
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
      
    
    {\displaystyle (x_{t},y_{t})}
  
, respectively. Then by moving the center (or origin) of the template to a point 
  
    
      
        (
        x
        ,
        y
        )
      
    
    {\displaystyle (x,y)}
  
 in the search image, as before, the sum of absolute differences between the template and search pixel intensities at that point is:
  
    
      
        S
        A
        D
        (
        x
        ,
        y
        )
        =
        
          ∑
          
            (
            
              x
              
                t
              
            
            ,
            
              y
              
                t
              
            
            )
            ∈
            T
          
        
        
          |
          
            
              I
              
                T
              
            
            (
            
              x
              
                t
              
            
            ,
            
              y
              
                t
              
            
            )
            −
            
              I
              
                S
              
            
            (
            
              x
              
                t
              
            
            +
            x
            ,
            
              y
              
                t
              
            
            +
            y
            )
          
          |
        
      
    
    {\displaystyle SAD(x,y)=\sum _{(x_{t},y_{t})\in T}\left\vert I_{T}(x_{t},y_{t})-I_{S}(x_{t}+x,y_{t}+y)\right\vert }
  
With this measure, the lowest SAD gives the best position for the template, rather than the greatest as with cross correlation. SAD tends to be relatively simple to implement and understand, but it also tends to be relatively slow to execute. A simple C++ implementation of SAD template matching is given below.


== Implementation ==
In this simple implementation, it is assumed that the above described method is applied on grey images: This is why Grey is used as pixel intensity.  The final position in this implementation gives the top left location for where the template image best matches the search image.

One way to perform template matching on color images is to decompose the pixels into their color components and measure the quality of match between the color template and search image using the sum of the SAD computed for each color separately.


== Speeding up the process ==
In the past, this type of spatial filtering was normally only used in dedicated hardware solutions because of the computational complexity of the operation, however we can lessen this complexity by filtering it in the frequency domain of the image, referred to as 'frequency domain filtering,' this is done through the use of the convolution theorem.
Another way of speeding up the matching process is through the use of an image pyramid. This is a series of images, at different scales, which are formed by repeatedly filtering and subsampling the original image in order to generate a sequence of reduced resolution images. These lower resolution images can then be searched for the template (with a similarly reduced resolution), in order to yield possible start positions for searching at the larger scales. The larger images can then be searched in a small window around the start position to find the best template location.
Other methods can handle problems such as translation, scale, image rotation and even all affine transformations.


== Improving the accuracy of the matching ==
Improvements can be made to the matching method by using more than one template (eigenspaces), these other templates can have different scales and rotations.
It is also possible to improve the accuracy of the matching method by hybridizing the feature-based and template-based approaches.  Naturally, this requires that the search and template images have features that are apparent enough to support feature matching.


== Similar methods ==
Other methods which are similar include 'Stereo matching', 'Image registration' and 'Scale-invariant feature transform'.


== Examples of use ==
Template matching has various applications and is used in such fields as face recognition (see facial recognition system) and medical image processing. Systems have been developed and used in the past to count the number of faces that walk across part of a bridge within a certain amount of time. Other systems include automated calcified nodule detection within digital chest X-rays.
Recently, this method was implemented in geostatistical simulation which could provide a fast algorithm.


== See also ==
Facial recognition system
Pattern recognition
Computer vision
Elastic Matching


== References ==


== External links ==
Template Matching in OpenCV
Visual Object Recognition using Template Matching
Rotation, scale, translation-invariant template matching demonstration program
perspective-invariant template matching
An extensive template matching bibliography up to 2009