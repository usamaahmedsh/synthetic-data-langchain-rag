In machine learning, diffusion models, also known as diffusion-based generative models or score-based generative models, are a class of latent variable generative models. A diffusion model consists of two major components: the forward diffusion process, and the reverse sampling process. The goal of diffusion models is to learn a diffusion process for a given dataset, such that the process can generate new elements that are distributed similarly as the original dataset. A diffusion model models data as generated by a diffusion process, whereby a new datum performs a random walk with drift through the space of all possible data. A trained diffusion model can be sampled in many ways, with different efficiency and quality.
There are various equivalent formalisms, including Markov chains, denoising diffusion probabilistic models, noise conditioned score networks, and stochastic differential equations. They are typically trained using variational inference. The model responsible for denoising is typically called its "backbone". The backbone may be of any kind, but they are typically U-nets or transformers.
As of 2024, diffusion models are mainly used for computer vision tasks, including image denoising, inpainting, super-resolution, image generation, and video generation. These typically involve training a neural network to sequentially denoise images blurred with Gaussian noise. The model is trained to reverse the process of adding noise to an image. After training to convergence, it can be used for image generation by starting with an image composed of random noise, and applying the network iteratively to denoise the image.
Diffusion-based image generators have seen widespread commercial interest, such as Stable Diffusion and DALL-E. These models typically combine diffusion models with other models, such as text-encoders and cross-attention modules to allow text-conditioned generation.
Other than computer vision, diffusion models have also found applications in natural language processing such as text generation and summarization, sound generation, and reinforcement learning.


== Denoising diffusion model ==


=== Non-equilibrium thermodynamics ===
Diffusion models were introduced in 2015 as a method to train a model that can sample from a highly complex probability distribution. They used techniques from non-equilibrium thermodynamics, especially diffusion.
Consider, for example, how one might model the distribution of all naturally occurring photos. Each image is a point in the space of all images, and the distribution of naturally occurring photos is a "cloud" in space, which, by repeatedly adding noise to the images, diffuses out to the rest of the image space, until the cloud becomes all but indistinguishable from a Gaussian distribution 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
. A model that can approximately undo the diffusion can then be used to sample from the original distribution. This is studied in "non-equilibrium" thermodynamics, as the starting distribution is not in equilibrium, unlike the final distribution.
The equilibrium distribution is the Gaussian distribution 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
, with pdf 
  
    
      
        ρ
        (
        x
        )
        ∝
        
          e
          
            −
            
              
                1
                2
              
            
            ‖
            x
            
              ‖
              
                2
              
            
          
        
      
    
    {\displaystyle \rho (x)\propto e^{-{\frac {1}{2}}\|x\|^{2}}}
  
. This is just the Maxwell–Boltzmann distribution of particles in a potential well 
  
    
      
        V
        (
        x
        )
        =
        
          
            1
            2
          
        
        ‖
        x
        
          ‖
          
            2
          
        
      
    
    {\displaystyle V(x)={\frac {1}{2}}\|x\|^{2}}
  
 at temperature 1. The initial distribution, being very much out of equilibrium, would diffuse towards the equilibrium distribution, making biased random steps that are a sum of pure randomness (like a Brownian walker) and gradient descent down the potential well. The randomness is necessary: if the particles were to undergo only gradient descent, then they will all fall to the origin, collapsing the distribution.


=== Denoising Diffusion Probabilistic Model (DDPM) ===
The 2020 paper proposed the Denoising Diffusion Probabilistic Model (DDPM), which improves upon the previous method by variational inference.


==== Forward diffusion ====
To present the model, some notation is required.

  
    
      
        
          β
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          β
          
            T
          
        
        ∈
        (
        0
        ,
        1
        )
      
    
    {\displaystyle \beta _{1},...,\beta _{T}\in (0,1)}
  
 are fixed constants.

  
    
      
        
          α
          
            t
          
        
        :=
        1
        −
        
          β
          
            t
          
        
      
    
    {\displaystyle \alpha _{t}:=1-\beta _{t}}
  

  
    
      
        
          
            
              
                α
                ¯
              
            
          
          
            t
          
        
        :=
        
          α
          
            1
          
        
        ⋯
        
          α
          
            t
          
        
      
    
    {\displaystyle {\bar {\alpha }}_{t}:=\alpha _{1}\cdots \alpha _{t}}
  

  
    
      
        
          σ
          
            t
          
        
        :=
        
          
            1
            −
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
      
    
    {\displaystyle \sigma _{t}:={\sqrt {1-{\bar {\alpha }}_{t}}}}
  

  
    
      
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
        
        :=
        
          
            
              σ
              
                t
                −
                1
              
            
            
              σ
              
                t
              
            
          
        
        
          
            
              β
              
                t
              
            
          
        
      
    
    {\displaystyle {\tilde {\sigma }}_{t}:={\frac {\sigma _{t-1}}{\sigma _{t}}}{\sqrt {\beta _{t}}}}
  

  
    
      
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        )
        :=
        
          
            
              
                
                  
                    α
                    
                      t
                    
                  
                
              
              (
              1
              −
              
                
                  
                    
                      α
                      ¯
                    
                  
                
                
                  t
                  −
                  1
                
              
              )
              
                x
                
                  t
                
              
              +
              
                
                  
                    
                      
                        
                          α
                          ¯
                        
                      
                    
                    
                      t
                      −
                      1
                    
                  
                
              
              (
              1
              −
              
                α
                
                  t
                
              
              )
              
                x
                
                  0
                
              
            
            
              σ
              
                t
              
              
                2
              
            
          
        
      
    
    {\displaystyle {\tilde {\mu }}_{t}(x_{t},x_{0}):={\frac {{\sqrt {\alpha _{t}}}(1-{\bar {\alpha }}_{t-1})x_{t}+{\sqrt {{\bar {\alpha }}_{t-1}}}(1-\alpha _{t})x_{0}}{\sigma _{t}^{2}}}}
  

  
    
      
        
          
            N
          
        
        (
        μ
        ,
        Σ
        )
      
    
    {\displaystyle {\mathcal {N}}(\mu ,\Sigma )}
  
 is the normal distribution with mean 
  
    
      
        μ
      
    
    {\displaystyle \mu }
  
 and variance 
  
    
      
        Σ
      
    
    {\displaystyle \Sigma }
  
, and 
  
    
      
        
          
            N
          
        
        (
        x
        
          |
        
        μ
        ,
        Σ
        )
      
    
    {\displaystyle {\mathcal {N}}(x|\mu ,\Sigma )}
  
 is the probability density at 
  
    
      
        x
      
    
    {\displaystyle x}
  
.
A vertical bar denotes conditioning.
A forward diffusion process starts at some starting point 
  
    
      
        
          x
          
            0
          
        
        ∼
        q
      
    
    {\displaystyle x_{0}\sim q}
  
, where 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is the probability distribution to be learned, then repeatedly adds noise to it by
  
    
      
        
          x
          
            t
          
        
        =
        
          
            1
            −
            
              β
              
                t
              
            
          
        
        
          x
          
            t
            −
            1
          
        
        +
        
          
            
              β
              
                t
              
            
          
        
        
          z
          
            t
          
        
      
    
    {\displaystyle x_{t}={\sqrt {1-\beta _{t}}}x_{t-1}+{\sqrt {\beta _{t}}}z_{t}}
  
where 
  
    
      
        
          z
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          z
          
            T
          
        
      
    
    {\displaystyle z_{1},...,z_{T}}
  
 are IID samples from 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
. The coefficients 
  
    
      
        
          
            1
            −
            
              β
              
                t
              
            
          
        
      
    
    {\displaystyle {\sqrt {1-\beta _{t}}}}
  
 and 
  
    
      
        
          
            
              β
              
                t
              
            
          
        
      
    
    {\displaystyle {\sqrt {\beta _{t}}}}
  
 ensure that 
  
    
      
        
          
            Var
          
        
        (
        
          X
          
            t
          
        
        )
        =
        I
      
    
    {\displaystyle {\mbox{Var}}(X_{t})=I}
  
 assuming that 
  
    
      
        
          
            Var
          
        
        (
        
          X
          
            0
          
        
        )
        =
        I
      
    
    {\displaystyle {\mbox{Var}}(X_{0})=I}
  
. The values of 
  
    
      
        
          β
          
            t
          
        
      
    
    {\displaystyle \beta _{t}}
  
 are chosen such that for any starting distribution of 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
, if it has finite second moment, then 
  
    
      
        
          lim
          
            t
            →
            ∞
          
        
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
      
    
    {\displaystyle \lim _{t\to \infty }x_{t}|x_{0}}
  
 converges to 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
.
The entire diffusion process then satisfies
  
    
      
        q
        (
        
          x
          
            0
            :
            T
          
        
        )
        =
        q
        (
        
          x
          
            0
          
        
        )
        q
        (
        
          x
          
            1
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ⋯
        q
        (
        
          x
          
            T
          
        
        
          |
        
        
          x
          
            T
            −
            1
          
        
        )
        =
        q
        (
        
          x
          
            0
          
        
        )
        
          
            N
          
        
        (
        
          x
          
            1
          
        
        
          |
        
        
          
            
              α
              
                1
              
            
          
        
        
          x
          
            0
          
        
        ,
        
          β
          
            1
          
        
        I
        )
        ⋯
        
          
            N
          
        
        (
        
          x
          
            T
          
        
        
          |
        
        
          
            
              α
              
                T
              
            
          
        
        
          x
          
            T
            −
            1
          
        
        ,
        
          β
          
            T
          
        
        I
        )
      
    
    {\displaystyle q(x_{0:T})=q(x_{0})q(x_{1}|x_{0})\cdots q(x_{T}|x_{T-1})=q(x_{0}){\mathcal {N}}(x_{1}|{\sqrt {\alpha _{1}}}x_{0},\beta _{1}I)\cdots {\mathcal {N}}(x_{T}|{\sqrt {\alpha _{T}}}x_{T-1},\beta _{T}I)}
  
or
  
    
      
        ln
        ⁡
        q
        (
        
          x
          
            0
            :
            T
          
        
        )
        =
        ln
        ⁡
        q
        (
        
          x
          
            0
          
        
        )
        −
        
          ∑
          
            t
            =
            1
          
          
            T
          
        
        
          
            1
            
              2
              
                β
                
                  t
                
              
            
          
        
        ‖
        
          x
          
            t
          
        
        −
        
          
            1
            −
            
              β
              
                t
              
            
          
        
        
          x
          
            t
            −
            1
          
        
        
          ‖
          
            2
          
        
        +
        C
      
    
    {\displaystyle \ln q(x_{0:T})=\ln q(x_{0})-\sum _{t=1}^{T}{\frac {1}{2\beta _{t}}}\|x_{t}-{\sqrt {1-\beta _{t}}}x_{t-1}\|^{2}+C}
  
where 
  
    
      
        C
      
    
    {\displaystyle C}
  
 is a normalization constant and often omitted. In particular, we note that 
  
    
      
        
          x
          
            1
            :
            T
          
        
        
          |
        
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{1:T}|x_{0}}
  
 is a Gaussian process, which affords us considerable freedom in reparameterization. For example, by standard manipulation with Gaussian process, 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              x
              
                0
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}x_{0},\sigma _{t}^{2}I\right)}
  

  
    
      
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        ∼
        
          
            N
          
        
        (
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        )
        ,
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            2
          
        
        I
        )
      
    
    {\displaystyle x_{t-1}|x_{t},x_{0}\sim {\mathcal {N}}({\tilde {\mu }}_{t}(x_{t},x_{0}),{\tilde {\sigma }}_{t}^{2}I)}
  
In particular, notice that for large 
  
    
      
        t
      
    
    {\displaystyle t}
  
, the variable 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              x
              
                0
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}x_{0},\sigma _{t}^{2}I\right)}
  
 converges to 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
. That is, after a long enough diffusion process, we end up with some 
  
    
      
        
          x
          
            T
          
        
      
    
    {\displaystyle x_{T}}
  
 that is very close to 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
, with all traces of the original 
  
    
      
        
          x
          
            0
          
        
        ∼
        q
      
    
    {\displaystyle x_{0}\sim q}
  
 gone.
For example, since
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              x
              
                0
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}x_{0},\sigma _{t}^{2}I\right)}
  
we can sample 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{t}|x_{0}}
  
 directly "in one step", instead of going through all the intermediate steps 
  
    
      
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            t
            −
            1
          
        
      
    
    {\displaystyle x_{1},x_{2},...,x_{t-1}}
  
.


==== Backward diffusion ====
The key idea of DDPM is to use a neural network parametrized by 
  
    
      
        θ
      
    
    {\displaystyle \theta }
  
. The network takes in two arguments 
  
    
      
        
          x
          
            t
          
        
        ,
        t
      
    
    {\displaystyle x_{t},t}
  
, and outputs a vector 
  
    
      
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \mu _{\theta }(x_{t},t)}
  
 and a matrix 
  
    
      
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \Sigma _{\theta }(x_{t},t)}
  
, such that each step in the forward diffusion process can be approximately undone by 
  
    
      
        
          x
          
            t
            −
            1
          
        
        ∼
        
          
            N
          
        
        (
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        ,
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        )
      
    
    {\displaystyle x_{t-1}\sim {\mathcal {N}}(\mu _{\theta }(x_{t},t),\Sigma _{\theta }(x_{t},t))}
  
. This then gives us a backward diffusion process 
  
    
      
        
          p
          
            θ
          
        
      
    
    {\displaystyle p_{\theta }}
  
 defined by
  
    
      
        
          p
          
            θ
          
        
        (
        
          x
          
            T
          
        
        )
        =
        
          
            N
          
        
        (
        
          x
          
            T
          
        
        
          |
        
        0
        ,
        I
        )
      
    
    {\displaystyle p_{\theta }(x_{T})={\mathcal {N}}(x_{T}|0,I)}
  

  
    
      
        
          p
          
            θ
          
        
        (
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          x
          
            t
          
        
        )
        =
        
          
            N
          
        
        (
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        ,
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        )
      
    
    {\displaystyle p_{\theta }(x_{t-1}|x_{t})={\mathcal {N}}(x_{t-1}|\mu _{\theta }(x_{t},t),\Sigma _{\theta }(x_{t},t))}
  
The goal now is to learn the parameters such that 
  
    
      
        
          p
          
            θ
          
        
        (
        
          x
          
            0
          
        
        )
      
    
    {\displaystyle p_{\theta }(x_{0})}
  
 is as close to 
  
    
      
        q
        (
        
          x
          
            0
          
        
        )
      
    
    {\displaystyle q(x_{0})}
  
 as possible. To do that, we use maximum likelihood estimation with variational inference.


==== Variational inference ====
The ELBO inequality states that 
  
    
      
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            0
          
        
        )
        ≥
        
          E
          
            
              x
              
                1
                :
                T
              
            
            ∼
            q
            (
            ⋅
            
              |
            
            
              x
              
                0
              
            
            )
          
        
        [
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            0
            :
            T
          
        
        )
        −
        ln
        ⁡
        q
        (
        
          x
          
            1
            :
            T
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ]
      
    
    {\displaystyle \ln p_{\theta }(x_{0})\geq E_{x_{1:T}\sim q(\cdot |x_{0})}[\ln p_{\theta }(x_{0:T})-\ln q(x_{1:T}|x_{0})]}
  
, and taking one more expectation, we get
  
    
      
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
          
        
        [
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            0
          
        
        )
        ]
        ≥
        
          E
          
            
              x
              
                0
                :
                T
              
            
            ∼
            q
          
        
        [
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            0
            :
            T
          
        
        )
        −
        ln
        ⁡
        q
        (
        
          x
          
            1
            :
            T
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ]
      
    
    {\displaystyle E_{x_{0}\sim q}[\ln p_{\theta }(x_{0})]\geq E_{x_{0:T}\sim q}[\ln p_{\theta }(x_{0:T})-\ln q(x_{1:T}|x_{0})]}
  
We see that maximizing the quantity on the right would give us a lower bound on the likelihood of observed data. This allows us to perform variational inference.
Define the loss function
  
    
      
        L
        (
        θ
        )
        :=
        −
        
          E
          
            
              x
              
                0
                :
                T
              
            
            ∼
            q
          
        
        [
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            0
            :
            T
          
        
        )
        −
        ln
        ⁡
        q
        (
        
          x
          
            1
            :
            T
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ]
      
    
    {\displaystyle L(\theta ):=-E_{x_{0:T}\sim q}[\ln p_{\theta }(x_{0:T})-\ln q(x_{1:T}|x_{0})]}
  
and now the goal is to minimize the loss by stochastic gradient descent. The expression may be simplified to
  
    
      
        L
        (
        θ
        )
        =
        
          ∑
          
            t
            =
            1
          
          
            T
          
        
        
          E
          
            
              x
              
                t
                −
                1
              
            
            ,
            
              x
              
                t
              
            
            ∼
            q
          
        
        [
        −
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          x
          
            t
          
        
        )
        ]
        +
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
          
        
        [
        
          D
          
            K
            L
          
        
        (
        q
        (
        
          x
          
            T
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ‖
        
          p
          
            θ
          
        
        (
        
          x
          
            T
          
        
        )
        )
        ]
        +
        C
      
    
    {\displaystyle L(\theta )=\sum _{t=1}^{T}E_{x_{t-1},x_{t}\sim q}[-\ln p_{\theta }(x_{t-1}|x_{t})]+E_{x_{0}\sim q}[D_{KL}(q(x_{T}|x_{0})\|p_{\theta }(x_{T}))]+C}
  
where 
  
    
      
        C
      
    
    {\displaystyle C}
  
 does not depend on the parameter, and thus can be ignored. Since 
  
    
      
        
          p
          
            θ
          
        
        (
        
          x
          
            T
          
        
        )
        =
        
          
            N
          
        
        (
        
          x
          
            T
          
        
        
          |
        
        0
        ,
        I
        )
      
    
    {\displaystyle p_{\theta }(x_{T})={\mathcal {N}}(x_{T}|0,I)}
  
 also does not depend on the parameter, the term 
  
    
      
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
          
        
        [
        
          D
          
            K
            L
          
        
        (
        q
        (
        
          x
          
            T
          
        
        
          |
        
        
          x
          
            0
          
        
        )
        ‖
        
          p
          
            θ
          
        
        (
        
          x
          
            T
          
        
        )
        )
        ]
      
    
    {\displaystyle E_{x_{0}\sim q}[D_{KL}(q(x_{T}|x_{0})\|p_{\theta }(x_{T}))]}
  
 can also be ignored. This leaves just 
  
    
      
        L
        (
        θ
        )
        =
        
          ∑
          
            t
            =
            1
          
          
            T
          
        
        
          L
          
            t
          
        
      
    
    {\displaystyle L(\theta )=\sum _{t=1}^{T}L_{t}}
  
 with 
  
    
      
        
          L
          
            t
          
        
        =
        
          E
          
            
              x
              
                t
                −
                1
              
            
            ,
            
              x
              
                t
              
            
            ∼
            q
          
        
        [
        −
        ln
        ⁡
        
          p
          
            θ
          
        
        (
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          x
          
            t
          
        
        )
        ]
      
    
    {\displaystyle L_{t}=E_{x_{t-1},x_{t}\sim q}[-\ln p_{\theta }(x_{t-1}|x_{t})]}
  
 to be minimized.


==== Noise prediction network ====
Since 
  
    
      
        
          x
          
            t
            −
            1
          
        
        
          |
        
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        ∼
        
          
            N
          
        
        (
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        )
        ,
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            2
          
        
        I
        )
      
    
    {\displaystyle x_{t-1}|x_{t},x_{0}\sim {\mathcal {N}}({\tilde {\mu }}_{t}(x_{t},x_{0}),{\tilde {\sigma }}_{t}^{2}I)}
  
, this suggests that we should use 
  
    
      
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        =
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          x
          
            0
          
        
        )
      
    
    {\displaystyle \mu _{\theta }(x_{t},t)={\tilde {\mu }}_{t}(x_{t},x_{0})}
  
; however, the network does not have access to 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
, and so it has to estimate it instead. Now, since 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              x
              
                0
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}x_{0},\sigma _{t}^{2}I\right)}
  
, we may write 
  
    
      
        
          x
          
            t
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          x
          
            0
          
        
        +
        
          σ
          
            t
          
        
        z
      
    
    {\displaystyle x_{t}={\sqrt {{\bar {\alpha }}_{t}}}x_{0}+\sigma _{t}z}
  
, where 
  
    
      
        z
      
    
    {\displaystyle z}
  
 is some unknown Gaussian noise. Now we see that estimating 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 is equivalent to estimating 
  
    
      
        z
      
    
    {\displaystyle z}
  
.
Therefore, let the network output a noise vector 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},t)}
  
, and let it predict
  
    
      
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        =
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        
          (
          
            
              x
              
                t
              
            
            ,
            
              
                
                  
                    x
                    
                      t
                    
                  
                  −
                  
                    σ
                    
                      t
                    
                  
                  
                    ϵ
                    
                      θ
                    
                  
                  (
                  
                    x
                    
                      t
                    
                  
                  ,
                  t
                  )
                
                
                  
                    
                      
                        
                          α
                          ¯
                        
                      
                    
                    
                      t
                    
                  
                
              
            
          
          )
        
        =
        
          
            
              
                x
                
                  t
                
              
              −
              
                ϵ
                
                  θ
                
              
              (
              
                x
                
                  t
                
              
              ,
              t
              )
              
                β
                
                  t
                
              
              
                /
              
              
                σ
                
                  t
                
              
            
            
              
                α
                
                  t
                
              
            
          
        
      
    
    {\displaystyle \mu _{\theta }(x_{t},t)={\tilde {\mu }}_{t}\left(x_{t},{\frac {x_{t}-\sigma _{t}\epsilon _{\theta }(x_{t},t)}{\sqrt {{\bar {\alpha }}_{t}}}}\right)={\frac {x_{t}-\epsilon _{\theta }(x_{t},t)\beta _{t}/\sigma _{t}}{\sqrt {\alpha _{t}}}}}
  
It remains to design 
  
    
      
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \Sigma _{\theta }(x_{t},t)}
  
. The DDPM paper suggested not learning it (since it resulted in "unstable training and poorer sample quality"), but fixing it at some value 
  
    
      
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        =
        
          ζ
          
            t
          
          
            2
          
        
        I
      
    
    {\displaystyle \Sigma _{\theta }(x_{t},t)=\zeta _{t}^{2}I}
  
, where either 
  
    
      
        
          ζ
          
            t
          
          
            2
          
        
        =
        
          β
          
            t
          
        
        
           or 
        
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            2
          
        
      
    
    {\displaystyle \zeta _{t}^{2}=\beta _{t}{\text{ or }}{\tilde {\sigma }}_{t}^{2}}
  
 yielded similar performance.
With this, the loss simplifies to 
  
    
      
        
          L
          
            t
          
        
        =
        
          
            
              β
              
                t
              
              
                2
              
            
            
              2
              
                α
                
                  t
                
              
              
                σ
                
                  t
                
                
                  2
                
              
              
                ζ
                
                  t
                
                
                  2
                
              
            
          
        
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
            ;
            z
            ∼
            
              
                N
              
            
            (
            0
            ,
            I
            )
          
        
        
          [
          
            
              ‖
              
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
                −
                z
              
              ‖
            
            
              2
            
          
          ]
        
        +
        C
      
    
    {\displaystyle L_{t}={\frac {\beta _{t}^{2}}{2\alpha _{t}\sigma _{t}^{2}\zeta _{t}^{2}}}E_{x_{0}\sim q;z\sim {\mathcal {N}}(0,I)}\left[\left\|\epsilon _{\theta }(x_{t},t)-z\right\|^{2}\right]+C}
  
which may be minimized by stochastic gradient descent. The paper noted empirically that an even simpler loss function
  
    
      
        
          L
          
            s
            i
            m
            p
            l
            e
            ,
            t
          
        
        =
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
            ;
            z
            ∼
            
              
                N
              
            
            (
            0
            ,
            I
            )
          
        
        
          [
          
            
              ‖
              
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
                −
                z
              
              ‖
            
            
              2
            
          
          ]
        
      
    
    {\displaystyle L_{simple,t}=E_{x_{0}\sim q;z\sim {\mathcal {N}}(0,I)}\left[\left\|\epsilon _{\theta }(x_{t},t)-z\right\|^{2}\right]}
  
resulted in better models.


=== Backward diffusion process ===
After a noise prediction network is trained, it can be used for generating data points in the original distribution in a loop as follows:

Compute the noise estimate 
  
    
      
        ϵ
        ←
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon \leftarrow \epsilon _{\theta }(x_{t},t)}
  

Compute the original data estimate 
  
    
      
        
          
            
              
                x
                ~
              
            
          
          
            0
          
        
        ←
        (
        
          x
          
            t
          
        
        −
        
          σ
          
            t
          
        
        ϵ
        )
        
          /
        
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
      
    
    {\displaystyle {\tilde {x}}_{0}\leftarrow (x_{t}-\sigma _{t}\epsilon )/{\sqrt {{\bar {\alpha }}_{t}}}}
  

Sample the previous data 
  
    
      
        
          x
          
            t
            −
            1
          
        
        ∼
        
          
            N
          
        
        (
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          
            
              
                x
                ~
              
            
          
          
            0
          
        
        )
        ,
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            2
          
        
        I
        )
      
    
    {\displaystyle x_{t-1}\sim {\mathcal {N}}({\tilde {\mu }}_{t}(x_{t},{\tilde {x}}_{0}),{\tilde {\sigma }}_{t}^{2}I)}
  

Change time 
  
    
      
        t
        ←
        t
        −
        1
      
    
    {\displaystyle t\leftarrow t-1}
  


== Score-based generative model ==
Score-based generative model is another formulation of diffusion modelling. They are also called noise conditional score network (NCSN) or score-matching with Langevin dynamics (SMLD).


=== Score matching ===


==== The idea of score functions ====
Consider the problem of image generation. Let 
  
    
      
        x
      
    
    {\displaystyle x}
  
 represent an image, and let 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
 be the probability distribution over all possible images. If we have 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
 itself, then we can say for certain how likely a certain image is. However, this is intractable in general.
Most often, we are uninterested in knowing the absolute probability of a certain image. Instead, we are usually only interested in knowing how likely a certain image is compared to its immediate neighbors — e.g. how much more likely is an image of cat compared to some small variants of it? Is it more likely if the image contains two whiskers, or three, or with some Gaussian noise added?
Consequently, we are actually quite uninterested in 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
 itself, but rather, 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        q
        (
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln q(x)}
  
. This has two major effects:

One, we no longer need to normalize 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
, but can use any 
  
    
      
        
          
            
              q
              ~
            
          
        
        (
        x
        )
        =
        C
        q
        (
        x
        )
      
    
    {\displaystyle {\tilde {q}}(x)=Cq(x)}
  
, where 
  
    
      
        C
        =
        ∫
        
          
            
              q
              ~
            
          
        
        (
        x
        )
        d
        x
        >
        0
      
    
    {\displaystyle C=\int {\tilde {q}}(x)dx>0}
  
 is any unknown constant that is of no concern to us.
Two, we are comparing 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
 neighbors 
  
    
      
        q
        (
        x
        +
        d
        x
        )
      
    
    {\displaystyle q(x+dx)}
  
, by 
  
    
      
        
          
            
              q
              (
              x
              )
            
            
              q
              (
              x
              +
              d
              x
              )
            
          
        
        =
        
          e
          
            −
            ⟨
            
              ∇
              
                x
              
            
            ln
            ⁡
            q
            ,
            d
            x
            ⟩
          
        
      
    
    {\displaystyle {\frac {q(x)}{q(x+dx)}}=e^{-\langle \nabla _{x}\ln q,dx\rangle }}
  

Let the score function be 
  
    
      
        s
        (
        x
        )
        :=
        
          ∇
          
            x
          
        
        ln
        ⁡
        q
        (
        x
        )
      
    
    {\displaystyle s(x):=\nabla _{x}\ln q(x)}
  
; then consider what we can do with 
  
    
      
        s
        (
        x
        )
      
    
    {\displaystyle s(x)}
  
.
As it turns out, 
  
    
      
        s
        (
        x
        )
      
    
    {\displaystyle s(x)}
  
 allows us to sample from 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
 using thermodynamics. Specifically, if we have a potential energy function 
  
    
      
        U
        (
        x
        )
        =
        −
        ln
        ⁡
        q
        (
        x
        )
      
    
    {\displaystyle U(x)=-\ln q(x)}
  
, and a lot of particles in the potential well, then the distribution at thermodynamic equilibrium is the Boltzmann distribution 
  
    
      
        
          q
          
            U
          
        
        (
        x
        )
        ∝
        
          e
          
            −
            U
            (
            x
            )
            
              /
            
            
              k
              
                B
              
            
            T
          
        
        =
        q
        (
        x
        
          )
          
            1
            
              /
            
            
              k
              
                B
              
            
            T
          
        
      
    
    {\displaystyle q_{U}(x)\propto e^{-U(x)/k_{B}T}=q(x)^{1/k_{B}T}}
  
. At temperature 
  
    
      
        
          k
          
            B
          
        
        T
        =
        1
      
    
    {\displaystyle k_{B}T=1}
  
, the Boltzmann distribution is exactly 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
.
Therefore, to model 
  
    
      
        q
        (
        x
        )
      
    
    {\displaystyle q(x)}
  
, we may start with a particle sampled at any convenient distribution (such as the standard Gaussian distribution), then simulate the motion of the particle forwards according to the Langevin equation

  
    
      
        d
        
          x
          
            t
          
        
        =
        −
        
          ∇
          
            
              x
              
                t
              
            
          
        
        U
        (
        
          x
          
            t
          
        
        )
        d
        t
        +
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle dx_{t}=-\nabla _{x_{t}}U(x_{t})dt+dW_{t}}
  

and the Boltzmann distribution is, by Fokker-Planck equation, the unique thermodynamic equilibrium. So no matter what distribution 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 has, the distribution of 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 converges in distribution to 
  
    
      
        q
      
    
    {\displaystyle q}
  
 as 
  
    
      
        t
        →
        ∞
      
    
    {\displaystyle t\to \infty }
  
.


==== Learning the score function ====
Given a density 
  
    
      
        q
      
    
    {\displaystyle q}
  
, we wish to learn a score function approximation 
  
    
      
        
          f
          
            θ
          
        
        ≈
        ∇
        ln
        ⁡
        q
      
    
    {\displaystyle f_{\theta }\approx \nabla \ln q}
  
. This is score matching. Typically, score matching is formalized as minimizing Fisher divergence function 
  
    
      
        
          E
          
            q
          
        
        [
        ‖
        
          f
          
            θ
          
        
        (
        x
        )
        −
        ∇
        ln
        ⁡
        q
        (
        x
        )
        
          ‖
          
            2
          
        
        ]
      
    
    {\displaystyle E_{q}[\|f_{\theta }(x)-\nabla \ln q(x)\|^{2}]}
  
. By expanding the integral, and performing an integration by parts, 
  
    
      
        
          E
          
            q
          
        
        [
        ‖
        
          f
          
            θ
          
        
        (
        x
        )
        −
        ∇
        ln
        ⁡
        q
        (
        x
        )
        
          ‖
          
            2
          
        
        ]
        =
        
          E
          
            q
          
        
        [
        ‖
        
          f
          
            θ
          
        
        
          ‖
          
            2
          
        
        +
        2
        ∇
        ⋅
        
          f
          
            θ
          
        
        ]
        +
        C
      
    
    {\displaystyle E_{q}[\|f_{\theta }(x)-\nabla \ln q(x)\|^{2}]=E_{q}[\|f_{\theta }\|^{2}+2\nabla \cdot f_{\theta }]+C}
  
giving us a loss function, also known as the Hyvärinen scoring rule, that can be minimized by stochastic gradient descent.


==== Annealing the score function ====
Suppose we need to model the distribution of images, and we want 
  
    
      
        
          x
          
            0
          
        
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle x_{0}\sim {\mathcal {N}}(0,I)}
  
, a white-noise image. Now, most white-noise images do not look like real images, so 
  
    
      
        q
        (
        
          x
          
            0
          
        
        )
        ≈
        0
      
    
    {\displaystyle q(x_{0})\approx 0}
  
 for large swaths of 
  
    
      
        
          x
          
            0
          
        
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle x_{0}\sim {\mathcal {N}}(0,I)}
  
. This presents a problem for learning the score function, because if there are no samples around a certain point, then we can't learn the score function at that point. If we do not know the score function 
  
    
      
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        q
        (
        
          x
          
            t
          
        
        )
      
    
    {\displaystyle \nabla _{x_{t}}\ln q(x_{t})}
  
 at that point, then we cannot impose the time-evolution equation on a particle:
  
    
      
        d
        
          x
          
            t
          
        
        =
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        q
        (
        
          x
          
            t
          
        
        )
        d
        t
        +
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle dx_{t}=\nabla _{x_{t}}\ln q(x_{t})dt+dW_{t}}
  
To deal with this problem, we perform annealing. If 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is too different from a white-noise distribution, then progressively add noise until it is indistinguishable from one. That is, we perform a forward diffusion, then learn the score function, then use the score function to perform a backward diffusion.


=== Continuous diffusion processes ===


==== Forward diffusion process ====
Consider again the forward diffusion process, but this time in continuous time:
  
    
      
        
          x
          
            t
          
        
        =
        
          
            1
            −
            
              β
              
                t
              
            
          
        
        
          x
          
            t
            −
            1
          
        
        +
        
          
            
              β
              
                t
              
            
          
        
        
          z
          
            t
          
        
      
    
    {\displaystyle x_{t}={\sqrt {1-\beta _{t}}}x_{t-1}+{\sqrt {\beta _{t}}}z_{t}}
  
By taking the 
  
    
      
        
          β
          
            t
          
        
        →
        β
        (
        t
        )
        d
        t
        ,
        
          
            d
            t
          
        
        
          z
          
            t
          
        
        →
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle \beta _{t}\to \beta (t)dt,{\sqrt {dt}}z_{t}\to dW_{t}}
  
 limit, we obtain a continuous diffusion process, in the form of a stochastic differential equation:
  
    
      
        d
        
          x
          
            t
          
        
        =
        −
        
          
            1
            2
          
        
        β
        (
        t
        )
        
          x
          
            t
          
        
        d
        t
        +
        
          
            β
            (
            t
            )
          
        
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle dx_{t}=-{\frac {1}{2}}\beta (t)x_{t}dt+{\sqrt {\beta (t)}}dW_{t}}
  
where 
  
    
      
        
          W
          
            t
          
        
      
    
    {\displaystyle W_{t}}
  
 is a Wiener process (multidimensional Brownian motion).
Now, the equation is exactly a special case of the overdamped Langevin equation
  
    
      
        d
        
          x
          
            t
          
        
        =
        −
        
          
            D
            
              
                k
                
                  B
                
              
              T
            
          
        
        (
        
          ∇
          
            x
          
        
        U
        )
        d
        t
        +
        
          
            2
            D
          
        
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle dx_{t}=-{\frac {D}{k_{B}T}}(\nabla _{x}U)dt+{\sqrt {2D}}dW_{t}}
  
where 
  
    
      
        D
      
    
    {\displaystyle D}
  
 is diffusion tensor, 
  
    
      
        T
      
    
    {\displaystyle T}
  
 is temperature, and 
  
    
      
        U
      
    
    {\displaystyle U}
  
 is potential energy field. If we substitute in 
  
    
      
        D
        =
        
          
            1
            2
          
        
        β
        (
        t
        )
        I
        ,
        
          k
          
            B
          
        
        T
        =
        1
        ,
        U
        =
        
          
            1
            2
          
        
        ‖
        x
        
          ‖
          
            2
          
        
      
    
    {\displaystyle D={\frac {1}{2}}\beta (t)I,k_{B}T=1,U={\frac {1}{2}}\|x\|^{2}}
  
, we recover the above equation. This explains why the phrase "Langevin dynamics" is sometimes used in diffusion models.
Now the above equation is for the stochastic motion of a single particle. Suppose we have a cloud of particles distributed according to 
  
    
      
        q
      
    
    {\displaystyle q}
  
 at time 
  
    
      
        t
        =
        0
      
    
    {\displaystyle t=0}
  
, then after a long time, the cloud of particles would settle into the stable distribution of 
  
    
      
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle {\mathcal {N}}(0,I)}
  
. Let 
  
    
      
        
          ρ
          
            t
          
        
      
    
    {\displaystyle \rho _{t}}
  
 be the density of the cloud of particles at time 
  
    
      
        t
      
    
    {\displaystyle t}
  
, then we have
  
    
      
        
          ρ
          
            0
          
        
        =
        q
        ;
        
        
          ρ
          
            T
          
        
        ≈
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle \rho _{0}=q;\quad \rho _{T}\approx {\mathcal {N}}(0,I)}
  
and the goal is to somehow reverse the process, so that we can start at the end and diffuse back to the beginning.
By Fokker-Planck equation, the density of the cloud evolves according to
  
    
      
        
          ∂
          
            t
          
        
        ln
        ⁡
        
          ρ
          
            t
          
        
        =
        
          
            1
            2
          
        
        β
        (
        t
        )
        
          (
          
            n
            +
            (
            x
            +
            ∇
            ln
            ⁡
            
              ρ
              
                t
              
            
            )
            ⋅
            ∇
            ln
            ⁡
            
              ρ
              
                t
              
            
            +
            Δ
            ln
            ⁡
            
              ρ
              
                t
              
            
          
          )
        
      
    
    {\displaystyle \partial _{t}\ln \rho _{t}={\frac {1}{2}}\beta (t)\left(n+(x+\nabla \ln \rho _{t})\cdot \nabla \ln \rho _{t}+\Delta \ln \rho _{t}\right)}
  
where 
  
    
      
        n
      
    
    {\displaystyle n}
  
 is the dimension of space, and 
  
    
      
        Δ
      
    
    {\displaystyle \Delta }
  
 is the Laplace operator. Equivalently,
  
    
      
        
          ∂
          
            t
          
        
        
          ρ
          
            t
          
        
        =
        
          
            1
            2
          
        
        β
        (
        t
        )
        (
        ∇
        ⋅
        (
        x
        
          ρ
          
            t
          
        
        )
        +
        Δ
        
          ρ
          
            t
          
        
        )
      
    
    {\displaystyle \partial _{t}\rho _{t}={\frac {1}{2}}\beta (t)(\nabla \cdot (x\rho _{t})+\Delta \rho _{t})}
  


==== Backward diffusion process ====
If we have solved 
  
    
      
        
          ρ
          
            t
          
        
      
    
    {\displaystyle \rho _{t}}
  
 for time 
  
    
      
        t
        ∈
        [
        0
        ,
        T
        ]
      
    
    {\displaystyle t\in [0,T]}
  
, then we can exactly reverse the evolution of the cloud. Suppose we start with another cloud of particles with density 
  
    
      
        
          ν
          
            0
          
        
        =
        
          ρ
          
            T
          
        
      
    
    {\displaystyle \nu _{0}=\rho _{T}}
  
, and let the particles in the cloud evolve according to

  
    
      
        d
        
          y
          
            t
          
        
        =
        
          
            1
            2
          
        
        β
        (
        T
        −
        t
        )
        
          y
          
            t
          
        
        d
        t
        +
        β
        (
        T
        −
        t
        )
        
          
            
              
                
                  ∇
                  
                    
                      y
                      
                        t
                      
                    
                  
                
                ln
                ⁡
                
                  ρ
                  
                    T
                    −
                    t
                  
                
                
                  (
                  
                    y
                    
                      t
                    
                  
                  )
                
              
              ⏟
            
          
          
            score function 
          
        
        d
        t
        +
        
          
            β
            (
            T
            −
            t
            )
          
        
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle dy_{t}={\frac {1}{2}}\beta (T-t)y_{t}dt+\beta (T-t)\underbrace {\nabla _{y_{t}}\ln \rho _{T-t}\left(y_{t}\right)} _{\text{score function }}dt+{\sqrt {\beta (T-t)}}dW_{t}}
  

then by plugging into the Fokker-Planck equation, we find that 
  
    
      
        
          ∂
          
            t
          
        
        
          ρ
          
            T
            −
            t
          
        
        =
        
          ∂
          
            t
          
        
        
          ν
          
            t
          
        
      
    
    {\displaystyle \partial _{t}\rho _{T-t}=\partial _{t}\nu _{t}}
  
. Thus this cloud of points is the original cloud, evolving backwards.


=== Noise conditional score network (NCSN) ===
At the continuous limit, 

  
    
      
        
          
            
              
                α
                ¯
              
            
          
          
            t
          
        
        =
        (
        1
        −
        
          β
          
            1
          
        
        )
        ⋯
        (
        1
        −
        
          β
          
            t
          
        
        )
        =
        
          e
          
            
              ∑
              
                i
              
            
            ln
            ⁡
            (
            1
            −
            
              β
              
                i
              
            
            )
          
        
        →
        
          e
          
            −
            
              ∫
              
                0
              
              
                t
              
            
            β
            (
            t
            )
            d
            t
          
        
      
    
    {\displaystyle {\bar {\alpha }}_{t}=(1-\beta _{1})\cdots (1-\beta _{t})=e^{\sum _{i}\ln(1-\beta _{i})}\to e^{-\int _{0}^{t}\beta (t)dt}}
  

and so 

  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              e
              
                −
                
                  
                    1
                    2
                  
                
                
                  ∫
                  
                    0
                  
                  
                    t
                  
                
                β
                (
                t
                )
                d
                t
              
            
            
              x
              
                0
              
            
            ,
            
              (
              
                1
                −
                
                  e
                  
                    −
                    
                      ∫
                      
                        0
                      
                      
                        t
                      
                    
                    β
                    (
                    t
                    )
                    d
                    t
                  
                
              
              )
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left(e^{-{\frac {1}{2}}\int _{0}^{t}\beta (t)dt}x_{0},\left(1-e^{-\int _{0}^{t}\beta (t)dt}\right)I\right)}
  

In particular, we see that we can directly sample from any point in the continuous diffusion process without going through the intermediate steps, by first sampling 
  
    
      
        
          x
          
            0
          
        
        ∼
        q
        ,
        z
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle x_{0}\sim q,z\sim {\mathcal {N}}(0,I)}
  
, then get 
  
    
      
        
          x
          
            t
          
        
        =
        
          e
          
            −
            
              
                1
                2
              
            
            
              ∫
              
                0
              
              
                t
              
            
            β
            (
            t
            )
            d
            t
          
        
        
          x
          
            0
          
        
        +
        
          (
          
            1
            −
            
              e
              
                −
                
                  ∫
                  
                    0
                  
                  
                    t
                  
                
                β
                (
                t
                )
                d
                t
              
            
          
          )
        
        z
      
    
    {\displaystyle x_{t}=e^{-{\frac {1}{2}}\int _{0}^{t}\beta (t)dt}x_{0}+\left(1-e^{-\int _{0}^{t}\beta (t)dt}\right)z}
  
. That is, we can quickly sample 
  
    
      
        
          x
          
            t
          
        
        ∼
        
          ρ
          
            t
          
        
      
    
    {\displaystyle x_{t}\sim \rho _{t}}
  
 for any 
  
    
      
        t
        ≥
        0
      
    
    {\displaystyle t\geq 0}
  
.
Now, define a certain probability distribution 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
 over 
  
    
      
        [
        0
        ,
        ∞
        )
      
    
    {\displaystyle [0,\infty )}
  
, then the score-matching loss function is defined as the expected Fisher divergence:

  
    
      
        L
        (
        θ
        )
        =
        
          E
          
            t
            ∼
            γ
            ,
            
              x
              
                t
              
            
            ∼
            
              ρ
              
                t
              
            
          
        
        [
        ‖
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        
          ‖
          
            2
          
        
        +
        2
        ∇
        ⋅
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        ]
      
    
    {\displaystyle L(\theta )=E_{t\sim \gamma ,x_{t}\sim \rho _{t}}[\|f_{\theta }(x_{t},t)\|^{2}+2\nabla \cdot f_{\theta }(x_{t},t)]}
  

After training, 
  
    
      
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        ≈
        ∇
        ln
        ⁡
        
          ρ
          
            t
          
        
      
    
    {\displaystyle f_{\theta }(x_{t},t)\approx \nabla \ln \rho _{t}}
  
, so we can perform the backwards diffusion process by first sampling 
  
    
      
        
          x
          
            T
          
        
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle x_{T}\sim {\mathcal {N}}(0,I)}
  
, then integrating the SDE from 
  
    
      
        t
        =
        T
      
    
    {\displaystyle t=T}
  
 to 
  
    
      
        t
        =
        0
      
    
    {\displaystyle t=0}
  
:

  
    
      
        
          x
          
            t
            −
            d
            t
          
        
        =
        
          x
          
            t
          
        
        +
        
          
            1
            2
          
        
        β
        (
        t
        )
        
          x
          
            t
          
        
        d
        t
        +
        β
        (
        t
        )
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        d
        t
        +
        
          
            β
            (
            t
            )
          
        
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle x_{t-dt}=x_{t}+{\frac {1}{2}}\beta (t)x_{t}dt+\beta (t)f_{\theta }(x_{t},t)dt+{\sqrt {\beta (t)}}dW_{t}}
  

This may be done by any SDE integration method, such as Euler–Maruyama method.
The name "noise conditional score network" is explained thus:

"network", because 
  
    
      
        
          f
          
            θ
          
        
      
    
    {\displaystyle f_{\theta }}
  
 is implemented as a neural network.
"score", because the output of the network is interpreted as approximating the score function 
  
    
      
        ∇
        ln
        ⁡
        
          ρ
          
            t
          
        
      
    
    {\displaystyle \nabla \ln \rho _{t}}
  
.
"noise conditional", because 
  
    
      
        
          ρ
          
            t
          
        
      
    
    {\displaystyle \rho _{t}}
  
 is equal to 
  
    
      
        
          ρ
          
            0
          
        
      
    
    {\displaystyle \rho _{0}}
  
 blurred by an added Gaussian noise that increases with time, and so the score function depends on the amount of noise added.


== Their equivalence ==
DDPM and score-based generative models are equivalent. This means that a network trained using DDPM can be used as a NCSN, and vice versa.
We know that 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              x
              
                0
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle x_{t}|x_{0}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}x_{0},\sigma _{t}^{2}I\right)}
  
, so by Tweedie's formula, we have

  
    
      
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        q
        (
        
          x
          
            t
          
        
        )
        =
        
          
            1
            
              σ
              
                t
              
              
                2
              
            
          
        
        (
        −
        
          x
          
            t
          
        
        +
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          E
          
            q
          
        
        [
        
          x
          
            0
          
        
        
          |
        
        
          x
          
            t
          
        
        ]
        )
      
    
    {\displaystyle \nabla _{x_{t}}\ln q(x_{t})={\frac {1}{\sigma _{t}^{2}}}(-x_{t}+{\sqrt {{\bar {\alpha }}_{t}}}E_{q}[x_{0}|x_{t}])}
  

As described previously, the DDPM loss function is 
  
    
      
        
          ∑
          
            t
          
        
        
          L
          
            s
            i
            m
            p
            l
            e
            ,
            t
          
        
      
    
    {\displaystyle \sum _{t}L_{simple,t}}
  
 with

  
    
      
        
          L
          
            s
            i
            m
            p
            l
            e
            ,
            t
          
        
        =
        
          E
          
            
              x
              
                0
              
            
            ∼
            q
            ;
            z
            ∼
            
              
                N
              
            
            (
            0
            ,
            I
            )
          
        
        
          [
          
            
              ‖
              
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
                −
                z
              
              ‖
            
            
              2
            
          
          ]
        
      
    
    {\displaystyle L_{simple,t}=E_{x_{0}\sim q;z\sim {\mathcal {N}}(0,I)}\left[\left\|\epsilon _{\theta }(x_{t},t)-z\right\|^{2}\right]}
  

where 
  
    
      
        
          x
          
            t
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          x
          
            0
          
        
        +
        
          σ
          
            t
          
        
        z
      
    
    {\displaystyle x_{t}={\sqrt {{\bar {\alpha }}_{t}}}x_{0}+\sigma _{t}z}
  
. By a change of variables,

  
    
      
        
          L
          
            s
            i
            m
            p
            l
            e
            ,
            t
          
        
        =
        
          E
          
            
              x
              
                0
              
            
            ,
            
              x
              
                t
              
            
            ∼
            q
          
        
        
          [
          
            
              ‖
              
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
                −
                
                  
                    
                      
                        x
                        
                          t
                        
                      
                      −
                      
                        
                          
                            
                              
                                
                                  α
                                  ¯
                                
                              
                            
                            
                              t
                            
                          
                        
                      
                      
                        x
                        
                          0
                        
                      
                    
                    
                      σ
                      
                        t
                      
                    
                  
                
              
              ‖
            
            
              2
            
          
          ]
        
        =
        
          E
          
            
              x
              
                t
              
            
            ∼
            q
            ,
            
              x
              
                0
              
            
            ∼
            q
            (
            ⋅
            
              |
            
            
              x
              
                t
              
            
            )
          
        
        
          [
          
            
              ‖
              
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
                −
                
                  
                    
                      
                        x
                        
                          t
                        
                      
                      −
                      
                        
                          
                            
                              
                                
                                  α
                                  ¯
                                
                              
                            
                            
                              t
                            
                          
                        
                      
                      
                        x
                        
                          0
                        
                      
                    
                    
                      σ
                      
                        t
                      
                    
                  
                
              
              ‖
            
            
              2
            
          
          ]
        
      
    
    {\displaystyle L_{simple,t}=E_{x_{0},x_{t}\sim q}\left[\left\|\epsilon _{\theta }(x_{t},t)-{\frac {x_{t}-{\sqrt {{\bar {\alpha }}_{t}}}x_{0}}{\sigma _{t}}}\right\|^{2}\right]=E_{x_{t}\sim q,x_{0}\sim q(\cdot |x_{t})}\left[\left\|\epsilon _{\theta }(x_{t},t)-{\frac {x_{t}-{\sqrt {{\bar {\alpha }}_{t}}}x_{0}}{\sigma _{t}}}\right\|^{2}\right]}
  

and the term inside becomes a least squares regression, so if the network actually reaches the global minimum of loss, then we have 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        =
        
          
            
              
                x
                
                  t
                
              
              −
              
                
                  
                    
                      
                        
                          α
                          ¯
                        
                      
                    
                    
                      t
                    
                  
                
              
              
                E
                
                  q
                
              
              [
              
                x
                
                  0
                
              
              
                |
              
              
                x
                
                  t
                
              
              ]
            
            
              σ
              
                t
              
            
          
        
        =
        −
        
          σ
          
            t
          
        
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        q
        (
        
          x
          
            t
          
        
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},t)={\frac {x_{t}-{\sqrt {{\bar {\alpha }}_{t}}}E_{q}[x_{0}|x_{t}]}{\sigma _{t}}}=-\sigma _{t}\nabla _{x_{t}}\ln q(x_{t})}
  

Thus, given a good score-based network, its predicted score is a good prediction of the noise (after scaling by 
  
    
      
        
          σ
          
            t
          
        
      
    
    {\displaystyle \sigma _{t}}
  
), and thus can be used for denoising.
Conversely, the continuous limit 
  
    
      
        
          x
          
            t
            −
            1
          
        
        =
        
          x
          
            t
            −
            d
            t
          
        
        ,
        
          β
          
            t
          
        
        =
        β
        (
        t
        )
        d
        t
        ,
        
          z
          
            t
          
        
        
          
            d
            t
          
        
        =
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle x_{t-1}=x_{t-dt},\beta _{t}=\beta (t)dt,z_{t}{\sqrt {dt}}=dW_{t}}
  
 of the backward equation

  
    
      
        
          x
          
            t
            −
            1
          
        
        =
        
          
            
              x
              
                t
              
            
            
              
                α
                
                  t
                
              
            
          
        
        −
        
          
            
              β
              
                t
              
            
            
              
                σ
                
                  t
                
              
              
                
                  
                    α
                    
                      t
                    
                  
                
              
            
          
        
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        +
        
          
            
              β
              
                t
              
            
          
        
        
          z
          
            t
          
        
        ;
        
        
          z
          
            t
          
        
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle x_{t-1}={\frac {x_{t}}{\sqrt {\alpha _{t}}}}-{\frac {\beta _{t}}{\sigma _{t}{\sqrt {\alpha _{t}}}}}\epsilon _{\theta }(x_{t},t)+{\sqrt {\beta _{t}}}z_{t};\quad z_{t}\sim {\mathcal {N}}(0,I)}
  

gives us precisely the same equation as score-based diffusion:

  
    
      
        
          x
          
            t
            −
            d
            t
          
        
        =
        
          x
          
            t
          
        
        (
        1
        +
        β
        (
        t
        )
        d
        t
        
          /
        
        2
        )
        +
        β
        (
        t
        )
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        q
        (
        
          x
          
            t
          
        
        )
        d
        t
        +
        
          
            β
            (
            t
            )
          
        
        d
        
          W
          
            t
          
        
      
    
    {\displaystyle x_{t-dt}=x_{t}(1+\beta (t)dt/2)+\beta (t)\nabla _{x_{t}}\ln q(x_{t})dt+{\sqrt {\beta (t)}}dW_{t}}
  
Thus, at infinitesimal steps of DDPM, a denoising network performs score-based diffusion.


== Main variants ==


=== Noise schedule ===

In DDPM, the sequence of numbers 
  
    
      
        0
        =
        
          σ
          
            0
          
        
        <
        
          σ
          
            1
          
        
        <
        ⋯
        <
        
          σ
          
            T
          
        
        <
        1
      
    
    {\displaystyle 0=\sigma _{0}<\sigma _{1}<\cdots <\sigma _{T}<1}
  
 is called a (discrete time) noise schedule. In general, consider a strictly increasing monotonic function 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
  
 of type 
  
    
      
        
          R
        
        →
        (
        0
        ,
        1
        )
      
    
    {\displaystyle \mathbb {R} \to (0,1)}
  
, such as the sigmoid function. In that case, a noise schedule is a sequence of real numbers 
  
    
      
        
          λ
          
            1
          
        
        <
        
          λ
          
            2
          
        
        <
        ⋯
        <
        
          λ
          
            T
          
        
      
    
    {\displaystyle \lambda _{1}<\lambda _{2}<\cdots <\lambda _{T}}
  
. It then defines a sequence of noises 
  
    
      
        
          σ
          
            t
          
        
        :=
        σ
        (
        
          λ
          
            t
          
        
        )
      
    
    {\displaystyle \sigma _{t}:=\sigma (\lambda _{t})}
  
, which then derives the other quantities 
  
    
      
        
          β
          
            t
          
        
        =
        1
        −
        
          
            
              1
              −
              
                σ
                
                  t
                
                
                  2
                
              
            
            
              1
              −
              
                σ
                
                  t
                  −
                  1
                
                
                  2
                
              
            
          
        
      
    
    {\displaystyle \beta _{t}=1-{\frac {1-\sigma _{t}^{2}}{1-\sigma _{t-1}^{2}}}}
  
.
In order to use arbitrary noise schedules, instead of training a noise prediction model 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},t)}
  
, one trains 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        
          σ
          
            t
          
        
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},\sigma _{t})}
  
.
Similarly, for the noise conditional score network, instead of training 
  
    
      
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle f_{\theta }(x_{t},t)}
  
, one trains 
  
    
      
        
          f
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        
          σ
          
            t
          
        
        )
      
    
    {\displaystyle f_{\theta }(x_{t},\sigma _{t})}
  
.


=== Denoising Diffusion Implicit Model (DDIM) ===
The original DDPM method for generating images is slow, since the forward diffusion process usually takes 
  
    
      
        T
        ∼
        1000
      
    
    {\displaystyle T\sim 1000}
  
 to make the distribution of 
  
    
      
        
          x
          
            T
          
        
      
    
    {\displaystyle x_{T}}
  
 to appear close to Gaussian. However this means the backward diffusion process also take 1000 steps. Unlike the forward diffusion process, which can skip steps as 
  
    
      
        
          x
          
            t
          
        
        
          |
        
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{t}|x_{0}}
  
 is Gaussian for all 
  
    
      
        t
        ≥
        1
      
    
    {\displaystyle t\geq 1}
  
, the backward diffusion process does not allow skipping steps. For example, to sample 
  
    
      
        
          x
          
            t
            −
            2
          
        
        
          |
        
        
          x
          
            t
            −
            1
          
        
        ∼
        
          
            N
          
        
        (
        
          μ
          
            θ
          
        
        (
        
          x
          
            t
            −
            1
          
        
        ,
        t
        −
        1
        )
        ,
        
          Σ
          
            θ
          
        
        (
        
          x
          
            t
            −
            1
          
        
        ,
        t
        −
        1
        )
        )
      
    
    {\displaystyle x_{t-2}|x_{t-1}\sim {\mathcal {N}}(\mu _{\theta }(x_{t-1},t-1),\Sigma _{\theta }(x_{t-1},t-1))}
  
 requires the model to first sample 
  
    
      
        
          x
          
            t
            −
            1
          
        
      
    
    {\displaystyle x_{t-1}}
  
. Attempting to directly sample 
  
    
      
        
          x
          
            t
            −
            2
          
        
        
          |
        
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t-2}|x_{t}}
  
 would require us to marginalize out 
  
    
      
        
          x
          
            t
            −
            1
          
        
      
    
    {\displaystyle x_{t-1}}
  
, which is generally intractable.
DDIM is a method to take any model trained on DDPM loss, and use it to sample with some steps skipped, sacrificing an adjustable amount of quality. If we generate the Markovian chain case in DDPM to non-Markovian case, DDIM corresponds to the case that the reverse process has variance equals to 0. In other words, the reverse process (and also the forward process) is deterministic. When using fewer sampling steps, DDIM outperforms DDPM.
In detail, the DDIM sampling method is as follows. Start with the forward diffusion process 
  
    
      
        
          x
          
            t
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          x
          
            0
          
        
        +
        
          σ
          
            t
          
        
        ϵ
      
    
    {\displaystyle x_{t}={\sqrt {{\bar {\alpha }}_{t}}}x_{0}+\sigma _{t}\epsilon }
  
. Then, during the backward denoising process, given 
  
    
      
        
          x
          
            t
          
        
        ,
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle x_{t},\epsilon _{\theta }(x_{t},t)}
  
, the original data is estimated as 
  
    
      
        
          x
          
            0
          
          ′
        
        =
        
          
            
              
                x
                
                  t
                
              
              −
              
                σ
                
                  t
                
              
              
                ϵ
                
                  θ
                
              
              (
              
                x
                
                  t
                
              
              ,
              t
              )
            
            
              
                
                  
                    
                      α
                      ¯
                    
                  
                
                
                  t
                
              
            
          
        
      
    
    {\displaystyle x_{0}'={\frac {x_{t}-\sigma _{t}\epsilon _{\theta }(x_{t},t)}{\sqrt {{\bar {\alpha }}_{t}}}}}
  
then the backward diffusion process can jump to any step 
  
    
      
        0
        ≤
        s
        <
        t
      
    
    {\displaystyle 0\leq s<t}
  
, and the next denoised sample is 
  
    
      
        
          x
          
            s
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                s
              
            
          
        
        
          x
          
            0
          
          ′
        
        +
        
          
            
              σ
              
                s
              
              
                2
              
            
            −
            (
            
              σ
              
                s
              
              ′
            
            
              )
              
                2
              
            
          
        
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        +
        
          σ
          
            s
          
          ′
        
        ϵ
      
    
    {\displaystyle x_{s}={\sqrt {{\bar {\alpha }}_{s}}}x_{0}'+{\sqrt {\sigma _{s}^{2}-(\sigma '_{s})^{2}}}\epsilon _{\theta }(x_{t},t)+\sigma _{s}'\epsilon }
  
where 
  
    
      
        
          σ
          
            s
          
          ′
        
      
    
    {\displaystyle \sigma _{s}'}
  
 is an arbitrary real number within the range 
  
    
      
        [
        0
        ,
        
          σ
          
            s
          
        
        ]
      
    
    {\displaystyle [0,\sigma _{s}]}
  
, and 
  
    
      
        ϵ
        ∼
        
          
            N
          
        
        (
        0
        ,
        I
        )
      
    
    {\displaystyle \epsilon \sim {\mathcal {N}}(0,I)}
  
 is a newly sampled Gaussian noise. If all 
  
    
      
        
          σ
          
            s
          
          ′
        
        =
        0
      
    
    {\displaystyle \sigma _{s}'=0}
  
, then the backward process becomes deterministic, and this special case of DDIM is also called "DDIM". The original paper noted that when the process is deterministic, samples generated with only 20 steps are already very similar to ones generated with 1000 steps on the high-level.
The original paper recommended defining a single "eta value" 
  
    
      
        η
        ∈
        [
        0
        ,
        1
        ]
      
    
    {\displaystyle \eta \in [0,1]}
  
, such that 
  
    
      
        
          σ
          
            s
          
          ′
        
        =
        η
        
          
            
              
                σ
                ~
              
            
          
          
            s
          
        
      
    
    {\displaystyle \sigma _{s}'=\eta {\tilde {\sigma }}_{s}}
  
. When 
  
    
      
        η
        =
        1
      
    
    {\displaystyle \eta =1}
  
, this is the original DDPM. When 
  
    
      
        η
        =
        0
      
    
    {\displaystyle \eta =0}
  
, this is the fully deterministic DDIM. For intermediate values, the process interpolates between them.
By the equivalence, the DDIM algorithm also applies for score-based diffusion models.


=== Latent diffusion model (LDM) ===

Since the diffusion model is a general method for modelling probability distributions, if one wants to model a distribution over images, one can first encode the images into a lower-dimensional space by an encoder, then use a diffusion model to model the distribution over encoded images. Then to generate an image, one can sample from the diffusion model, then use a decoder to decode it into an image.
The encoder-decoder pair is most often a variational autoencoder (VAE).


=== Architectural improvements ===
 proposed various architectural improvements. For example, they proposed log-space interpolation during backward sampling. Instead of sampling from 
  
    
      
        
          x
          
            t
            −
            1
          
        
        ∼
        
          
            N
          
        
        (
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          
            
              
                x
                ~
              
            
          
          
            0
          
        
        )
        ,
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            2
          
        
        I
        )
      
    
    {\displaystyle x_{t-1}\sim {\mathcal {N}}({\tilde {\mu }}_{t}(x_{t},{\tilde {x}}_{0}),{\tilde {\sigma }}_{t}^{2}I)}
  
, they recommended sampling from 
  
    
      
        
          
            N
          
        
        (
        
          
            
              
                μ
                ~
              
            
          
          
            t
          
        
        (
        
          x
          
            t
          
        
        ,
        
          
            
              
                x
                ~
              
            
          
          
            0
          
        
        )
        ,
        (
        
          σ
          
            t
          
          
            v
          
        
        
          
            
              
                σ
                ~
              
            
          
          
            t
          
          
            1
            −
            v
          
        
        
          )
          
            2
          
        
        I
        )
      
    
    {\displaystyle {\mathcal {N}}({\tilde {\mu }}_{t}(x_{t},{\tilde {x}}_{0}),(\sigma _{t}^{v}{\tilde {\sigma }}_{t}^{1-v})^{2}I)}
  
 for a learned parameter 
  
    
      
        v
      
    
    {\displaystyle v}
  
.
In the v-prediction formalism, the noising formula 
  
    
      
        
          x
          
            t
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          x
          
            0
          
        
        +
        
          
            1
            −
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        
          ϵ
          
            t
          
        
      
    
    {\displaystyle x_{t}={\sqrt {{\bar {\alpha }}_{t}}}x_{0}+{\sqrt {1-{\bar {\alpha }}_{t}}}\epsilon _{t}}
  
 is reparameterised by an angle 
  
    
      
        
          ϕ
          
            t
          
        
      
    
    {\displaystyle \phi _{t}}
  
 such that 
  
    
      
        cos
        ⁡
        
          ϕ
          
            t
          
        
        =
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
      
    
    {\displaystyle \cos \phi _{t}={\sqrt {{\bar {\alpha }}_{t}}}}
  
 and a "velocity" defined by 
  
    
      
        cos
        ⁡
        
          ϕ
          
            t
          
        
        
          ϵ
          
            t
          
        
        −
        sin
        ⁡
        
          ϕ
          
            t
          
        
        
          x
          
            0
          
        
      
    
    {\displaystyle \cos \phi _{t}\epsilon _{t}-\sin \phi _{t}x_{0}}
  
. The network is trained to predict the velocity 
  
    
      
        
          
            
              
                v
                ^
              
            
          
          
            θ
          
        
      
    
    {\displaystyle {\hat {v}}_{\theta }}
  
, and denoising is by 
  
    
      
        
          x
          
            
              ϕ
              
                t
              
            
            −
            δ
          
        
        =
        cos
        ⁡
        (
        δ
        )
        
        
          x
          
            
              ϕ
              
                t
              
            
          
        
        −
        sin
        ⁡
        (
        δ
        )
        
          
            
              
                v
                ^
              
            
          
          
            θ
          
        
        
        (
        
          x
          
            
              ϕ
              
                t
              
            
          
        
        )
      
    
    {\displaystyle x_{\phi _{t}-\delta }=\cos(\delta )\;x_{\phi _{t}}-\sin(\delta ){\hat {v}}_{\theta }\;(x_{\phi _{t}})}
  
. This parameterization was found to improve performance, as the model can be trained to reach total noise (i.e. 
  
    
      
        
          ϕ
          
            t
          
        
        =
        
          90
          
            ∘
          
        
      
    
    {\displaystyle \phi _{t}=90^{\circ }}
  
) and then reverse it, whereas the standard parameterization never reaches total noise since 
  
    
      
        
          
            
              
                
                  
                    α
                    ¯
                  
                
              
              
                t
              
            
          
        
        >
        0
      
    
    {\displaystyle {\sqrt {{\bar {\alpha }}_{t}}}>0}
  
 is always true.


=== Classifier guidance ===
Classifier guidance was proposed in 2021 to improve class-conditional generation by using a classifier. The original publication used CLIP text encoders to improve text-conditional image generation.
Suppose we wish to sample not from the entire distribution of images, but conditional on the image description. We don't want to sample a generic image, but an image that fits the description "black cat with red eyes". Generally, we want to sample from the distribution 
  
    
      
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle p(x|y)}
  
, where 
  
    
      
        x
      
    
    {\displaystyle x}
  
 ranges over images, and 
  
    
      
        y
      
    
    {\displaystyle y}
  
 ranges over classes of images (a description "black cat with red eyes" is just a very detailed class, and a class "cat" is just a very vague description).
Taking the perspective of the noisy channel model, we can understand the process as follows: To generate an image 
  
    
      
        x
      
    
    {\displaystyle x}
  
 conditional on description 
  
    
      
        y
      
    
    {\displaystyle y}
  
, we imagine that the requester really had in mind an image 
  
    
      
        x
      
    
    {\displaystyle x}
  
, but the image is passed through a noisy channel and came out garbled, as 
  
    
      
        y
      
    
    {\displaystyle y}
  
. Image generation is then nothing but inferring which 
  
    
      
        x
      
    
    {\displaystyle x}
  
 the requester had in mind.
In other words, conditional image generation is simply "translating from a textual language into a pictorial language". Then, as in noisy-channel model, we use Bayes theorem to get

  
    
      
        p
        (
        x
        
          |
        
        y
        )
        ∝
        p
        (
        y
        
          |
        
        x
        )
        p
        (
        x
        )
      
    
    {\displaystyle p(x|y)\propto p(y|x)p(x)}
  

in other words, if we have a good model of the space of all images, and a good image-to-class translator, we get a class-to-image translator "for free". In the equation for backward diffusion, the score 
  
    
      
        ∇
        ln
        ⁡
        p
        (
        x
        )
      
    
    {\displaystyle \nabla \ln p(x)}
  
 can be replaced by

  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        
          |
        
        y
        )
        =
        
          
            
              
                
                  ∇
                  
                    x
                  
                
                ln
                ⁡
                p
                (
                x
                )
              
              ⏟
            
          
          
            score
          
        
        +
        
          
            
              
                
                  ∇
                  
                    x
                  
                
                ln
                ⁡
                p
                (
                y
                
                  |
                
                x
                )
              
              ⏟
            
          
          
            classifier guidance
          
        
      
    
    {\displaystyle \nabla _{x}\ln p(x|y)=\underbrace {\nabla _{x}\ln p(x)} _{\text{score}}+\underbrace {\nabla _{x}\ln p(y|x)} _{\text{classifier guidance}}}
  

where 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln p(x)}
  
 is the score function, trained as previously described, and 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        y
        
          |
        
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln p(y|x)}
  
 is found by using a differentiable image classifier.
During the diffusion process, we need to condition on the time, giving
  
    
      
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        
          x
          
            t
          
        
        
          |
        
        y
        ,
        t
        )
        =
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        y
        
          |
        
        
          x
          
            t
          
        
        ,
        t
        )
        +
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        
          x
          
            t
          
        
        
          |
        
        t
        )
      
    
    {\displaystyle \nabla _{x_{t}}\ln p(x_{t}|y,t)=\nabla _{x_{t}}\ln p(y|x_{t},t)+\nabla _{x_{t}}\ln p(x_{t}|t)}
  
Although, usually the classifier model does not depend on time, in which case 
  
    
      
        p
        (
        y
        
          |
        
        
          x
          
            t
          
        
        ,
        t
        )
        =
        p
        (
        y
        
          |
        
        
          x
          
            t
          
        
        )
      
    
    {\displaystyle p(y|x_{t},t)=p(y|x_{t})}
  
.
Classifier guidance is defined for the gradient of score function, thus for score-based diffusion network, but as previously noted, score-based diffusion models are equivalent to denoising models by 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        =
        −
        
          σ
          
            t
          
        
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        
          x
          
            t
          
        
        
          |
        
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},t)=-\sigma _{t}\nabla _{x_{t}}\ln p(x_{t}|t)}
  
, and similarly, 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        )
        =
        −
        
          σ
          
            t
          
        
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        
          x
          
            t
          
        
        
          |
        
        y
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},y,t)=-\sigma _{t}\nabla _{x_{t}}\ln p(x_{t}|y,t)}
  
. Therefore, classifier guidance works for denoising diffusion as well, using the modified noise prediction:
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        )
        =
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        −
        
          
            
              
                
                  σ
                  
                    t
                  
                
                
                  ∇
                  
                    
                      x
                      
                        t
                      
                    
                  
                
                ln
                ⁡
                p
                (
                y
                
                  |
                
                
                  x
                  
                    t
                  
                
                ,
                t
                )
              
              ⏟
            
          
          
            classifier guidance
          
        
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},y,t)=\epsilon _{\theta }(x_{t},t)-\underbrace {\sigma _{t}\nabla _{x_{t}}\ln p(y|x_{t},t)} _{\text{classifier guidance}}}
  


==== With temperature ====
The classifier-guided diffusion model samples from 
  
    
      
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle p(x|y)}
  
, which is concentrated around the maximum a posteriori estimate 
  
    
      
        arg
        ⁡
        
          max
          
            x
          
        
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle \arg \max _{x}p(x|y)}
  
. If we want to force the model to move towards the maximum likelihood estimate 
  
    
      
        arg
        ⁡
        
          max
          
            x
          
        
        p
        (
        y
        
          |
        
        x
        )
      
    
    {\displaystyle \arg \max _{x}p(y|x)}
  
, we can use 

  
    
      
        
          p
          
            γ
          
        
        (
        x
        
          |
        
        y
        )
        ∝
        p
        (
        y
        
          |
        
        x
        
          )
          
            γ
          
        
        p
        (
        x
        )
      
    
    {\displaystyle p_{\gamma }(x|y)\propto p(y|x)^{\gamma }p(x)}
  

where 
  
    
      
        γ
        >
        0
      
    
    {\displaystyle \gamma >0}
  
 is interpretable as inverse temperature. In the context of diffusion models, it is usually called the guidance scale. A high 
  
    
      
        γ
      
    
    {\displaystyle \gamma }
  
 would force the model to sample from a distribution concentrated around 
  
    
      
        arg
        ⁡
        
          max
          
            x
          
        
        p
        (
        y
        
          |
        
        x
        )
      
    
    {\displaystyle \arg \max _{x}p(y|x)}
  
. This sometimes improves quality of generated images.
This gives a modification to the previous equation:
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        
          p
          
            β
          
        
        (
        x
        
          |
        
        y
        )
        =
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        )
        +
        γ
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        y
        
          |
        
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln p_{\beta }(x|y)=\nabla _{x}\ln p(x)+\gamma \nabla _{x}\ln p(y|x)}
  
For denoising models, it corresponds to
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        )
        =
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        −
        γ
        
          σ
          
            t
          
        
        
          ∇
          
            
              x
              
                t
              
            
          
        
        ln
        ⁡
        p
        (
        y
        
          |
        
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},y,t)=\epsilon _{\theta }(x_{t},t)-\gamma \sigma _{t}\nabla _{x_{t}}\ln p(y|x_{t},t)}
  


=== Classifier-free guidance (CFG) ===
If we do not have a classifier 
  
    
      
        p
        (
        y
        
          |
        
        x
        )
      
    
    {\displaystyle p(y|x)}
  
, we could still extract one out of the image model itself:

  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        
          p
          
            γ
          
        
        (
        x
        
          |
        
        y
        )
        =
        (
        1
        −
        γ
        )
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        )
        +
        γ
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle \nabla _{x}\ln p_{\gamma }(x|y)=(1-\gamma )\nabla _{x}\ln p(x)+\gamma \nabla _{x}\ln p(x|y)}
  

Such a model is usually trained by presenting it with both 
  
    
      
        (
        x
        ,
        y
        )
      
    
    {\displaystyle (x,y)}
  
 and 
  
    
      
        (
        x
        ,
        
          
            N
            o
            n
            e
          
        
        )
      
    
    {\displaystyle (x,{\rm {None}})}
  
, allowing it to model both 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle \nabla _{x}\ln p(x|y)}
  
 and 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln p(x)}
  
.
Note that for CFG, the diffusion model cannot be merely a generative model of the entire data distribution 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        )
      
    
    {\displaystyle \nabla _{x}\ln p(x)}
  
. It must be a conditional generative model 
  
    
      
        
          ∇
          
            x
          
        
        ln
        ⁡
        p
        (
        x
        
          |
        
        y
        )
      
    
    {\displaystyle \nabla _{x}\ln p(x|y)}
  
. For example, in stable diffusion, the diffusion backbone takes as input both a noisy model 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
, a time 
  
    
      
        t
      
    
    {\displaystyle t}
  
, and a conditioning vector 
  
    
      
        y
      
    
    {\displaystyle y}
  
 (such as a vector encoding a text prompt), and produces a noise prediction 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},y,t)}
  
.
For denoising models, it corresponds to
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        ,
        γ
        )
        =
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        +
        γ
        (
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        y
        ,
        t
        )
        −
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},y,t,\gamma )=\epsilon _{\theta }(x_{t},t)+\gamma (\epsilon _{\theta }(x_{t},y,t)-\epsilon _{\theta }(x_{t},t))}
  
As sampled by DDIM, the algorithm can be written as
  
    
      
        
          
            
              
                
                  ϵ
                  
                    uncond
                  
                
              
              
                
                ←
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                )
              
            
            
              
                
                  ϵ
                  
                    cond
                  
                
              
              
                
                ←
                
                  ϵ
                  
                    θ
                  
                
                (
                
                  x
                  
                    t
                  
                
                ,
                t
                ,
                c
                )
              
            
            
              
                
                  ϵ
                  
                    CFG
                  
                
              
              
                
                ←
                
                  ϵ
                  
                    uncond
                  
                
                +
                γ
                (
                
                  ϵ
                  
                    cond
                  
                
                −
                
                  ϵ
                  
                    uncond
                  
                
                )
              
            
            
              
                
                  x
                  
                    0
                  
                
              
              
                
                ←
                (
                
                  x
                  
                    t
                  
                
                −
                
                  σ
                  
                    t
                  
                
                
                  ϵ
                  
                    CFG
                  
                
                )
                
                  /
                
                
                  
                    1
                    −
                    
                      σ
                      
                        t
                      
                      
                        2
                      
                    
                  
                
              
            
            
              
                
                  x
                  
                    s
                  
                
              
              
                
                ←
                
                  
                    1
                    −
                    
                      σ
                      
                        s
                      
                      
                        2
                      
                    
                  
                
                
                  x
                  
                    0
                  
                
                +
                
                  
                    
                      σ
                      
                        s
                      
                      
                        2
                      
                    
                    −
                    (
                    
                      σ
                      
                        s
                      
                      ′
                    
                    
                      )
                      
                        2
                      
                    
                  
                
                
                  ϵ
                  
                    uncond
                  
                
                +
                
                  σ
                  
                    s
                  
                  ′
                
                ϵ
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\epsilon _{\text{uncond}}&\leftarrow \epsilon _{\theta }(x_{t},t)\\\epsilon _{\text{cond}}&\leftarrow \epsilon _{\theta }(x_{t},t,c)\\\epsilon _{\text{CFG}}&\leftarrow \epsilon _{\text{uncond}}+\gamma (\epsilon _{\text{cond}}-\epsilon _{\text{uncond}})\\x_{0}&\leftarrow (x_{t}-\sigma _{t}\epsilon _{\text{CFG}})/{\sqrt {1-\sigma _{t}^{2}}}\\x_{s}&\leftarrow {\sqrt {1-\sigma _{s}^{2}}}x_{0}+{\sqrt {\sigma _{s}^{2}-(\sigma _{s}')^{2}}}\epsilon _{\text{uncond}}+\sigma _{s}'\epsilon \\\end{aligned}}}
  
A similar technique applies to language model sampling. Also, if the unconditional generation 
  
    
      
        
          ϵ
          
            uncond
          
        
        ←
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\text{uncond}}\leftarrow \epsilon _{\theta }(x_{t},t)}
  
 is replaced by 
  
    
      
        
          ϵ
          
            neg cond
          
        
        ←
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        ,
        
          c
          ′
        
        )
      
    
    {\displaystyle \epsilon _{\text{neg cond}}\leftarrow \epsilon _{\theta }(x_{t},t,c')}
  
, then it results in negative prompting, which pushes the generation away from 
  
    
      
        
          c
          ′
        
      
    
    {\displaystyle c'}
  
 condition.


=== Samplers ===
Given a diffusion model, one may regard it either as a continuous process, and sample from it by integrating a SDE, or one can regard it as a discrete process, and sample from it by iterating the discrete steps. The choice of the "noise schedule" 
  
    
      
        
          β
          
            t
          
        
      
    
    {\displaystyle \beta _{t}}
  
 can also affect the quality of samples. A noise schedule is a function that sends a natural number to a noise level: 
  
    
      
        t
        ↦
        
          β
          
            t
          
        
        ,
        
        t
        ∈
        {
        1
        ,
        2
        ,
        …
        }
        ,
        β
        ∈
        (
        0
        ,
        1
        )
      
    
    {\displaystyle t\mapsto \beta _{t},\quad t\in \{1,2,\dots \},\beta \in (0,1)}
  
A noise schedule is more often specified by a map 
  
    
      
        t
        ↦
        
          σ
          
            t
          
        
      
    
    {\displaystyle t\mapsto \sigma _{t}}
  
. The two definitions are equivalent, since 
  
    
      
        
          β
          
            t
          
        
        =
        1
        −
        
          
            
              1
              −
              
                σ
                
                  t
                
                
                  2
                
              
            
            
              1
              −
              
                σ
                
                  t
                  −
                  1
                
                
                  2
                
              
            
          
        
      
    
    {\displaystyle \beta _{t}=1-{\frac {1-\sigma _{t}^{2}}{1-\sigma _{t-1}^{2}}}}
  
.
In the DDPM perspective, one can use the DDPM itself (with noise), or DDIM (with adjustable amount of noise). The case where one adds noise is sometimes called ancestral sampling. One can interpolate between noise and no noise. The amount of noise is denoted 
  
    
      
        η
      
    
    {\displaystyle \eta }
  
 ("eta value") in the DDIM paper, with 
  
    
      
        η
        =
        0
      
    
    {\displaystyle \eta =0}
  
 denoting no noise (as in deterministic DDIM), and 
  
    
      
        η
        =
        1
      
    
    {\displaystyle \eta =1}
  
 denoting full noise (as in DDPM).
In the perspective of SDE, one can use any of the numerical integration methods, such as Euler–Maruyama method, Heun's method, linear multistep methods, etc. Just as in the discrete case, one can add an adjustable amount of noise during the integration.
A survey and comparison of samplers in the context of image generation is in.


=== Other examples ===
Notable variants include Poisson flow generative model, consistency model, critically damped Langevin diffusion, GenPhys, cold diffusion, etc.


== Flow-based diffusion model ==
Abstractly speaking, the idea of diffusion model is to take an unknown probability distribution (the distribution of natural-looking images), then progressively convert it to a known probability distribution (standard Gaussian distribution), by building an absolutely continuous probability path connecting them. The probability path is in fact defined implicitly by the score function 
  
    
      
        ∇
        ln
        ⁡
        
          p
          
            t
          
        
      
    
    {\displaystyle \nabla \ln p_{t}}
  
.
In denoising diffusion models, the forward process adds noise, and the backward process removes noise. Both the forward and backward processes are SDEs, though the forward process is integrable in closed-form, so it can be done at no computational cost. The backward process is not integrable in closed-form, so it must be integrated step-by-step by standard SDE solvers, which can be very expensive. The probability path in diffusions model is defined through an Itô process and one can retrieve the deterministic process by using the Probability ODE flow formulation.
In flow-based diffusion models, the forward process is a deterministic flow along a time-dependent vector field, and the backward process is also a deterministic flow along the same vector field, but going backwards. Both processes are solutions to ODEs. If the vector field is well-behaved, the ODE will also be well-behaved.
Given two distributions 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
, a flow-based model is a time-dependent velocity field 
  
    
      
        
          v
          
            t
          
        
        (
        x
        )
      
    
    {\displaystyle v_{t}(x)}
  
 in 
  
    
      
        [
        0
        ,
        1
        ]
        ×
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle [0,1]\times \mathbb {R} ^{d}}
  
, such that if we start by sampling a point 
  
    
      
        x
        ∼
        
          π
          
            0
          
        
      
    
    {\displaystyle x\sim \pi _{0}}
  
, and let it move according to the velocity field:

  
    
      
        
          
            d
            
              d
              t
            
          
        
        
          ϕ
          
            t
          
        
        (
        x
        )
        =
        
          v
          
            t
          
        
        (
        
          ϕ
          
            t
          
        
        (
        x
        )
        )
        
        t
        ∈
        [
        0
        ,
        1
        ]
        ,
        
        
          starting from 
        
        
          ϕ
          
            0
          
        
        (
        x
        )
        =
        x
      
    
    {\displaystyle {\frac {d}{dt}}\phi _{t}(x)=v_{t}(\phi _{t}(x))\quad t\in [0,1],\quad {\text{starting from }}\phi _{0}(x)=x}
  

we end up with a point 
  
    
      
        
          x
          
            1
          
        
        ∼
        
          π
          
            1
          
        
      
    
    {\displaystyle x_{1}\sim \pi _{1}}
  
. The solution 
  
    
      
        
          ϕ
          
            t
          
        
      
    
    {\displaystyle \phi _{t}}
  
 of the above ODE define a probability path 
  
    
      
        
          p
          
            t
          
        
        =
        [
        
          ϕ
          
            t
          
        
        
          ]
          
            #
          
        
        
          π
          
            0
          
        
      
    
    {\displaystyle p_{t}=[\phi _{t}]_{\#}\pi _{0}}
  
 by the pushforward measure operator. In particular, 
  
    
      
        [
        
          ϕ
          
            1
          
        
        
          ]
          
            #
          
        
        
          π
          
            0
          
        
        =
        
          π
          
            1
          
        
      
    
    {\displaystyle [\phi _{1}]_{\#}\pi _{0}=\pi _{1}}
  
.
The probability path and the velocity field also satisfy the continuity equation, in the sense of probability distribution:

  
    
      
        
          ∂
          
            t
          
        
        
          p
          
            t
          
        
        +
        ∇
        ⋅
        (
        
          v
          
            t
          
        
        
          p
          
            t
          
        
        )
        =
        0
      
    
    {\displaystyle \partial _{t}p_{t}+\nabla \cdot (v_{t}p_{t})=0}
  

To construct a probability path, we start by construct a conditional probability path 
  
    
      
        
          p
          
            t
          
        
        (
        x
        |
        z
        )
      
    
    {\displaystyle p_{t}(x\vert z)}
  
 and the corresponding conditional velocity field 
  
    
      
        
          v
          
            t
          
        
        (
        x
        |
        z
        )
      
    
    {\displaystyle v_{t}(x\vert z)}
  
 on some conditional distribution 
  
    
      
        q
        (
        z
        )
      
    
    {\displaystyle q(z)}
  
. A natural choice is the Gaussian conditional probability path:

  
    
      
        
          p
          
            t
          
        
        (
        x
        |
        z
        )
        =
        
          
            N
          
        
        
          (
          
            
              m
              
                t
              
            
            (
            z
            )
            ,
            
              ζ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle p_{t}(x\vert z)={\mathcal {N}}\left(m_{t}(z),\zeta _{t}^{2}I\right)}
  

The conditional velocity field which corresponds to the geodesic path between conditional Gaussian path is 

  
    
      
        
          v
          
            t
          
        
        (
        x
        |
        z
        )
        =
        
          
            
              ζ
              
                t
              
              ′
            
            
              ζ
              
                t
              
            
          
        
        (
        x
        −
        
          m
          
            t
          
        
        (
        z
        )
        )
        +
        
          m
          
            t
          
          ′
        
        (
        z
        )
      
    
    {\displaystyle v_{t}(x\vert z)={\frac {\zeta _{t}'}{\zeta _{t}}}(x-m_{t}(z))+m_{t}'(z)}
  

The probability path and velocity field are then computed by marginalizing

  
    
      
        
          p
          
            t
          
        
        (
        x
        )
        =
        ∫
        
          p
          
            t
          
        
        (
        x
        |
        z
        )
        q
        (
        z
        )
        d
        z
        
        
           and 
        
        
        
          v
          
            t
          
        
        (
        x
        )
        =
        
          
            E
          
          
            q
            (
            z
            )
          
        
        
          [
          
            
              
                
                  v
                  
                    t
                  
                
                (
                x
                |
                z
                )
                
                  p
                  
                    t
                  
                
                (
                x
                |
                z
                )
              
              
                
                  p
                  
                    t
                  
                
                (
                x
                )
              
            
          
          ]
        
      
    
    {\displaystyle p_{t}(x)=\int p_{t}(x\vert z)q(z)dz\qquad {\text{ and }}\qquad v_{t}(x)=\mathbb {E} _{q(z)}\left[{\frac {v_{t}(x\vert z)p_{t}(x\vert z)}{p_{t}(x)}}\right]}
  


=== Optimal transport flow ===
The idea of optimal transport flow  is to construct a probability path minimizing the Wasserstein metric. The distribution on which we condition is an approximation of the optimal transport plan between 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
: 
  
    
      
        z
        =
        (
        
          x
          
            0
          
        
        ,
        
          x
          
            1
          
        
        )
      
    
    {\displaystyle z=(x_{0},x_{1})}
  
 and 
  
    
      
        q
        (
        z
        )
        =
        Γ
        (
        
          π
          
            0
          
        
        ,
        
          π
          
            1
          
        
        )
      
    
    {\displaystyle q(z)=\Gamma (\pi _{0},\pi _{1})}
  
, where 
  
    
      
        Γ
      
    
    {\displaystyle \Gamma }
  
 is the optimal transport plan, which can be approximated by mini-batch optimal transport. If the batch size is not large, then the transport it computes can be very far from the true optimal transport.


=== Rectified flow ===
The idea of rectified flow is to learn a flow model such that the velocity is nearly constant along each flow path. This is beneficial, because we can integrate along such a vector field with very few steps. For example, if an ODE 
  
    
      
        
          
            
              
                ϕ
                
                  t
                
              
              ˙
            
          
        
        (
        x
        )
        =
        
          v
          
            t
          
        
        (
        
          ϕ
          
            t
          
        
        (
        x
        )
        )
      
    
    {\displaystyle {\dot {\phi _{t}}}(x)=v_{t}(\phi _{t}(x))}
  
 follows perfectly straight paths, it simplifies to 
  
    
      
        
          ϕ
          
            t
          
        
        (
        x
        )
        =
        
          x
          
            0
          
        
        +
        t
        ⋅
        
          v
          
            0
          
        
        (
        
          x
          
            0
          
        
        )
      
    
    {\displaystyle \phi _{t}(x)=x_{0}+t\cdot v_{0}(x_{0})}
  
, allowing for exact solutions in one step. In practice, we cannot reach such perfection, but when the flow field is nearly so, we can take a few large steps instead of many little steps.  

The general idea is to start with two distributions 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
, then construct a flow field 
  
    
      
        
          ϕ
          
            0
          
        
        =
        {
        
          ϕ
          
            t
          
        
        :
        t
        ∈
        [
        0
        ,
        1
        ]
        }
      
    
    {\displaystyle \phi ^{0}=\{\phi _{t}:t\in [0,1]\}}
  
 from it, then repeatedly apply a "reflow" operation to obtain successive flow fields 
  
    
      
        
          ϕ
          
            1
          
        
        ,
        
          ϕ
          
            2
          
        
        ,
        …
      
    
    {\displaystyle \phi ^{1},\phi ^{2},\dots }
  
, each straighter than the previous one. When the flow field is straight enough for the application, we stop.
Generally, for any time-differentiable process 
  
    
      
        
          ϕ
          
            t
          
        
      
    
    {\displaystyle \phi _{t}}
  
, 
  
    
      
        
          v
          
            t
          
        
      
    
    {\displaystyle v_{t}}
  
 can be estimated by solving:

  
    
      
        
          min
          
            θ
          
        
        
          ∫
          
            0
          
          
            1
          
        
        
          
            E
          
          
            x
            ∼
            
              p
              
                t
              
            
          
        
        
          [
          
            ‖
            
              
                v
                
                  t
                
              
              (
              x
              ,
              θ
              )
              −
              
                v
                
                  t
                
              
              (
              x
              )
            
            
              ‖
              
                2
              
            
          
          ]
        
        
        
          d
        
        t
        .
      
    
    {\displaystyle \min _{\theta }\int _{0}^{1}\mathbb {E} _{x\sim p_{t}}\left[\lVert {v_{t}(x,\theta )-v_{t}(x)}\rVert ^{2}\right]\,\mathrm {d} t.}
  

In rectified flow, by injecting strong priors that intermediate trajectories are straight, it can achieve both theoretical relevance for optimal transport  and computational efficiency, as ODEs with straight paths can be simulated precisely without time discretization.

Specifically, rectified flow seeks to match an ODE with the marginal distributions of the linear interpolation between points from distributions 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
. Given observations 
  
    
      
        
          x
          
            0
          
        
        ∼
        
          π
          
            0
          
        
      
    
    {\displaystyle x_{0}\sim \pi _{0}}
  
 and 
  
    
      
        
          x
          
            1
          
        
        ∼
        
          π
          
            1
          
        
      
    
    {\displaystyle x_{1}\sim \pi _{1}}
  
, the canonical linear interpolation 
  
    
      
        
          x
          
            t
          
        
        =
        t
        
          x
          
            1
          
        
        +
        (
        1
        −
        t
        )
        
          x
          
            0
          
        
        ,
        t
        ∈
        [
        0
        ,
        1
        ]
      
    
    {\displaystyle x_{t}=tx_{1}+(1-t)x_{0},t\in [0,1]}
  
 yields a trivial case 
  
    
      
        
          
            
              
                x
                ˙
              
            
          
          
            t
          
        
        =
        
          x
          
            1
          
        
        −
        
          x
          
            0
          
        
      
    
    {\displaystyle {\dot {x}}_{t}=x_{1}-x_{0}}
  
, which cannot be causally simulated without 
  
    
      
        
          x
          
            1
          
        
      
    
    {\displaystyle x_{1}}
  
. To address this, 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 is "projected" into a space of causally simulatable ODEs, by minimizing the least squares loss with respect to the direction 
  
    
      
        
          x
          
            1
          
        
        −
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{1}-x_{0}}
  
:

  
    
      
        
          min
          
            θ
          
        
        
          ∫
          
            0
          
          
            1
          
        
        
          
            E
          
          
            
              π
              
                0
              
            
            ,
            
              π
              
                1
              
            
            ,
            
              p
              
                t
              
            
          
        
        
          [
          
            ‖
            
              (
              
                x
                
                  1
                
              
              −
              
                x
                
                  0
                
              
              )
              −
              
                v
                
                  t
                
              
              (
              
                x
                
                  t
                
              
              )
            
            
              ‖
              
                2
              
            
          
          ]
        
        
        
          d
        
        t
        .
      
    
    {\displaystyle \min _{\theta }\int _{0}^{1}\mathbb {E} _{\pi _{0},\pi _{1},p_{t}}\left[\lVert {(x_{1}-x_{0})-v_{t}(x_{t})}\rVert ^{2}\right]\,\mathrm {d} t.}
  

The data pair 
  
    
      
        (
        
          x
          
            0
          
        
        ,
        
          x
          
            1
          
        
        )
      
    
    {\displaystyle (x_{0},x_{1})}
  
 can be any coupling of 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
, typically independent (i.e., 
  
    
      
        (
        
          x
          
            0
          
        
        ,
        
          x
          
            1
          
        
        )
        ∼
        
          π
          
            0
          
        
        ×
        
          π
          
            1
          
        
      
    
    {\displaystyle (x_{0},x_{1})\sim \pi _{0}\times \pi _{1}}
  
) obtained by randomly combining observations from 
  
    
      
        
          π
          
            0
          
        
      
    
    {\displaystyle \pi _{0}}
  
 and 
  
    
      
        
          π
          
            1
          
        
      
    
    {\displaystyle \pi _{1}}
  
. This process ensures that the trajectories closely mirror the density map of 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 trajectories but reroute at intersections to ensure causality.

A distinctive aspect of rectified flow is its capability for "reflow", which straightens the trajectory of ODE paths. Denote the rectified flow 
  
    
      
        
          ϕ
          
            0
          
        
        =
        {
        
          ϕ
          
            t
          
        
        :
        t
        ∈
        [
        0
        ,
        1
        ]
        }
      
    
    {\displaystyle \phi ^{0}=\{\phi _{t}:t\in [0,1]\}}
  
 induced from 
  
    
      
        (
        
          x
          
            0
          
        
        ,
        
          x
          
            1
          
        
        )
      
    
    {\displaystyle (x_{0},x_{1})}
  
 as 
  
    
      
        
          ϕ
          
            0
          
        
        =
        
          
            R
            e
            c
            t
            f
            l
            o
            w
          
        
        (
        (
        
          x
          
            0
          
        
        ,
        
          x
          
            1
          
        
        )
        )
      
    
    {\displaystyle \phi ^{0}={\mathsf {Rectflow}}((x_{0},x_{1}))}
  
. Recursively applying this 
  
    
      
        
          
            R
            e
            c
            t
            f
            l
            o
            w
          
        
        (
        ⋅
        )
      
    
    {\displaystyle {\mathsf {Rectflow}}(\cdot )}
  
 operator generates a series of rectified flows 
  
    
      
        
          ϕ
          
            k
            +
            1
          
        
        =
        
          
            R
            e
            c
            t
            f
            l
            o
            w
          
        
        (
        (
        
          ϕ
          
            0
          
          
            k
          
        
        (
        
          x
          
            0
          
        
        )
        ,
        
          ϕ
          
            1
          
          
            k
          
        
        (
        
          x
          
            1
          
        
        )
        )
        )
      
    
    {\displaystyle \phi ^{k+1}={\mathsf {Rectflow}}((\phi _{0}^{k}(x_{0}),\phi _{1}^{k}(x_{1})))}
  
. This "reflow" process not only reduces transport costs but also straightens the paths of rectified flows, making 
  
    
      
        
          ϕ
          
            k
          
        
      
    
    {\displaystyle \phi ^{k}}
  
 paths straighter with increasing 
  
    
      
        k
      
    
    {\displaystyle k}
  
.
Rectified flow includes a nonlinear extension where linear interpolation 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 is replaced with any time-differentiable curve that connects 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 and 
  
    
      
        
          x
          
            1
          
        
      
    
    {\displaystyle x_{1}}
  
, given by 
  
    
      
        
          x
          
            t
          
        
        =
        
          α
          
            t
          
        
        
          x
          
            1
          
        
        +
        
          β
          
            t
          
        
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{t}=\alpha _{t}x_{1}+\beta _{t}x_{0}}
  
. This framework encompasses DDIM and probability flow ODEs as special cases, with particular choices of 
  
    
      
        
          α
          
            t
          
        
      
    
    {\displaystyle \alpha _{t}}
  
 and 
  
    
      
        
          β
          
            t
          
        
      
    
    {\displaystyle \beta _{t}}
  
. However, in the case where the path of 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 is not straight, the reflow process no longer ensures a reduction in convex transport costs, and also no longer straighten the paths of 
  
    
      
        
          ϕ
          
            t
          
        
      
    
    {\displaystyle \phi _{t}}
  
.


== Choice of architecture ==


=== Diffusion model ===
For generating images by DDPM, we need a neural network that takes a time 
  
    
      
        t
      
    
    {\displaystyle t}
  
 and a noisy image 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
, and predicts a noise 
  
    
      
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            t
          
        
        ,
        t
        )
      
    
    {\displaystyle \epsilon _{\theta }(x_{t},t)}
  
 from it. Since predicting the noise is the same as predicting the denoised image, then subtracting it from 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
, denoising architectures tend to work well. For example, the U-Net, which was found to be good for denoising images, is often used for denoising diffusion models that generate images.
For DDPM, the underlying architecture ("backbone") does not have to be a U-Net. It just has to predict the noise somehow. For example, the diffusion transformer (DiT) uses a Transformer to predict the mean and diagonal covariance of the noise, given the textual conditioning and the partially denoised image. It is the same as standard U-Net-based denoising diffusion model, with a Transformer replacing the U-Net. Mixture of experts-Transformer can also be applied.
DDPM can be used to model general data distributions, not just natural-looking images. For example, Human Motion Diffusion models human motion trajectory by DDPM. Each human motion trajectory is a sequence of poses, represented by either joint rotations or positions. It uses a Transformer network to generate a less noisy trajectory out of a noisy one.


=== Conditioning ===
The base diffusion model can only generate unconditionally from the whole distribution. For example, a diffusion model learned on ImageNet would generate images that look like a random image from ImageNet. To generate images from just one category, one would need to impose the condition, and then sample from the conditional distribution. Whatever condition one wants to impose, one needs to first convert the conditioning into a vector of floating point numbers, then feed it into the underlying diffusion model neural network. However, one has freedom in choosing how to convert the conditioning into a vector.
Stable Diffusion, for example, imposes conditioning in the form of cross-attention mechanism, where the query is an intermediate representation of the image in the U-Net, and both key and value are the conditioning vectors. The conditioning can be selectively applied to only parts of an image, and new kinds of conditionings can be finetuned upon the base model, as used in ControlNet.
As a particularly simple example, consider image inpainting. The conditions are 
  
    
      
        
          
            
              x
              ~
            
          
        
      
    
    {\displaystyle {\tilde {x}}}
  
, the reference image, and 
  
    
      
        m
      
    
    {\displaystyle m}
  
, the inpainting mask. The conditioning is imposed at each step of the backward diffusion process, by first sampling 
  
    
      
        
          
            
              
                x
                ~
              
            
          
          
            t
          
        
        ∼
        N
        
          (
          
            
              
                
                  
                    
                      
                        α
                        ¯
                      
                    
                  
                  
                    t
                  
                
              
            
            
              
                
                  x
                  ~
                
              
            
            ,
            
              σ
              
                t
              
              
                2
              
            
            I
          
          )
        
      
    
    {\displaystyle {\tilde {x}}_{t}\sim N\left({\sqrt {{\bar {\alpha }}_{t}}}{\tilde {x}},\sigma _{t}^{2}I\right)}
  
, a noisy version of 
  
    
      
        
          
            
              x
              ~
            
          
        
      
    
    {\displaystyle {\tilde {x}}}
  
, then replacing 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  
 with 
  
    
      
        (
        1
        −
        m
        )
        ⊙
        
          x
          
            t
          
        
        +
        m
        ⊙
        
          
            
              
                x
                ~
              
            
          
          
            t
          
        
      
    
    {\displaystyle (1-m)\odot x_{t}+m\odot {\tilde {x}}_{t}}
  
, where 
  
    
      
        ⊙
      
    
    {\displaystyle \odot }
  
 means elementwise multiplication. Another application of cross-attention mechanism is prompt-to-prompt image editing.
Conditioning is not limited to just generating images from a specific category, or according to a specific caption (as in text-to-image). For example, demonstrated generating human motion, conditioned on an audio clip of human walking (allowing syncing motion to a soundtrack), or video of human running, or a text description of human motion, etc. For how conditional diffusion models are mathematically formulated, see a methodological summary in.


=== Upscaling ===
As generating an image takes a long time, one can try to generate a small image by a base diffusion model, then upscale it by other models. Upscaling can be done by GAN, Transformer, or signal processing methods like Lanczos resampling.
Diffusion models themselves can be used to perform upscaling. Cascading diffusion model stacks multiple diffusion models one after another, in the style of Progressive GAN. The lowest level is a standard diffusion model that generate 32x32 image, then the image would be upscaled by a diffusion model specifically trained for upscaling, and the process repeats.
In more detail, the diffusion upscaler is trained as follows:

Sample 
  
    
      
        (
        
          x
          
            0
          
        
        ,
        
          z
          
            0
          
        
        ,
        c
        )
      
    
    {\displaystyle (x_{0},z_{0},c)}
  
, where 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 is the high-resolution image, 
  
    
      
        
          z
          
            0
          
        
      
    
    {\displaystyle z_{0}}
  
 is the same image but scaled down to a low-resolution, and 
  
    
      
        c
      
    
    {\displaystyle c}
  
 is the conditioning, which can be the caption of the image, the class of the image, etc.
Sample two white noises 
  
    
      
        
          ϵ
          
            x
          
        
        ,
        
          ϵ
          
            z
          
        
      
    
    {\displaystyle \epsilon _{x},\epsilon _{z}}
  
, two time-steps 
  
    
      
        
          t
          
            x
          
        
        ,
        
          t
          
            z
          
        
      
    
    {\displaystyle t_{x},t_{z}}
  
. Compute the noisy versions of the high-resolution and low-resolution images: 
  
    
      
        
          
            {
            
              
                
                  
                    x
                    
                      
                        t
                        
                          x
                        
                      
                    
                  
                
                
                  =
                  
                    
                      
                        
                          
                            
                              α
                              ¯
                            
                          
                        
                        
                          
                            t
                            
                              x
                            
                          
                        
                      
                    
                  
                  
                    x
                    
                      0
                    
                  
                  +
                  
                    σ
                    
                      
                        t
                        
                          x
                        
                      
                    
                  
                  
                    ϵ
                    
                      x
                    
                  
                
              
              
                
                  
                    z
                    
                      
                        t
                        
                          z
                        
                      
                    
                  
                
                
                  =
                  
                    
                      
                        
                          
                            
                              α
                              ¯
                            
                          
                        
                        
                          
                            t
                            
                              z
                            
                          
                        
                      
                    
                  
                  
                    z
                    
                      0
                    
                  
                  +
                  
                    σ
                    
                      
                        t
                        
                          z
                        
                      
                    
                  
                  
                    ϵ
                    
                      z
                    
                  
                
              
            
            
          
        
      
    
    {\displaystyle {\begin{cases}x_{t_{x}}&={\sqrt {{\bar {\alpha }}_{t_{x}}}}x_{0}+\sigma _{t_{x}}\epsilon _{x}\\z_{t_{z}}&={\sqrt {{\bar {\alpha }}_{t_{z}}}}z_{0}+\sigma _{t_{z}}\epsilon _{z}\end{cases}}}
  
.
Train the denoising network to predict 
  
    
      
        
          ϵ
          
            x
          
        
      
    
    {\displaystyle \epsilon _{x}}
  
 given 
  
    
      
        
          x
          
            
              t
              
                x
              
            
          
        
        ,
        
          z
          
            
              t
              
                z
              
            
          
        
        ,
        
          t
          
            x
          
        
        ,
        
          t
          
            z
          
        
        ,
        c
      
    
    {\displaystyle x_{t_{x}},z_{t_{z}},t_{x},t_{z},c}
  
. That is, apply gradient descent on 
  
    
      
        θ
      
    
    {\displaystyle \theta }
  
 on the L2 loss 
  
    
      
        ‖
        
          ϵ
          
            θ
          
        
        (
        
          x
          
            
              t
              
                x
              
            
          
        
        ,
        
          z
          
            
              t
              
                z
              
            
          
        
        ,
        
          t
          
            x
          
        
        ,
        
          t
          
            z
          
        
        ,
        c
        )
        −
        
          ϵ
          
            x
          
        
        
          ‖
          
            2
          
          
            2
          
        
      
    
    {\displaystyle \|\epsilon _{\theta }(x_{t_{x}},z_{t_{z}},t_{x},t_{z},c)-\epsilon _{x}\|_{2}^{2}}
  
.


== Examples ==
This section collects some notable diffusion models, and briefly describes their architecture.


=== OpenAI ===

The DALL-E series by OpenAI are text-conditional diffusion models of images.
The first version of DALL-E (2021) is not actually a diffusion model. Instead, it uses a Transformer architecture that autoregressively generates a sequence of tokens, which is then converted to an image by the decoder of a discrete VAE. Released with DALL-E was the CLIP classifier, which was used by DALL-E to rank generated images according to how close the image fits the text.
GLIDE (2022-03) is a 3.5-billion diffusion model, and a small version was released publicly. Soon after, DALL-E 2 was released (2022-04). DALL-E 2 is a 3.5-billion cascaded diffusion model that generates images from text by "inverting the CLIP image encoder", the technique which they termed "unCLIP".
The unCLIP method contains 4 models: a CLIP image encoder, a CLIP text encoder, an image decoder, and a "prior" model (which can be a diffusion model, or an autoregressive model). During training, the prior model is trained to convert CLIP image encodings to CLIP text encodings. The image decoder is trained to convert CLIP image encodings back to images. During inference, a text is converted by the CLIP text encoder to a vector, then it is converted by the prior model to an image encoding, then it is converted by the image decoder to an image.
Sora (2024-02) is a diffusion Transformer model (DiT).


=== Stability AI ===

Stable Diffusion (2022-08), released by Stability AI, consists of a denoising latent diffusion model (860 million parameters), a VAE, and a text encoder. The denoising network is a U-Net, with cross-attention blocks to allow for conditional image generation.
Stable Diffusion 3 (2024-03) changed the latent diffusion model from the UNet to a Transformer model, and so it is a DiT. It uses rectified flow.
Stable Video 4D (2024-07) is a latent diffusion model for videos of 3D objects.


=== Google ===
Imagen (2022) uses a T5-XXL language model to encode the input text into an embedding vector. It is a cascaded diffusion model with three sub-models. The first step denoises a white noise to a 64×64 image, conditional on the embedding vector of the text. This model has 2B parameters. The second step upscales the image by 64×64→256×256, conditional on embedding. This model has 650M parameters. The third step is similar, upscaling by 256×256→1024×1024. This model has 400M parameters. The three denoising networks are all U-Nets.
Muse (2023-01) is not a diffusion model, but an encoder-only Transformer that is trained to predict masked image tokens from unmasked image tokens.
Imagen 2 (2023-12) is also diffusion-based. It can generate images based on a prompt that mixes images and text. No further information available. Imagen 3 (2024-05) is too. No further information available.
Veo (2024) generates videos by latent diffusion. The diffusion is conditioned on a vector that encodes both a text prompt and an image prompt.


=== Meta ===
Make-A-Video (2022) is a text-to-video diffusion model.
CM3leon (2023) is not a diffusion model, but an autoregressive causally masked Transformer, with mostly the same architecture as LLaMa-2.

Transfusion (2024) is a Transformer that combines autoregressive text generation and denoising diffusion. Specifically, it generates text autoregressively (with causal masking), and generates images by denoising multiple times over image tokens (with all-to-all attention).
Movie Gen (2024) is a series of Diffusion Transformers operating on latent space and by flow matching.


== See also ==
Diffusion process
Markov chain
Variational inference
Variational autoencoder


== Further reading ==
Review papers
Yang, Ling (2024-09-06), YangLing0818/Diffusion-Models-Papers-Survey-Taxonomy, retrieved 2024-09-06
Yang, Ling; Zhang, Zhilong; Song, Yang; Hong, Shenda; Xu, Runsheng; Zhao, Yue; Zhang, Wentao; Cui, Bin; Yang, Ming-Hsuan (2023-11-09). "Diffusion Models: A Comprehensive Survey of Methods and Applications". ACM Comput. Surv. 56 (4): 105:1–105:39. arXiv:2209.00796. doi:10.1145/3626235. ISSN 0360-0300.
Austin, Jacob; Johnson, Daniel D.; Ho, Jonathan; Tarlow, Daniel; Rianne van den Berg (2021). "Structured Denoising Diffusion Models in Discrete State-Spaces". arXiv:2107.03006 [cs.LG].
Croitoru, Florinel-Alin; Hondru, Vlad; Ionescu, Radu Tudor; Shah, Mubarak (2023-09-01). "Diffusion Models in Vision: A Survey". IEEE Transactions on Pattern Analysis and Machine Intelligence. 45 (9): 10850–10869. arXiv:2209.04747. Bibcode:2023ITPAM..4510850C. doi:10.1109/TPAMI.2023.3261988. ISSN 0162-8828. PMID 37030794.
Mathematical details omitted in the article.
"Power of Diffusion Models". AstraBlog. 2022-09-25. Retrieved 2023-09-25.
Luo, Calvin (2022-08-25). "Understanding Diffusion Models: A Unified Perspective". arXiv:2208.11970 [cs.LG].
Weng, Lilian (2021-07-11). "What are Diffusion Models?". lilianweng.github.io. Retrieved 2023-09-25.
Tutorials
Nakkiran, Preetum; Bradley, Arwen; Zhou, Hattie; Advani, Madhu (2024). "Step-by-Step Diffusion: An Elementary Tutorial". arXiv:2406.08929 [cs.LG].
"Guidance: a cheat code for diffusion models". 26 May 2022. Overview of classifier guidance and classifier-free guidance, light on mathematical details.
Catherine Higham, Desmond J. Higham, and Peter Grindrod: "Diffusion Models for Generative Artificial Intelligence: An Introduction for Applied Mathematicians", SIAM Review, Vol.67, No.3 (2025).


== References ==