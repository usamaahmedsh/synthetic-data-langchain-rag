Prompt engineering is the process of structuring or crafting an instruction in order to produce better outputs from a generative artificial intelligence (AI) model. It typically involves designing clear queries, adding relevant context, and refining wording to guide the model toward more accurate, useful, and consistent responses.
A prompt is natural language text describing the task that an AI should perform. A prompt for a text-to-text language model can be a query, a command, or a longer statement including context, instructions, and conversation history. Prompt engineering may involve phrasing a query, specifying a style, choice of words and grammar, providing relevant context, or describing a character for the AI to mimic.
When communicating with a text-to-image or a text-to-audio model, a typical prompt is a description of a desired output such as "a high-quality photo of an astronaut riding a horse" or "Lo-fi slow BPM electro chill with organic samples". Prompting a text-to-image model may involve adding, removing, or emphasizing words to achieve a desired subject, style, layout, lighting, and aesthetic.


== History ==
In 2018, researchers first proposed that all previously separate tasks in natural language processing (NLP) could be cast as a question-answering problem over a context. In addition, they trained a first single, joint, multi-task model that would answer any task-related question like "What is the sentiment" or "Translate this sentence to German" or "Who is the president?"
The AI boom saw an increase in the amount of "prompting technique" to get the model to output the desired outcome and avoid nonsensical output, a process characterized by trial-and-error. After the release of ChatGPT in 2022, prompt engineering was soon seen as an important business skill, albeit one with an uncertain economic future.
A repository for prompts reported that over 2,000 public prompts for around 170 datasets were available in February 2022. In 2022, the chain-of-thought prompting technique was proposed by Google researchers. In 2023, several text-to-text and text-to-image prompt databases were made publicly available. The Personalized Image-Prompt (PIP) dataset, a generated image-text dataset that has been categorized by 3,115 users, has also been made available publicly in 2024.


== Text-to-text ==
A comprehensive 2024 survey of the field identified over 50 distinct text-based prompting techniques and around 40 multimodal variants, demonstrating rapid diversification in prompting strategies. The study also documented a controlled vocabulary of 33 terms used across prompting research, highlighting the growing need for standardization.
The survey found that the performance of large language models is highly sensitive to choices such as the ordering of examples, the quality of demonstration labels, and even small variations in phrasing. In some cases, reordering examples in a prompt produced accuracy shifts of more than 40 percent, emphasizing the importance of methodical prompt construction.


=== Chain-of-thought ===

According to Google Research, chain-of-thought (CoT) prompting is a technique that allows large language models (LLMs) to solve a problem as a series of intermediate steps before giving a final answer. In 2022, Google Brain reported that chain-of-thought prompting improves reasoning ability by inducing the model to answer a multi-step problem with steps of reasoning that mimic a train of thought. Chain-of-thought techniques were developed to help LLMs handle multi-step reasoning tasks, such as arithmetic or commonsense reasoning questions.
For example, given the question "Q: The cafeteria had 23 apples. If they used 20 to make lunch and bought 6 more, how many apples do they have?", CoT prompting induced an LLM to answer "A: The cafeteria had 23 apples originally. They used 20 to make lunch. So they had 23 - 20 = 3. They bought 6 more apples, so they have 3 + 6 = 9. The answer is 9." When applied to PaLM, a 540 billion parameter language model, according to Google, CoT prompting significantly aided the model, allowing it to perform comparably with task-specific fine-tuned models on several tasks, achieving state-of-the-art results at the time on the GSM8K mathematical reasoning benchmark. It is possible to fine-tune models on CoT reasoning datasets to enhance this capability further and stimulate better interpretability.
As originally proposed by Google, each CoT prompt is accompanied by a set of input/output examples—called exemplars—to demonstrate the desired model output, making it a few-shot prompting technique. However, according to a later paper from researchers at Google and the University of Tokyo, simply appending the words "Let's think step-by-step" was also effective, which allowed for CoT to be employed as a zero-shot technique.
An example format of few-shot CoT prompting with in-context exemplars:

   Q: {example question 1}
   A: {example answer 1}
   ...
   Q: {example question n}
   A: {example answer n}
   
   Q: {question}
   A: {LLM output}

An example format of zero-shot CoT prompting:

   Q: {question}. Let's think step by step.
   A: {LLM output}


=== In-context learning ===
In-context learning, refers to a model's ability to temporarily learn from prompts. For example, a prompt may include a few examples for a model to learn from, such as asking the model to complete "maison → house, chat → cat, chien →" (the expected response being dog), an approach called few-shot learning.
In-context learning is an emergent ability of large language models. It is an emergent property of model scale, meaning that breaks in downstream scaling laws occur, leading to its efficacy increasing at a different rate in larger models than in smaller models. Unlike training and fine-tuning, which produce lasting changes, in-context learning is temporary. Training models to perform in-context learning can be viewed as a form of meta-learning, or "learning to learn".


=== Self-consistency ===
Self-consistency performs several chain-of-thought rollouts, then selects the most commonly reached conclusion out of all the rollouts.


=== Tree-of-thought ===
Tree-of-thought prompting generalizes chain-of-thought by generating multiple lines of reasoning in parallel, with the ability to backtrack or explore other paths. It can use tree search algorithms like breadth-first, depth-first, or beam.


=== Prompting to estimate model sensitivity ===
Research consistently demonstrates that LLMs are highly sensitive to subtle variations in prompt formatting, structure, and linguistic properties. Some studies have shown up to 76 accuracy points across formatting changes in few-shot settings. Linguistic features significantly influence prompt effectiveness—such as morphology, syntax, and lexico-semantic changes—which meaningfully enhance task performance across a variety of tasks. Clausal syntax, for example, improves consistency and reduces uncertainty in knowledge retrieval. This sensitivity persists even with larger model sizes, additional few-shot examples, or instruction tuning.
To address sensitivity of models and make them more robust, several methods have been proposed. FormatSpread facilitates systematic analysis by evaluating a range of plausible prompt formats, offering a more comprehensive performance interval. Similarly, PromptEval estimates performance distributions across diverse prompts, enabling robust metrics such as performance quantiles and accurate evaluations under constrained budgets.


=== Automatic prompt generation ===
Recent research has explored automated prompt engineering, using optimization algorithms to generate or refine prompts without human intervention. These automated approaches aim to identify effective prompt patterns by analyzing model gradients, reinforcement feedback, or evolutionary processes, reducing the need for manual experimentation.


==== Retrieval-augmented generation ====

Retrieval-augmented generation (RAG) is a technique that enables generative artificial intelligence (Gen AI) models to retrieve and incorporate new information. It modifies interactions with an LLM so that the model responds to user queries with reference to a specified set of documents, using this information to supplement information from its pre-existing training data. This allows LLMs to use domain-specific and/or updated information.
RAG improves large language models by incorporating information retrieval before generating responses. Unlike traditional LLMs that rely on static training data, RAG pulls relevant text from databases, uploaded documents, or web sources. According to Ars Technica, "RAG is a way of improving LLM performance, in essence by blending the LLM process with a web search or other document look-up process to help LLMs stick to the facts." This method helps reduce AI hallucinations, which have led to real-world issues like chatbots inventing policies or lawyers citing nonexistent legal cases. By dynamically retrieving information, RAG enables AI to provide more accurate responses without frequent retraining.


==== Graph retrieval-augmented generation ====

GraphRAG (coined by Microsoft Research) is a technique that extends RAG with the use of a knowledge graph (usually, LLM-generated) to allow the model to connect disparate pieces of information, synthesize insights, and holistically understand summarized semantic concepts over large data collections. It was shown to be effective on datasets like the Violent Incident Information from News Articles (VIINA).
Earlier work showed the effectiveness of using a knowledge graph for question answering using text-to-query generation. These techniques can be combined to search across both unstructured and structured data, providing expanded context, and improved ranking.


==== Using language models to generate prompts ====
LLMs themselves can be used to compose prompts for LLMs. The automatic prompt engineer algorithm uses one LLM to beam search over prompts for another LLM:

There are two LLMs. One is the target LLM, and another is the prompting LLM.
Prompting LLM is presented with example input-output pairs, and asked to generate instructions that could have caused a model following the instructions to generate the outputs, given the inputs.
Each of the generated instructions is used to prompt the target LLM, followed by each of the inputs. The log-probabilities of the outputs are computed and added. This is the score of the instruction.
The highest-scored instructions are given to the prompting LLM for further variations.
Repeat until some stopping criteria is reached, then output the highest-scored instructions.
CoT examples can be generated by LLM themselves. In "auto-CoT", a library of questions are converted to vectors by a model such as BERT. The question vectors are clustered. Questions close to the centroid of each cluster are selected, in order to have a subset of diverse questions. An LLM does zero-shot CoT on each selected question. The question and the corresponding CoT answer are added to a dataset of demonstrations. These diverse demonstrations can then added to prompts for few-shot learning.


==== Automatic prompt optimization ====
Automatic prompt optimization techniques refine prompts for large language models (LLMs) by automatically searching over alternative prompt strings using evaluation datasets and task-specific metrics. MIPRO (Multi-prompt Instruction Proposal Optimizer) optimizes the instructions and few-shot demonstrations of multi-stage language model programs, proposing small changes to module prompts and retaining those that improve a downstream performance metric without access to module-level labels or gradients. GEPA (Genetic-Pareto) is a reflective prompt optimizer for compound AI systems that combines language-model-based analysis of execution traces and textual feedback with a Pareto-based evolutionary search over a population of candidate systems; across four tasks, GEPA reports average gains of about 10% over reinforcement-learning-based Group Relative Policy Optimization and over 10% over the MIPROv2 prompt optimizer, while using up to 35 times fewer rollouts than GRPO. Open-source frameworks such as DSPy and Opik expose these and related optimizers, allowing prompt search to be expressed as part of a programmatic pipeline rather than through manual trial and error.


=== Context engineering ===
Context engineering is an emerging, practitioner-focused term describing the discipline of designing, curating and governing the elements that accompany user prompts. This includes system instructions, retrieved knowledge, tool definitions, conversation summaries, and task metadata to improve reliability, provenance and token efficiency in production LLM systems.
The concept emphasises operational practices such as token budgeting, provenance tags, versioning of context artifacts, observability (logging which context was supplied), and context regression tests to ensure that changes to supplied context do not silently alter system behaviour. A July 2025 survey provides a formal taxonomy of context engineering components (context retrieval/generation, context processing, and context management) and argues for treating the context window as a managed engineering surface rather than only a passive source of retrieved documents.


== Text-to-image ==

In 2022, text-to-image models like DALL-E 2, Stable Diffusion, and Midjourney were released to the public. These models take text prompts as input and use them to generate images.


=== Prompt formats ===
Early text-to-image models typically do not understand negation, grammar and sentence structure in the same way as large language models, and may thus require a different set of prompting techniques. The prompt "a party with no cake" may produce an image including a cake. As an alternative, negative prompts allow a user to indicate, in a separate prompt, which terms should not appear in the resulting image. Techniques such as framing the normal prompt into a sequence-to-sequence language modeling problem can be used to automatically generate an output for the negative prompt.
A text-to-image prompt commonly includes a description of the subject of the art, the desired medium (such as digital painting or photography), style (such as hyperrealistic or pop-art), lighting (such as rim lighting or crepuscular rays), color, and texture. Word order also affects the output of a text-to-image prompt. Words closer to the start of a prompt may be emphasized more heavily.
The Midjourney documentation encourages short, descriptive prompts: instead of "Show me a picture of lots of blooming California poppies, make them bright, vibrant orange, and draw them in an illustrated style with colored pencils", an effective prompt might be "Bright orange California poppies drawn with colored pencils".


=== Artist styles ===
Some text-to-image models are capable of imitating the style of particular artists by name. For example, the phrase in the style of Greg Rutkowski has been used in Stable Diffusion and Midjourney prompts to generate images in the distinctive style of Polish digital artist Greg Rutkowski. Famous artists such as Vincent van Gogh and Salvador Dalí have also been used for styling and testing.


== Non-text prompts ==
Some approaches augment or replace natural language text prompts with non-text input.


=== Textual inversion and embeddings ===
For text-to-image models, textual inversion performs an optimization process to create a new word embedding based on a set of example images. This embedding vector acts as a "pseudo-word" which can be included in a prompt to express the content or style of the examples.


=== Image prompting ===
In 2023, Meta's AI research released Segment Anything, a computer vision model that can perform image segmentation by prompting. As an alternative to text prompts, Segment Anything can accept bounding boxes, segmentation masks, and foreground/background points.


=== Using gradient descent to search for prompts ===
In "prefix-tuning", "prompt tuning", or "soft prompting", floating-point-valued vectors are searched directly by gradient descent to maximize the log-likelihood on outputs.
Formally, let 
  
    
      
        
          E
        
        =
        {
        
          
            e
            
              1
            
          
        
        ,
        …
        ,
        
          
            e
            
              k
            
          
        
        }
      
    
    {\displaystyle \mathbf {E} =\{\mathbf {e_{1}} ,\dots ,\mathbf {e_{k}} \}}
  
 be a set of soft prompt tokens (tunable embeddings), while 
  
    
      
        
          X
        
        =
        {
        
          
            x
            
              1
            
          
        
        ,
        …
        ,
        
          
            x
            
              m
            
          
        
        }
      
    
    {\displaystyle \mathbf {X} =\{\mathbf {x_{1}} ,\dots ,\mathbf {x_{m}} \}}
  
 and 
  
    
      
        
          Y
        
        =
        {
        
          
            y
            
              1
            
          
        
        ,
        …
        ,
        
          
            y
            
              n
            
          
        
        }
      
    
    {\displaystyle \mathbf {Y} =\{\mathbf {y_{1}} ,\dots ,\mathbf {y_{n}} \}}
  
 be the token embeddings of the input and output respectively. During training, the tunable embeddings, input, and output tokens are concatenated into a single sequence 
  
    
      
        
          concat
        
        (
        
          E
        
        ;
        
          X
        
        ;
        
          Y
        
        )
      
    
    {\displaystyle {\text{concat}}(\mathbf {E} ;\mathbf {X} ;\mathbf {Y} )}
  
, and fed to the LLMs. The losses are computed over the 
  
    
      
        
          Y
        
      
    
    {\displaystyle \mathbf {Y} }
  
 tokens; the gradients are backpropagated to prompt-specific parameters: in prefix-tuning, they are parameters associated with the prompt tokens at each layer; in prompt tuning, they are merely the soft tokens added to the vocabulary.
More formally, this is prompt tuning. Let an LLM be written as 
  
    
      
        L
        L
        M
        (
        X
        )
        =
        F
        (
        E
        (
        X
        )
        )
      
    
    {\displaystyle LLM(X)=F(E(X))}
  
, where 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is a sequence of linguistic tokens, 
  
    
      
        E
      
    
    {\displaystyle E}
  
 is the token-to-vector function, and 
  
    
      
        F
      
    
    {\displaystyle F}
  
 is the rest of the model. In prefix-tuning, one provides a set of input-output pairs 
  
    
      
        {
        (
        
          X
          
            i
          
        
        ,
        
          Y
          
            i
          
        
        )
        
          }
          
            i
          
        
      
    
    {\displaystyle \{(X^{i},Y^{i})\}_{i}}
  
, and then use gradient descent to search for 
  
    
      
        arg
        ⁡
        
          max
          
            
              
                Z
                ~
              
            
          
        
        
          ∑
          
            i
          
        
        log
        ⁡
        P
        r
        [
        
          Y
          
            i
          
        
        
          |
        
        
          
            
              Z
              ~
            
          
        
        ∗
        E
        (
        
          X
          
            i
          
        
        )
        ]
      
    
    {\displaystyle \arg \max _{\tilde {Z}}\sum _{i}\log Pr[Y^{i}|{\tilde {Z}}\ast E(X^{i})]}
  
. In words, 
  
    
      
        log
        ⁡
        P
        r
        [
        
          Y
          
            i
          
        
        
          |
        
        
          
            
              Z
              ~
            
          
        
        ∗
        E
        (
        
          X
          
            i
          
        
        )
        ]
      
    
    {\displaystyle \log Pr[Y^{i}|{\tilde {Z}}\ast E(X^{i})]}
  
 is the log-likelihood of outputting 
  
    
      
        
          Y
          
            i
          
        
      
    
    {\displaystyle Y^{i}}
  
, if the model first encodes the input 
  
    
      
        
          X
          
            i
          
        
      
    
    {\displaystyle X^{i}}
  
 into the vector 
  
    
      
        E
        (
        
          X
          
            i
          
        
        )
      
    
    {\displaystyle E(X^{i})}
  
, then prepend the vector with the "prefix vector" 
  
    
      
        
          
            
              Z
              ~
            
          
        
      
    
    {\displaystyle {\tilde {Z}}}
  
, then apply 
  
    
      
        F
      
    
    {\displaystyle F}
  
. For prefix tuning, it is similar, but the "prefix vector" 
  
    
      
        
          
            
              Z
              ~
            
          
        
      
    
    {\displaystyle {\tilde {Z}}}
  
 is pre-appended to the hidden states in every layer of the model.
An earlier result uses the same idea of gradient descent search, but is designed for masked language models like BERT, and searches only over token sequences, rather than numerical vectors. Formally, it searches for 
  
    
      
        arg
        ⁡
        
          max
          
            
              
                X
                ~
              
            
          
        
        
          ∑
          
            i
          
        
        log
        ⁡
        P
        r
        [
        
          Y
          
            i
          
        
        
          |
        
        
          
            
              X
              ~
            
          
        
        ∗
        
          X
          
            i
          
        
        ]
      
    
    {\displaystyle \arg \max _{\tilde {X}}\sum _{i}\log Pr[Y^{i}|{\tilde {X}}\ast X^{i}]}
  
 where 
  
    
      
        
          
            
              X
              ~
            
          
        
      
    
    {\displaystyle {\tilde {X}}}
  
 is ranges over token sequences of a specified length.


== Limitations ==
While the process of writing and refining a prompt for an LLM or generative AI shares some parallels with an iterative engineering design process, such as through discovering 'best principles' to reuse and discovery through reproducible experimentation, the actual learned principles and skills depend heavily on the specific model being learned rather than being generalizable across the entire field of prompt-based generative models. Such patterns are also volatile and exhibit significantly different results from seemingly insignificant prompt changes. According to The Wall Street Journal in 2025, the job of prompt engineer was one of the hottest in 2023, but has become obsolete due to models that better intuit user intent and to company trainings.


== Prompt injection ==

Prompt injection is a cybersecurity exploit in which adversaries craft inputs that appear legitimate but are designed to cause unintended behavior in machine learning models, particularly large language models. This attack takes advantage of the model's inability to distinguish between developer-defined prompts and user inputs, allowing adversaries to bypass safeguards and influence model behaviour. While LLMs are designed to follow trusted instructions, they can be manipulated into carrying out unintended responses through carefully crafted inputs.


== References ==