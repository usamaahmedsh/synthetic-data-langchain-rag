Top-p sampling, also known as nucleus sampling, is a stochastic decoding strategy for generating sequences from autoregressive probabilistic models. It was originally proposed by Ari Holtzman, Yejin Choi and colleagues in 2019 for natural language generation to address the issue of repetitive and nonsensical text generated by other common decoding methods like beam search. The technique has since been applied in other scientific fields, such as protein engineering and geophysics.
In top-p sampling, a probability threshold p is set, and the next item in a sequence is sampled only from the smallest possible set of high-probability candidates whose cumulative probability exceeds p. This method adapts the size of the candidate pool based on the model's certainty, making it more flexible than top-k sampling, which samples from a fixed number of candidates. Due to its effectiveness, top-p sampling is a widely used technique in many large language model applications.


== Technique ==
At each step of the text generation process, a language model calculates a probability distribution over its entire vocabulary for the next token. While simply picking the token with the highest probability (greedy search) or a limited set of high-probability sequences (beam search) is possible, these deterministic methods often produce text that is dull, repetitive, or nonsensical. Top-p sampling introduces randomness to avoid these issues while maintaining quality.
The core idea is to sample from a smaller, more credible set of tokens at each step, called the nucleus. This nucleus contains the most likely next tokens whose combined, or cumulative probability, just exceeds the threshold p. By sampling only from this dynamically-sized group, the model can adapt to different situations. When the model is confident about the next token (e.g., one token has a very high probability), the nucleus will be small. When the model is uncertain (the probabilities are more evenly distributed), the nucleus will be larger, allowing for more diversity.
The process at each step is as follows:

The model calculates the probabilities for all possible next tokens.
The tokens are sorted by their probability in descending order.
The nucleus is formed by selecting tokens from the top of the list until their cumulative probability exceeds the predefined threshold, p.
The probabilities of tokens within this nucleus are then rescaled so that they sum to 1. All tokens outside the nucleus are discarded (given a probability of 0).
The final next token is randomly sampled from this new, smaller distribution.
Formally, the nucleus, 
  
    
      
        
          V
          
            (
            p
            )
          
        
        ⊆
        V
      
    
    {\displaystyle V^{(p)}\subseteq V}
  
, is defined as the largest set of tokens satisfying:

  
    
      
        
          ∑
          
            x
            ∈
            
              V
              
                (
                p
                )
              
            
          
        
        P
        (
        x
        
          |
        
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            t
            −
            1
          
        
        )
        ≥
        p
      
    
    {\displaystyle \sum _{x\in V^{(p)}}P(x|x_{1},\dots ,x_{t-1})\geq p}
  

In this formula, 
  
    
      
        P
        (
        x
        
          |
        
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            t
            −
            1
          
        
        )
      
    
    {\displaystyle P(x|x_{1},\dots ,x_{t-1})}
  
 represents the probability of a token 
  
    
      
        x
      
    
    {\displaystyle x}
  
 given the preceding tokens 
  
    
      
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            t
            −
            1
          
        
      
    
    {\displaystyle x_{1},\dots ,x_{t-1}}
  
.


=== Example ===
Imagine at a certain step, a language model has a vocabulary of five words: `[the, a, cat, dog, eats]` and produces the following probabilities:

the: 0.5
a: 0.2
cat: 0.1
dog: 0.1
eats: 0.1
If we set 
  
    
      
        p
        =
        0.8
      
    
    {\displaystyle p=0.8}
  
:

The tokens are sorted by probability: [the, a, cat, dog, eats].
The cumulative probability is calculated:
the: 0.5
the + a: 0.5 + 0.2 = 0.7
the + a + cat: 0.7 + 0.1 = 0.8
The nucleus is the smallest set with cumulative probability ≥ 0.8, which is 
  
    
      
        
          V
          
            (
            0.8
            )
          
        
        =
        {
        
          the, a, cat
        
        }
      
    
    {\displaystyle V^{(0.8)}=\{{\text{the, a, cat}}\}}
  
.
The probabilities for this set are rescaled to sum to 1:
P(the) = 0.5 / 0.8 = 0.625
P(a) = 0.2 / 0.8 = 0.25
P(cat) = 0.1 / 0.8 = 0.125
The next token is then sampled from this new distribution, meaning dog and eats have a 0% chance of being chosen.


=== Top-k sampling ===
Top-k sampling is a similar technique where the pool of candidate tokens is restricted to the 
  
    
      
        k
      
    
    {\displaystyle k}
  
 most likely tokens. The main advantage of top-p is its adaptability. When the model is very certain about the next token (a peaked distribution), the nucleus 
  
    
      
        
          V
          
            (
            p
            )
          
        
      
    
    {\displaystyle V^{(p)}}
  
 can be very small. When the model is uncertain (a flat distribution), the nucleus can be much larger, allowing for more diversity. In contrast, top-k always samples from a fixed number of tokens, which may be too restrictive or too broad depending on the context.


== Applications ==
While top-p sampling is most famously used as a decoding strategy for large language models, the technique has also been adapted for use in other scientific domains that involve generating or analyzing sequential data from probabilistic models.


=== Natural language generation ===
In its original domain of natural language generation, top-p sampling is valued for its ability to produce more diverse and coherent text compared to deterministic methods. It has been shown to be beneficial in tasks like automatic question generation, where sample diversity is important for creating effective training data for question answering models.


=== Drug and protein design ===
Top-p sampling is used in computational biology to generate novel molecular and protein sequences from specialized language models. In de novo drug design, chemical language models trained on molecular structures use nucleus sampling to generate focused libraries of new, valid drug candidates. By combining this generation with a predictive model for bioactivity, researchers have identified novel, potent kinase inhibitors. Similarly, in protein engineering, the technique is used to sample protein language models to explore the vast space of possible amino acid sequences to find novel, functional candidates for use in therapeutics or new materials.


=== Geophysics ===
The technique has also been applied in geophysics for denoising audio magnetotelluric (AMT) data. In one method, nucleus sampling is integrated into an attention mechanism to help identify and remove complex anthropogenic noise from geophysical signals. This improves the accuracy of AMT in interpreting the Earth's subsurface resistivity structure, which is critical for applications like mineral exploration.


== Limitations and alternatives ==
While top-p and top-k sampling address many of the issues found in deterministic methods like beam search, they are not without shortcomings. Research has shown that these stochastic methods can produce text with undesirable repetitions and may not fully capture the statistical properties of human language.
A range of alternative sampling strategies have been proposed to address these limitations.

Factual-nucleus sampling was proposed to counter the tendency for the "uniform randomness" applied to the nucleus to harm the factuality of the generated text. It dynamically adapts the level of randomness to improve factual accuracy while maintaining text quality.
Locally typical sampling frames text generation in an information-theoretic light. Instead of selecting only the highest-probability tokens, it samples from a set of tokens that are "locally typical" in an information-theoretic sense, which has been shown to reduce repetition and improve quality.
Priority sampling is a deterministic alternative designed to address the issue of repeated or incoherent samples. It produces a set of unique samples ordered by the model's confidence and has been shown to outperform nucleus sampling in some compiler optimization tasks.


== See also ==
Beam search


== References ==