In mathematics, statistics, finance, and computer science, particularly in machine learning and inverse problems, regularization is a process that converts the answer to a problem to a simpler one. It is often used in solving ill-posed problems or to prevent overfitting.
Although regularization procedures can be divided in many ways, the following delineation is particularly helpful:

Explicit regularization is regularization whenever one explicitly adds a term to the optimization problem.  These terms could be priors, penalties, or constraints. Explicit regularization is commonly employed with ill-posed optimization problems. The regularization term, or penalty, imposes a cost on the optimization function to make the optimal solution unique.
Implicit regularization is all other forms of regularization.  This includes, for example, early stopping, using a robust loss function, and discarding outliers. Implicit regularization is essentially ubiquitous in modern machine learning approaches, including stochastic gradient descent for training deep neural networks, and ensemble methods (such as random forests and gradient boosted trees).
In explicit regularization, independent of the problem or model, there is always a data term, that corresponds to a likelihood of the measurement, and a regularization term that corresponds to a prior. By combining both using Bayesian statistics, one can compute a posterior, that includes both information sources and therefore stabilizes the estimation process. By trading off both objectives, one chooses to be more aligned to the data or to enforce regularization (to prevent overfitting). There is a whole research branch dealing with all possible regularizations. In practice, one usually tries a specific regularization and then figures out the probability density that corresponds to that regularization to justify the choice. It can also be physically motivated by common sense or intuition.
In machine learning, the data term corresponds to the training data and the regularization is either the choice of the model or modifications to the algorithm. It is always intended to reduce the generalization error, i.e. the error score with the trained model on the evaluation set (testing data) and not the training data.
One of the earliest uses of regularization is Tikhonov regularization (ridge regression), related to the method of least squares.


== Regularization in machine learning ==
In machine learning, a key challenge is enabling models to accurately predict outcomes on unseen data, not just on familiar training data. Regularization is crucial for addressing overfitting—where a model memorizes training data details but cannot generalize to new data. The goal of regularization is to encourage models to learn the broader patterns within the data rather than memorizing it. Techniques like early stopping, L1 and L2 regularization, and dropout are designed to prevent overfitting and underfitting, thereby enhancing the model's ability to adapt to and perform well with new data, thus improving model generalization.


=== Early stopping ===
Stops training when validation performance deteriorates, preventing overfitting by halting before the model memorizes training data.


=== L1 and L2 regularization ===
Adds penalty terms to the cost function to discourage complex models:

L1 regularization (also called LASSO) leads to sparse models by adding a penalty based on the absolute value of coefficients.
L2 regularization (also called ridge regression) encourages smaller, more evenly distributed weights by adding a penalty based on the square of the coefficients.


=== Dropout ===
In the context of neural networks, the Dropout technique repeatedly ignores random subsets of neurons during training, which simulates the training of multiple neural network architectures at once to improve generalization.


== Classification ==
Empirical learning of classifiers (from a finite data set) is always an underdetermined problem, because it attempts to infer a function of any 
  
    
      
        x
      
    
    {\displaystyle x}
  
 given only examples 
  
    
      
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        …
        ,
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{1},x_{2},\dots ,x_{n}}
  
.
A regularization term (or regularizer) 
  
    
      
        R
        (
        f
        )
      
    
    {\displaystyle R(f)}
  
 is added to a loss function:

  
    
      
        
          min
          
            f
          
        
        
          ∑
          
            i
            =
            1
          
          
            n
          
        
        V
        (
        f
        (
        
          x
          
            i
          
        
        )
        ,
        
          y
          
            i
          
        
        )
        +
        λ
        R
        (
        f
        )
      
    
    {\displaystyle \min _{f}\sum _{i=1}^{n}V(f(x_{i}),y_{i})+\lambda R(f)}
  

where 
  
    
      
        V
      
    
    {\displaystyle V}
  
 is an underlying loss function that describes the cost of predicting 
  
    
      
        f
        (
        x
        )
      
    
    {\displaystyle f(x)}
  
 when the label is 
  
    
      
        y
      
    
    {\displaystyle y}
  
, such as the square loss or hinge loss; and 
  
    
      
        λ
      
    
    {\displaystyle \lambda }
  
 is a parameter which controls the importance of the regularization term. 
  
    
      
        R
        (
        f
        )
      
    
    {\displaystyle R(f)}
  
 is typically chosen to impose a penalty on the complexity of 
  
    
      
        f
      
    
    {\displaystyle f}
  
. Concrete notions of complexity used include restrictions for smoothness and bounds on the vector space norm.
A theoretical justification for regularization is that it attempts to impose Occam's razor on the solution (as depicted in the figure above, where the green function, the simpler one, may be preferred). From a Bayesian point of view, many regularization techniques correspond to imposing certain prior distributions on model parameters.
Regularization can serve multiple purposes, including learning simpler models, inducing models to be sparse and introducing group structure into the learning problem.
The same idea arose in many fields of science. A simple form of regularization applied to integral equations (Tikhonov regularization)  is essentially a trade-off between fitting the data and reducing a norm of the solution. More recently, non-linear regularization methods, including total variation regularization, have become popular.


=== Generalization ===

Regularization can be motivated as a technique to improve the generalizability of a learned model.
The goal of this learning problem is to find a function that fits or predicts the outcome (label) that minimizes the expected error over all possible inputs and labels. The expected error of a function 
  
    
      
        
          f
          
            n
          
        
      
    
    {\displaystyle f_{n}}
  
 is:

  
    
      
        I
        [
        
          f
          
            n
          
        
        ]
        =
        
          ∫
          
            X
            ×
            Y
          
        
        V
        (
        
          f
          
            n
          
        
        (
        x
        )
        ,
        y
        )
        ρ
        (
        x
        ,
        y
        )
        
        d
        x
        
        d
        y
      
    
    {\displaystyle I[f_{n}]=\int _{X\times Y}V(f_{n}(x),y)\rho (x,y)\,dx\,dy}
  

where 
  
    
      
        X
      
    
    {\displaystyle X}
  
 and 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
 are the domains of input data 
  
    
      
        x
      
    
    {\displaystyle x}
  
 and their labels 
  
    
      
        y
      
    
    {\displaystyle y}
  
 respectively.
Typically in learning problems, only a subset of input data and labels are available, measured with some noise. Therefore, the expected error is unmeasurable, and the best surrogate available is the empirical error over the 
  
    
      
        N
      
    
    {\displaystyle N}
  
 available samples:

  
    
      
        
          I
          
            S
          
        
        [
        
          f
          
            n
          
        
        ]
        =
        
          
            1
            n
          
        
        
          ∑
          
            i
            =
            1
          
          
            N
          
        
        V
        (
        
          f
          
            n
          
        
        (
        
          
            
              
                x
                ^
              
            
          
          
            i
          
        
        )
        ,
        
          
            
              
                y
                ^
              
            
          
          
            i
          
        
        )
      
    
    {\displaystyle I_{S}[f_{n}]={\frac {1}{n}}\sum _{i=1}^{N}V(f_{n}({\hat {x}}_{i}),{\hat {y}}_{i})}
  

Without bounds on the complexity of the function space (formally, the reproducing kernel Hilbert space) available, a model will be learned that incurs zero loss on the surrogate empirical error. If measurements (e.g. of 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
) were made with noise, this model may suffer from overfitting and display poor expected error. Regularization introduces a penalty for exploring certain regions of the function space used to build the model, which can improve generalization.


== Tikhonov regularization (ridge regression) ==

These techniques are named for Andrey Nikolayevich Tikhonov, who applied regularization to integral equations and made important contributions in many other areas.
When learning a linear function 
  
    
      
        f
      
    
    {\displaystyle f}
  
, characterized by an unknown vector 
  
    
      
        w
      
    
    {\displaystyle w}
  
 such that 
  
    
      
        f
        (
        x
        )
        =
        w
        ⋅
        x
      
    
    {\displaystyle f(x)=w\cdot x}
  
, one can add the 
  
    
      
        
          L
          
            2
          
        
      
    
    {\displaystyle L_{2}}
  
-norm of the vector 
  
    
      
        w
      
    
    {\displaystyle w}
  
 to the loss expression in order to prefer solutions with smaller norms. Tikhonov regularization is one of the most common forms. It is also known as ridge regression. It is expressed as:

  
    
      
        
          min
          
            w
          
        
        
          ∑
          
            i
            =
            1
          
          
            n
          
        
        V
        (
        
          
            
              
                x
                ^
              
            
          
          
            i
          
        
        ⋅
        w
        ,
        
          
            
              
                y
                ^
              
            
          
          
            i
          
        
        )
        +
        λ
        
          
            ‖
            w
            ‖
          
          
            2
          
          
            2
          
        
        ,
      
    
    {\displaystyle \min _{w}\sum _{i=1}^{n}V({\hat {x}}_{i}\cdot w,{\hat {y}}_{i})+\lambda \left\|w\right\|_{2}^{2},}
  

where 
  
    
      
        (
        
          
            
              
                x
                ^
              
            
          
          
            i
          
        
        ,
        
          
            
              
                y
                ^
              
            
          
          
            i
          
        
        )
        ,
        
        1
        ≤
        i
        ≤
        n
        ,
      
    
    {\displaystyle ({\hat {x}}_{i},{\hat {y}}_{i}),\,1\leq i\leq n,}
  
 would represent samples used for training.
In the case of a general function, the norm of the function in its reproducing kernel Hilbert space is:

  
    
      
        
          min
          
            f
          
        
        
          ∑
          
            i
            =
            1
          
          
            n
          
        
        V
        (
        f
        (
        
          
            
              
                x
                ^
              
            
          
          
            i
          
        
        )
        ,
        
          
            
              
                y
                ^
              
            
          
          
            i
          
        
        )
        +
        λ
        
          
            ‖
            f
            ‖
          
          
            
              H
            
          
          
            2
          
        
      
    
    {\displaystyle \min _{f}\sum _{i=1}^{n}V(f({\hat {x}}_{i}),{\hat {y}}_{i})+\lambda \left\|f\right\|_{\mathcal {H}}^{2}}
  

As the 
  
    
      
        
          L
          
            2
          
        
      
    
    {\displaystyle L_{2}}
  
 norm is differentiable, learning can be advanced by gradient descent.


=== Tikhonov-regularized least squares ===
The learning problem with the least squares loss function and Tikhonov regularization can be solved analytically. Written in matrix form, the optimal 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is the one for which the gradient of the loss function with respect to 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is 0.

  
    
      
        
          min
          
            w
          
        
        
          
            1
            n
          
        
        
          
            (
            
              
                
                  
                    X
                    ^
                  
                
              
              w
              −
              Y
            
            )
          
          
            
              T
            
          
        
        
          (
          
            
              
                
                  X
                  ^
                
              
            
            w
            −
            Y
          
          )
        
        +
        λ
        
          
            ‖
            w
            ‖
          
          
            2
          
          
            2
          
        
      
    
    {\displaystyle \min _{w}{\frac {1}{n}}\left({\hat {X}}w-Y\right)^{\mathsf {T}}\left({\hat {X}}w-Y\right)+\lambda \left\|w\right\|_{2}^{2}}
  

  
    
      
        
          ∇
          
            w
          
        
        =
        
          
            2
            n
          
        
        
          
            
              
                X
                ^
              
            
          
          
            
              T
            
          
        
        
          (
          
            
              
                
                  X
                  ^
                
              
            
            w
            −
            Y
          
          )
        
        +
        2
        λ
        w
      
    
    {\displaystyle \nabla _{w}={\frac {2}{n}}{\hat {X}}^{\mathsf {T}}\left({\hat {X}}w-Y\right)+2\lambda w}
  

  
    
      
        0
        =
        
          
            
              
                X
                ^
              
            
          
          
            
              T
            
          
        
        
          (
          
            
              
                
                  X
                  ^
                
              
            
            w
            −
            Y
          
          )
        
        +
        n
        λ
        w
      
    
    {\displaystyle 0={\hat {X}}^{\mathsf {T}}\left({\hat {X}}w-Y\right)+n\lambda w}
  

  
    
      
        w
        =
        
          
            (
            
              
                
                  
                    
                      X
                      ^
                    
                  
                
                
                  
                    T
                  
                
              
              
                
                  
                    X
                    ^
                  
                
              
              +
              λ
              n
              I
            
            )
          
          
            −
            1
          
        
        
          (
          
            
              
                
                  
                    X
                    ^
                  
                
              
              
                
                  T
                
              
            
            Y
          
          )
        
      
    
    {\displaystyle w=\left({\hat {X}}^{\mathsf {T}}{\hat {X}}+\lambda nI\right)^{-1}\left({\hat {X}}^{\mathsf {T}}Y\right)}
  

where the third statement is a first-order condition.
By construction of the optimization problem, other values of 
  
    
      
        w
      
    
    {\displaystyle w}
  
 give larger values for the loss function. This can be verified by examining the second derivative 
  
    
      
        
          ∇
          
            w
            w
          
        
      
    
    {\displaystyle \nabla _{ww}}
  
.
During training, this algorithm takes 
  
    
      
        O
        (
        
          d
          
            3
          
        
        +
        n
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(d^{3}+nd^{2})}
  
 time. The terms correspond to the matrix inversion and calculating 
  
    
      
        
          X
          
            
              T
            
          
        
        X
      
    
    {\displaystyle X^{\mathsf {T}}X}
  
, respectively. Testing takes 
  
    
      
        O
        (
        n
        d
        )
      
    
    {\displaystyle O(nd)}
  
 time.


== Early stopping ==

Early stopping can be viewed as regularization in time. Intuitively, a training procedure such as gradient descent tends to learn more and more complex functions with increasing iterations. By regularizing for time, model complexity can be controlled, improving generalization.
Early stopping is implemented using one data set for training, one statistically independent data set for validation and another for testing. The model is trained until performance on the validation set no longer improves and then applied to the test set.


=== Theoretical motivation in least squares ===
Consider the finite approximation of Neumann series for an invertible matrix A where 
  
    
      
        
          ‖
          
            I
            −
            A
          
          ‖
        
        <
        1
      
    
    {\displaystyle \left\|I-A\right\|<1}
  
:

  
    
      
        
          ∑
          
            i
            =
            0
          
          
            T
            −
            1
          
        
        
          
            (
            
              I
              −
              A
            
            )
          
          
            i
          
        
        ≈
        
          A
          
            −
            1
          
        
      
    
    {\displaystyle \sum _{i=0}^{T-1}\left(I-A\right)^{i}\approx A^{-1}}
  

This can be used to approximate the analytical solution of unregularized least squares, if γ is introduced to ensure the norm is less than one.

  
    
      
        
          w
          
            T
          
        
        =
        
          
            γ
            n
          
        
        
          ∑
          
            i
            =
            0
          
          
            T
            −
            1
          
        
        
          
            (
            
              I
              −
              
                
                  γ
                  n
                
              
              
                
                  
                    
                      X
                      ^
                    
                  
                
                
                  
                    T
                  
                
              
              
                
                  
                    X
                    ^
                  
                
              
            
            )
          
          
            i
          
        
        
          
            
              
                X
                ^
              
            
          
          
            
              T
            
          
        
        
          
            
              Y
              ^
            
          
        
      
    
    {\displaystyle w_{T}={\frac {\gamma }{n}}\sum _{i=0}^{T-1}\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right)^{i}{\hat {X}}^{\mathsf {T}}{\hat {Y}}}
  

The exact solution to the unregularized least squares learning problem minimizes the empirical error, but may fail. By limiting T, the only free parameter in the algorithm above, the problem is regularized for time, which may improve its generalization.
The algorithm above is equivalent to restricting the number of gradient descent iterations for the empirical risk

  
    
      
        
          I
          
            s
          
        
        [
        w
        ]
        =
        
          
            1
            
              2
              n
            
          
        
        
          
            ‖
            
              
                
                  
                    X
                    ^
                  
                
              
              w
              −
              
                
                  
                    Y
                    ^
                  
                
              
            
            ‖
          
          
            
              
                R
              
              
                n
              
            
          
          
            2
          
        
      
    
    {\displaystyle I_{s}[w]={\frac {1}{2n}}\left\|{\hat {X}}w-{\hat {Y}}\right\|_{\mathbb {R} ^{n}}^{2}}
  

with the gradient descent update:

  
    
      
        
          
            
              
                
                  w
                  
                    0
                  
                
              
              
                
                =
                0
              
            
            
              
                
                  w
                  
                    t
                    +
                    1
                  
                
              
              
                
                =
                
                  (
                  
                    I
                    −
                    
                      
                        γ
                        n
                      
                    
                    
                      
                        
                          
                            X
                            ^
                          
                        
                      
                      
                        
                          T
                        
                      
                    
                    
                      
                        
                          X
                          ^
                        
                      
                    
                  
                  )
                
                
                  w
                  
                    t
                  
                
                +
                
                  
                    γ
                    n
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}w_{0}&=0\\[1ex]w_{t+1}&=\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right)w_{t}+{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {Y}}\end{aligned}}}
  

The base case is trivial. The inductive case is proved as follows:

  
    
      
        
          
            
              
                
                  w
                  
                    T
                  
                
              
              
                
                =
                
                  (
                  
                    I
                    −
                    
                      
                        γ
                        n
                      
                    
                    
                      
                        
                          
                            X
                            ^
                          
                        
                      
                      
                        
                          T
                        
                      
                    
                    
                      
                        
                          X
                          ^
                        
                      
                    
                  
                  )
                
                
                  
                    γ
                    n
                  
                
                
                  ∑
                  
                    i
                    =
                    0
                  
                  
                    T
                    −
                    2
                  
                
                
                  
                    (
                    
                      I
                      −
                      
                        
                          γ
                          n
                        
                      
                      
                        
                          
                            
                              X
                              ^
                            
                          
                        
                        
                          
                            T
                          
                        
                      
                      
                        
                          
                            X
                            ^
                          
                        
                      
                    
                    )
                  
                  
                    i
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
                +
                
                  
                    γ
                    n
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
              
            
            
              
              
                
                =
                
                  
                    γ
                    n
                  
                
                
                  ∑
                  
                    i
                    =
                    1
                  
                  
                    T
                    −
                    1
                  
                
                
                  
                    (
                    
                      I
                      −
                      
                        
                          γ
                          n
                        
                      
                      
                        
                          
                            
                              X
                              ^
                            
                          
                        
                        
                          
                            T
                          
                        
                      
                      
                        
                          
                            X
                            ^
                          
                        
                      
                    
                    )
                  
                  
                    i
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
                +
                
                  
                    γ
                    n
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
              
            
            
              
              
                
                =
                
                  
                    γ
                    n
                  
                
                
                  ∑
                  
                    i
                    =
                    0
                  
                  
                    T
                    −
                    1
                  
                
                
                  
                    (
                    
                      I
                      −
                      
                        
                          γ
                          n
                        
                      
                      
                        
                          
                            
                              X
                              ^
                            
                          
                        
                        
                          
                            T
                          
                        
                      
                      
                        
                          
                            X
                            ^
                          
                        
                      
                    
                    )
                  
                  
                    i
                  
                
                
                  
                    
                      
                        X
                        ^
                      
                    
                  
                  
                    
                      T
                    
                  
                
                
                  
                    
                      Y
                      ^
                    
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}w_{T}&=\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right){\frac {\gamma }{n}}\sum _{i=0}^{T-2}\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right)^{i}{\hat {X}}^{\mathsf {T}}{\hat {Y}}+{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {Y}}\\[1ex]&={\frac {\gamma }{n}}\sum _{i=1}^{T-1}\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right)^{i}{\hat {X}}^{\mathsf {T}}{\hat {Y}}+{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {Y}}\\[1ex]&={\frac {\gamma }{n}}\sum _{i=0}^{T-1}\left(I-{\frac {\gamma }{n}}{\hat {X}}^{\mathsf {T}}{\hat {X}}\right)^{i}{\hat {X}}^{\mathsf {T}}{\hat {Y}}\end{aligned}}}
  


== Regularizers for sparsity ==
Assume that a dictionary 
  
    
      
        
          ϕ
          
            j
          
        
      
    
    {\displaystyle \phi _{j}}
  
 with dimension 
  
    
      
        p
      
    
    {\displaystyle p}
  
 is given such that a function in the function space can be expressed as:

  
    
      
        f
        (
        x
        )
        =
        
          ∑
          
            j
            =
            1
          
          
            p
          
        
        
          ϕ
          
            j
          
        
        (
        x
        )
        
          w
          
            j
          
        
      
    
    {\displaystyle f(x)=\sum _{j=1}^{p}\phi _{j}(x)w_{j}}
  

Enforcing a sparsity constraint on 
  
    
      
        w
      
    
    {\displaystyle w}
  
 can lead to simpler and more interpretable models. This is useful in many real-life applications such as computational biology. An example is developing a simple predictive test for a disease in order to minimize the cost of performing medical tests while maximizing predictive power.
A sensible sparsity constraint is the 
  
    
      
        
          L
          
            0
          
        
      
    
    {\displaystyle L_{0}}
  
 norm 
  
    
      
        ‖
        w
        
          ‖
          
            0
          
        
      
    
    {\displaystyle \|w\|_{0}}
  
, defined as the number of non-zero elements in 
  
    
      
        w
      
    
    {\displaystyle w}
  
. Solving a 
  
    
      
        
          L
          
            0
          
        
      
    
    {\displaystyle L_{0}}
  
 regularized learning problem, however, has been demonstrated to be NP-hard.
The 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 norm (see also Norms) can be used to approximate the optimal 
  
    
      
        
          L
          
            0
          
        
      
    
    {\displaystyle L_{0}}
  
 norm via convex relaxation. It can be shown that the 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 norm induces sparsity. In the case of least squares, this problem is known as LASSO in statistics and basis pursuit in signal processing.

  
    
      
        
          min
          
            w
            ∈
            
              
                R
              
              
                p
              
            
          
        
        
          
            1
            n
          
        
        
          
            ‖
            
              
                
                  
                    X
                    ^
                  
                
              
              w
              −
              
                
                  
                    Y
                    ^
                  
                
              
            
            ‖
          
          
            2
          
        
        +
        λ
        
          
            ‖
            w
            ‖
          
          
            1
          
        
      
    
    {\displaystyle \min _{w\in \mathbb {R} ^{p}}{\frac {1}{n}}\left\|{\hat {X}}w-{\hat {Y}}\right\|^{2}+\lambda \left\|w\right\|_{1}}
  

  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 regularization can occasionally produce non-unique solutions. A simple example is provided in the figure when the space of possible solutions lies on a 45 degree line. This can be problematic for certain applications, and is overcome by combining 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 with 
  
    
      
        
          L
          
            2
          
        
      
    
    {\displaystyle L_{2}}
  
 regularization in elastic net regularization, which takes the following form:

  
    
      
        
          min
          
            w
            ∈
            
              
                R
              
              
                p
              
            
          
        
        
          
            1
            n
          
        
        
          
            ‖
            
              
                
                  
                    X
                    ^
                  
                
              
              w
              −
              
                
                  
                    Y
                    ^
                  
                
              
            
            ‖
          
          
            2
          
        
        +
        λ
        
          (
          
            α
            
              
                ‖
                w
                ‖
              
              
                1
              
            
            +
            (
            1
            −
            α
            )
            
              
                ‖
                w
                ‖
              
              
                2
              
              
                2
              
            
          
          )
        
        ,
        α
        ∈
        [
        0
        ,
        1
        ]
      
    
    {\displaystyle \min _{w\in \mathbb {R} ^{p}}{\frac {1}{n}}\left\|{\hat {X}}w-{\hat {Y}}\right\|^{2}+\lambda \left(\alpha \left\|w\right\|_{1}+(1-\alpha )\left\|w\right\|_{2}^{2}\right),\alpha \in [0,1]}
  

Elastic net regularization tends to have a grouping effect, where correlated input features are assigned equal weights.
Elastic net regularization is commonly used in practice and is implemented in many machine learning libraries.


=== Proximal methods ===
While the 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 norm does not result in an NP-hard problem, the 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 norm is convex but is not strictly differentiable due to the kink at x = 0. Subgradient methods which rely on the subderivative can be used to solve 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 regularized learning problems. However, faster convergence can be achieved through proximal methods.
For a problem 
  
    
      
        
          min
          
            w
            ∈
            H
          
        
        F
        (
        w
        )
        +
        R
        (
        w
        )
      
    
    {\displaystyle \min _{w\in H}F(w)+R(w)}
  
 such that 
  
    
      
        F
      
    
    {\displaystyle F}
  
 is convex, continuous, differentiable, with Lipschitz continuous gradient (such as the least squares loss function), and 
  
    
      
        R
      
    
    {\displaystyle R}
  
 is convex, continuous, and proper, then the proximal method to solve the problem is as follows. First define the proximal operator

  
    
      
        
          prox
          
            R
          
        
        ⁡
        (
        v
        )
        =
        
          
            argmin
          
          
            w
            ∈
            
              
                R
              
              
                D
              
            
          
        
        ⁡
        
          {
          
            R
            (
            w
            )
            +
            
              
                1
                2
              
            
            
              
                ‖
                
                  w
                  −
                  v
                
                ‖
              
              
                2
              
            
          
          }
        
        ,
      
    
    {\displaystyle \operatorname {prox} _{R}(v)=\mathop {\operatorname {argmin} } _{w\in \mathbb {R} ^{D}}\left\{R(w)+{\frac {1}{2}}\left\|w-v\right\|^{2}\right\},}
  

and then iterate

  
    
      
        
          w
          
            k
            +
            1
          
        
        =
        
          
            prox
          
          
            γ
            ,
            R
          
        
        ⁡
        
          (
          
            
              w
              
                k
              
            
            −
            γ
            ∇
            F
            (
            
              w
              
                k
              
            
            )
          
          )
        
      
    
    {\displaystyle w_{k+1}=\mathop {\operatorname {prox} } _{\gamma ,R}\left(w_{k}-\gamma \nabla F(w_{k})\right)}
  

The proximal method iteratively performs gradient descent and then projects the result back into the space permitted by 
  
    
      
        R
      
    
    {\displaystyle R}
  
.
When 
  
    
      
        R
      
    
    {\displaystyle R}
  
 is the L1 regularizer, the proximal operator is equivalent to the soft-thresholding operator,

  
    
      
        
          S
          
            λ
          
        
        (
        v
        )
        f
        (
        n
        )
        =
        
          
            {
            
              
                
                  
                    v
                    
                      i
                    
                  
                  −
                  λ
                  ,
                
                
                  
                    if 
                  
                  
                    v
                    
                      i
                    
                  
                  >
                  λ
                
              
              
                
                  0
                  ,
                
                
                  
                    if 
                  
                  
                    v
                    
                      i
                    
                  
                  ∈
                  [
                  −
                  λ
                  ,
                  λ
                  ]
                
              
              
                
                  
                    v
                    
                      i
                    
                  
                  +
                  λ
                  ,
                
                
                  
                    if 
                  
                  
                    v
                    
                      i
                    
                  
                  <
                  −
                  λ
                
              
            
            
          
        
      
    
    {\displaystyle S_{\lambda }(v)f(n)={\begin{cases}v_{i}-\lambda ,&{\text{if }}v_{i}>\lambda \\0,&{\text{if }}v_{i}\in [-\lambda ,\lambda ]\\v_{i}+\lambda ,&{\text{if }}v_{i}<-\lambda \end{cases}}}
  

This allows for efficient computation.


=== Group sparsity without overlaps ===
Groups of features can be regularized by a sparsity constraint, which can be useful for expressing certain prior knowledge into an optimization problem.
In the case of a linear model with non-overlapping known groups, a regularizer can be defined:

  
    
      
        R
        (
        w
        )
        =
        
          ∑
          
            g
            =
            1
          
          
            G
          
        
        
          
            ‖
            
              w
              
                g
              
            
            ‖
          
          
            2
          
        
        ,
      
    
    {\displaystyle R(w)=\sum _{g=1}^{G}\left\|w_{g}\right\|_{2},}
  
 where 
  
    
      
        ‖
        
          w
          
            g
          
        
        
          ‖
          
            2
          
        
        =
        
          
            
              ∑
              
                j
                =
                1
              
              
                
                  |
                
                
                  G
                  
                    g
                  
                
                
                  |
                
              
            
            
              
                (
                
                  w
                  
                    g
                  
                  
                    j
                  
                
                )
              
              
                2
              
            
          
        
      
    
    {\displaystyle \|w_{g}\|_{2}={\sqrt {\sum _{j=1}^{|G_{g}|}\left(w_{g}^{j}\right)^{2}}}}
  

This can be viewed as inducing a regularizer over the 
  
    
      
        
          L
          
            2
          
        
      
    
    {\displaystyle L_{2}}
  
 norm over members of each group followed by an 
  
    
      
        
          L
          
            1
          
        
      
    
    {\displaystyle L_{1}}
  
 norm over groups.
This can be solved by the proximal method, where the proximal operator is a block-wise soft-thresholding function:

  
    
      
        
          prox
          
            λ
            ,
            R
            ,
            g
          
        
        ⁡
        (
        
          w
          
            g
          
        
        )
        =
        
          
            {
            
              
                
                  
                    (
                    
                      1
                      −
                      
                        
                          
                            λ
                            
                              
                                ‖
                                
                                  w
                                  
                                    g
                                  
                                
                                ‖
                              
                              
                                2
                              
                            
                          
                        
                      
                    
                    )
                  
                  
                    w
                    
                      g
                    
                  
                  ,
                
                
                  
                    if 
                  
                  
                    
                      ‖
                      
                        w
                        
                          g
                        
                      
                      ‖
                    
                    
                      2
                    
                  
                  >
                  λ
                
              
              
                
                  0
                  ,
                
                
                  
                    if 
                  
                  ‖
                  
                    w
                    
                      g
                    
                  
                  
                    ‖
                    
                      2
                    
                  
                  ≤
                  λ
                
              
            
            
          
        
      
    
    {\displaystyle \operatorname {prox} \limits _{\lambda ,R,g}(w_{g})={\begin{cases}\left(1-{\dfrac {\lambda }{\left\|w_{g}\right\|_{2}}}\right)w_{g},&{\text{if }}\left\|w_{g}\right\|_{2}>\lambda \\[1ex]0,&{\text{if }}\|w_{g}\|_{2}\leq \lambda \end{cases}}}
  


=== Group sparsity with overlaps ===
The algorithm described for group sparsity without overlaps can be applied to the case where groups do overlap, in certain situations. This will likely result in some groups with all zero elements, and other groups with some non-zero and some zero elements.
If it is desired to preserve the group structure, a new regularizer can be defined:

  
    
      
        R
        (
        w
        )
        =
        inf
        
          {
          
            
              ∑
              
                g
                =
                1
              
              
                G
              
            
            ‖
            
              w
              
                g
              
            
            
              ‖
              
                2
              
            
            :
            w
            =
            
              ∑
              
                g
                =
                1
              
              
                G
              
            
            
              
                
                  
                    w
                    ¯
                  
                
              
              
                g
              
            
          
          }
        
      
    
    {\displaystyle R(w)=\inf \left\{\sum _{g=1}^{G}\|w_{g}\|_{2}:w=\sum _{g=1}^{G}{\bar {w}}_{g}\right\}}
  

For each 
  
    
      
        
          w
          
            g
          
        
      
    
    {\displaystyle w_{g}}
  
, 
  
    
      
        
          
            
              
                w
                ¯
              
            
          
          
            g
          
        
      
    
    {\displaystyle {\bar {w}}_{g}}
  
 is defined as the vector such that the restriction of 
  
    
      
        
          
            
              
                w
                ¯
              
            
          
          
            g
          
        
      
    
    {\displaystyle {\bar {w}}_{g}}
  
 to the group 
  
    
      
        g
      
    
    {\displaystyle g}
  
 equals 
  
    
      
        
          w
          
            g
          
        
      
    
    {\displaystyle w_{g}}
  
 and all other entries of 
  
    
      
        
          
            
              
                w
                ¯
              
            
          
          
            g
          
        
      
    
    {\displaystyle {\bar {w}}_{g}}
  
 are zero. The regularizer finds the optimal disintegration of 
  
    
      
        w
      
    
    {\displaystyle w}
  
 into parts. It can be viewed as duplicating all elements that exist in multiple groups. Learning problems with this regularizer can also be solved with the proximal method with a complication. The proximal operator cannot be computed in closed form, but can be effectively solved iteratively, inducing an inner iteration within the proximal method iteration.


== Regularizers for semi-supervised learning ==

When labels are more expensive to gather than input examples, semi-supervised learning can be useful. Regularizers have been designed to guide learning algorithms to learn models that respect the structure of unsupervised training samples. If a symmetric weight matrix 
  
    
      
        W
      
    
    {\displaystyle W}
  
 is given, a regularizer can be defined:

  
    
      
        R
        (
        f
        )
        =
        
          ∑
          
            i
            ,
            j
          
        
        
          w
          
            i
            j
          
        
        
          
            (
            
              f
              (
              
                x
                
                  i
                
              
              )
              −
              f
              (
              
                x
                
                  j
                
              
              )
            
            )
          
          
            2
          
        
      
    
    {\displaystyle R(f)=\sum _{i,j}w_{ij}\left(f(x_{i})-f(x_{j})\right)^{2}}
  

If 
  
    
      
        
          W
          
            i
            j
          
        
      
    
    {\displaystyle W_{ij}}
  
 encodes the result of some distance metric for points 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 and 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
, it is desirable that 
  
    
      
        f
        (
        
          x
          
            i
          
        
        )
        ≈
        f
        (
        
          x
          
            j
          
        
        )
      
    
    {\displaystyle f(x_{i})\approx f(x_{j})}
  
. This regularizer captures this intuition, and is equivalent to:

  
    
      
        R
        (
        f
        )
        =
        
          
            
              
                f
                ¯
              
            
          
          
            
              T
            
          
        
        L
        
          
            
              f
              ¯
            
          
        
      
    
    {\displaystyle R(f)={\bar {f}}^{\mathsf {T}}L{\bar {f}}}
  
 where 
  
    
      
        L
        =
        D
        −
        W
      
    
    {\displaystyle L=D-W}
  
 is the Laplacian matrix of the graph induced by 
  
    
      
        W
      
    
    {\displaystyle W}
  
.
The optimization problem 
  
    
      
        
          min
          
            f
            ∈
            
              
                R
              
              
                m
              
            
          
        
        R
        (
        f
        )
        ,
        m
        =
        u
        +
        l
      
    
    {\displaystyle \min _{f\in \mathbb {R} ^{m}}R(f),m=u+l}
  
 can be solved analytically if the constraint 
  
    
      
        f
        (
        
          x
          
            i
          
        
        )
        =
        
          y
          
            i
          
        
      
    
    {\displaystyle f(x_{i})=y_{i}}
  
 is applied for all supervised samples. The labeled part of the vector 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is therefore obvious. The unlabeled part of 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is solved for by:

  
    
      
        
          min
          
            
              f
              
                u
              
            
            ∈
            
              
                R
              
              
                u
              
            
          
        
        
          f
          
            
              T
            
          
        
        L
        f
        =
        
          min
          
            
              f
              
                u
              
            
            ∈
            
              
                R
              
              
                u
              
            
          
        
        
          {
          
            
              f
              
                u
              
              
                
                  T
                
              
            
            
              L
              
                u
                u
              
            
            
              f
              
                u
              
            
            +
            
              f
              
                l
              
              
                
                  T
                
              
            
            
              L
              
                l
                u
              
            
            
              f
              
                u
              
            
            +
            
              f
              
                u
              
              
                
                  T
                
              
            
            
              L
              
                u
                l
              
            
            
              f
              
                l
              
            
          
          }
        
      
    
    {\displaystyle \min _{f_{u}\in \mathbb {R} ^{u}}f^{\mathsf {T}}Lf=\min _{f_{u}\in \mathbb {R} ^{u}}\left\{f_{u}^{\mathsf {T}}L_{uu}f_{u}+f_{l}^{\mathsf {T}}L_{lu}f_{u}+f_{u}^{\mathsf {T}}L_{ul}f_{l}\right\}}
  

  
    
      
        
          ∇
          
            
              f
              
                u
              
            
          
        
        =
        2
        
          L
          
            u
            u
          
        
        
          f
          
            u
          
        
        +
        2
        
          L
          
            u
            l
          
        
        Y
      
    
    {\displaystyle \nabla _{f_{u}}=2L_{uu}f_{u}+2L_{ul}Y}
  

  
    
      
        
          f
          
            u
          
        
        =
        
          L
          
            u
            u
          
          
            †
          
        
        
          (
          
            
              L
              
                u
                l
              
            
            Y
          
          )
        
      
    
    {\displaystyle f_{u}=L_{uu}^{\dagger }\left(L_{ul}Y\right)}
  

The pseudo-inverse can be taken because 
  
    
      
        
          L
          
            u
            l
          
        
      
    
    {\displaystyle L_{ul}}
  
 has the same range as 
  
    
      
        
          L
          
            u
            u
          
        
      
    
    {\displaystyle L_{uu}}
  
.


== Regularizers for multitask learning ==
In the case of multitask learning, 
  
    
      
        T
      
    
    {\displaystyle T}
  
 problems are considered simultaneously, each related in some way. The goal is to learn 
  
    
      
        T
      
    
    {\displaystyle T}
  
 functions, ideally borrowing strength from the relatedness of tasks, that have predictive power. This is equivalent to learning the matrix 
  
    
      
        W
        :
        T
        ×
        D
      
    
    {\displaystyle W:T\times D}
  
 .


=== Sparse regularizer on columns ===

  
    
      
        R
        (
        w
        )
        =
        
          ∑
          
            i
            =
            1
          
          
            D
          
        
        
          
            ‖
            W
            ‖
          
          
            2
            ,
            1
          
        
      
    
    {\displaystyle R(w)=\sum _{i=1}^{D}\left\|W\right\|_{2,1}}
  

This regularizer defines an L2 norm on each column and an L1 norm over all columns. It can be solved by proximal methods.


=== Nuclear norm regularization ===

  
    
      
        R
        (
        w
        )
        =
        
          
            ‖
            
              σ
              (
              W
              )
            
            ‖
          
          
            1
          
        
      
    
    {\displaystyle R(w)=\left\|\sigma (W)\right\|_{1}}
  
 where 
  
    
      
        σ
        (
        W
        )
      
    
    {\displaystyle \sigma (W)}
  
 is the eigenvalues in the singular value decomposition of 
  
    
      
        W
      
    
    {\displaystyle W}
  
.


=== Mean-constrained regularization ===

  
    
      
        R
        (
        
          f
          
            1
          
        
        ⋯
        
          f
          
            T
          
        
        )
        =
        
          ∑
          
            t
            =
            1
          
          
            T
          
        
        
          
            ‖
            
              
                f
                
                  t
                
              
              −
              
                
                  1
                  T
                
              
              
                ∑
                
                  s
                  =
                  1
                
                
                  T
                
              
              
                f
                
                  s
                
              
            
            ‖
          
          
            
              H
              
                k
              
            
          
          
            2
          
        
      
    
    {\displaystyle R(f_{1}\cdots f_{T})=\sum _{t=1}^{T}\left\|f_{t}-{\frac {1}{T}}\sum _{s=1}^{T}f_{s}\right\|_{H_{k}}^{2}}
  

This regularizer constrains the functions learned for each task to be similar to the overall average of the functions across all tasks. This is useful for expressing prior information that each task is expected to share with each other task. An example is predicting blood iron levels measured at different times of the day, where each task represents an individual.


=== Clustered mean-constrained regularization ===

  
    
      
        R
        (
        
          f
          
            1
          
        
        ⋯
        
          f
          
            T
          
        
        )
        =
        
          ∑
          
            r
            =
            1
          
          
            C
          
        
        
          ∑
          
            t
            ∈
            I
            (
            r
            )
          
        
        
          
            ‖
            
              
                f
                
                  t
                
              
              −
              
                
                  1
                  
                    I
                    (
                    r
                    )
                  
                
              
              
                ∑
                
                  s
                  ∈
                  I
                  (
                  r
                  )
                
              
              
                f
                
                  s
                
              
            
            ‖
          
          
            
              H
              
                k
              
            
          
          
            2
          
        
      
    
    {\displaystyle R(f_{1}\cdots f_{T})=\sum _{r=1}^{C}\sum _{t\in I(r)}\left\|f_{t}-{\frac {1}{I(r)}}\sum _{s\in I(r)}f_{s}\right\|_{H_{k}}^{2}}
  
 where 
  
    
      
        I
        (
        r
        )
      
    
    {\displaystyle I(r)}
  
 is a cluster of tasks.
This regularizer is similar to the mean-constrained regularizer, but instead enforces similarity between tasks within the same cluster. This can capture more complex prior information. This technique has been used to predict Netflix recommendations. A cluster would correspond to a group of people who share similar preferences.


=== Graph-based similarity ===
More generally than above, similarity between tasks can be defined by a function. The regularizer encourages the model to learn similar functions for similar tasks.

  
    
      
        R
        (
        
          f
          
            1
          
        
        ⋯
        
          f
          
            T
          
        
        )
        =
        
          ∑
          
            t
            ,
            s
            =
            1
            ,
            t
            ≠
            s
          
          
            
              T
            
          
        
        
          
            ‖
            
              
                f
                
                  t
                
              
              −
              
                f
                
                  s
                
              
            
            ‖
          
          
            2
          
        
        
          M
          
            t
            s
          
        
      
    
    {\displaystyle R(f_{1}\cdots f_{T})=\sum _{t,s=1,t\neq s}^{\mathsf {T}}\left\|f_{t}-f_{s}\right\|^{2}M_{ts}}
  
 for a given symmetric similarity matrix 
  
    
      
        M
      
    
    {\displaystyle M}
  
.


== Other uses of regularization in statistics and machine learning ==
Bayesian learning methods make use of a prior probability that (usually) gives lower probability to more complex models. Well-known model selection techniques include the Akaike information criterion (AIC), minimum description length (MDL), and the Bayesian information criterion (BIC). Alternative methods of controlling overfitting not involving regularization include cross-validation.
Examples of applications of different methods of regularization to the linear model are:


== See also ==
Bayesian interpretation of regularization
Bias–variance tradeoff
Matrix regularization
Regularization by spectral filtering
Regularized least squares
Lagrange multiplier
Variance reduction
L-curve


== Notes ==


== References ==
Neumaier, A. (1998). "Solving ill-conditioned and singular linear systems: A tutorial on regularization" (PDF). SIAM Review. 40 (3): 636–666. Bibcode:1998SIAMR..40..636N. doi:10.1137/S0036144597321909. Archived from the original (PDF) on 2007-06-30.
Kukačka, Jan; Golkov, Vladimir; Cremers, Daniel (2017). "Regularization for Deep Learning: A Taxonomy". arXiv:1710.10686 [cs.LG].