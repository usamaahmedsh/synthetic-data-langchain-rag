Micro-Controller Operating Systems (MicroC/OS, stylized as μC/OS, or Micrium OS) is a real-time operating system (RTOS) designed by Jean J. Labrosse in 1991. It is a priority-based preemptive real-time kernel for microprocessors, written mostly in the programming language C. It is intended for use in embedded systems.
MicroC/OS allows defining several functions in C, each of which can execute as an independent thread or task. Each task runs at a different priority, and runs as if it owns the central processing unit (CPU). Lower priority tasks can be preempted by higher priority tasks at any time. Higher priority tasks use operating system (OS) services (such as a delay or event) to allow lower priority tasks to execute. OS services are provided for managing tasks and memory, communicating between tasks, and timing.


== History ==
The MicroC/OS kernel was published originally in a three-part article in Embedded Systems Programming magazine and the book μC/OS The Real-Time Kernel by Labrosse. He intended at first to simply describe the internals of a portable OS he had developed for his own use, but later developed it as a commercial product in his own company Micrium, Inc. in versions II and III.
In 2016 Micrium, Inc. was acquired by Silicon Laboratories and  it was subsequently released as open-source under the Apache license.
Silicon Labs continues to maintain an open-source product named Micrium OS for use on their own silicon and a group of former Micrium, Inc. employees (including Labrosse) provides consultancy and support for both μC/OS and Cesium RTOS, a proprietary fork made just after the open-source release.


== μC/OS-II ==
Based on the source code written for μC/OS, and introduced as a commercial product in 1998, μC/OS-II is a portable, ROM-able, scalable, preemptive, real-time, deterministic, multitasking kernel for microprocessors, and digital signal processors (DSPs). It manages up to 64 tasks. Its size can be scaled (between 5 and 24 Kbytes) to only contain the features needed for a given use.
Most of μC/OS-II is written in highly portable ANSI C, with target microprocessor-specific code written in assembly language. Use of the latter is minimized to ease porting to other processors.


=== Uses in embedded systems ===
μC/OS-II was designed for embedded uses. If the producer has the proper toolchain (i.e., C compiler, assembler, and linker-locator), μC/OS-II can be embedded as part of a product.
μC/OS-II is used in many embedded systems, including:

Avionics
Medical equipment and devices
Data communications equipment
White goods (appliances)
Mobile phones, personal digital assistants (PDAs), MIDs
Industrial controls
Consumer electronics
Automotive


=== Task states ===
μC/OS-II is a multitasking operating system. Each task is an infinite loop and can be in any one of the following five states (see figure below additionally)

Dormant
Ready
Running
Waiting (for an event)
Interrupted (interrupt service routine (ISR))
Further, it can manage up to 64 tasks. However, it is recommended that eight of these tasks be reserved for μC/OS-II, leaving an application up to 56 tasks.


=== Kernels ===
The kernel is the name given to the program that does most of the housekeeping tasks for the operating system. The boot loader hands control over to the kernel, which initializes the various devices to a known state and makes the computer ready for general operations. The kernel is responsible for managing tasks (i.e., for managing the CPU's time) and communicating between tasks. The fundamental service provided by the kernel is context switching.
The scheduler is the part of the kernel responsible for determining which task runs next. Most real-time kernels are priority based. In a priority-based kernel, control of the CPU is always given to the highest priority task ready to run. Two types of priority-based kernels exist: non-preemptive and preemptive. Nonpreemptive kernels require that each task do something to explicitly give up control of the CPU. A preemptive kernel is used when system responsiveness is more important. Thus, μC/OS-II and most commercial real-time kernels are preemptive. The highest priority task ready to run is always given control of the CPU.


=== Assigning tasks ===
Tasks with the highest rate of execution are given the highest priority using rate-monotonic scheduling. This scheduling algorithm is used in real-time operating systems (RTOS) with a static-priority scheduling class.


=== Managing tasks ===
In computing, a task is a unit of execution. In some operating systems, a task is synonymous with a process, in others with a thread. In batch processing computer systems, a task is a unit of execution within a job.
The system user of μC/OS-II is able to control the tasks by using the following features:

Task feature
Task creation
Task stack & stack checking
Task deletion
Change a task's priority
Suspend and resume a task
Get information about a task


=== Managing memory ===
To avoid fragmentation, μC/OS-II allows applications to obtain fixed-sized memory blocks from a partition made of a contiguous memory area. All memory blocks are the same size, and the partition contains an integral number of blocks. Allocation and deallocation of these memory blocks is done in constant time and is a deterministic system.


=== Managing time ===
μC/OS-II requires that a periodic time source be provided to keep track of time delays and timeouts. A tick should occur between 10 and 1000 times per second, or Hertz. The faster the tick rate, the more overhead μC/OS-II imposes on the system. The frequency of the clock tick depends on the desired tick resolution of an application. Tick sources can be obtained by dedicating a hardware timer, or by generating an interrupt from an alternating current (AC) power line (50 or 60 Hz) signal. This periodic time source is termed a clock tick.
After a clock tick is determined, tasks can be: 

Delaying a task
Resume a delayed task


=== Communicating between tasks ===
Intertask or interprocess communication in μC/OS-II occurs via: semaphores, message mailbox, message queues, tasks, and interrupt service routines (ISRs). They can interact with each other when a task or an ISR signals a task through a kernel object called an event control block (ECB). The signal is considered to be an event.


== μC/OS-III ==
μC/OS-III is the acronym for Micro-Controller Operating Systems Version 3, introduced in 2009 and adding functionality to the μC/OS-II RTOS.
μC/OS-III offers all of the features and functions of μC/OS-II. The biggest difference is the number of supported tasks. μC/OS-II allows only 1 task at each of 255 priority levels, for a maximum of 255 tasks. μC/OS-III allows any number of application tasks, priority levels, and tasks per level, limited only by processor access to memory.
μC/OS-II and μC/OS-III are currently maintained by Micrium, Inc., a subsidiary of Silicon Labs, and can be licensed per product or per product line.


=== Uses in embedded systems ===
The uses are the same as for μC/OS-II


=== Task states ===
μC/OS-III is a multitasking operating system. Each task is an infinite loop and can be in any one of five states (dormant, ready, running, interrupted, or pending). μC/OS-III supports an unlimited number of task priorities but configuring μC/OS-III to have between 32 and 256 task priorities typically suits most embedded systems well.


=== Round robin scheduling ===
When two or more tasks have the same priority, the kernel allows one task to run for a predetermined amount of time, named a quantum, and then selects another task. This process is termed round robin scheduling or time slicing. The kernel gives control to the next task in line if:

The current task has no work to do during its time slice, or
The current task completes before the end of its time slice, or
The time slice ends.


=== Kernels ===
The kernel functionality for μC/OS-III is the same as for μC/OS-II.


=== Managing tasks ===
Task management also functions the same as for μC/OS-II. However, μC/OS-III supports multitasking and allows an application to have any number of tasks. The maximum number of tasks is limited by only the amount of computer memory (both code and data space) available to the processor.
A task can be implemented viarunning to scheduled completion, in which the task deletes itself when it is finished, or more typically as an infinite loop, waiting for events to occur and processing those events.


=== Managing memory ===
Memory management is performed in the same way as in μC/OS-II.


=== Managing time ===
μC/OS-III offers the same time managing features as μC/OS-II. It also provides services to applications so that tasks can suspend their execution for user-defined time delays. Delays are specified by a number of either clock ticks, or hours, minutes, seconds, and milliseconds.


=== Communicating between tasks ===
Sometimes, a task or ISR must communicate information to another task, because it is unsafe for two tasks to access the same specific data or hardware resource at once. This can be resolved via an information transfer, termed inter-task communication. Information can be communicated between tasks in two ways: through global data, or by sending messages.
When using global variables, each task or ISR must ensure that it has exclusive access to variables. If an ISR is involved, the only way to ensure exclusive access to common variables is to disable interrupts. If two tasks share data, each can gain exclusive access to variables by either disabling interrupts, locking the scheduler, using a semaphore, or preferably, using a mutual exclusion semaphore. Messages can be sent to either an intermediate object called a message queue, or directly to a task, since in μC/OS-III, each task has its own built-in message queue. Use an external message queue if multiple tasks are to wait for messages. Send a message directly to a task if only one task will process the data received. While a task waits for a message to arrive, it uses no CPU time.


== Ports ==
A port involves three aspects: CPU, OS, and board specific (BSP) code. μC/OS-II and μC/OS-III have ports for most popular processors and boards in the market and are suitable for use in safety critical embedded systems such as aviation, medical systems, and nuclear installations. A μC/OS-III port involves writing or changing the contents of three kernel specific files: OS_CPU.H, OS_CPU_A.ASM, and OS_CPU_C.C. Finally create or change a board support package (BSP) for the evaluation board or target board being used. A μC/OS-III port is similar to a μC/OS-II port. There are significantly more ports than listed here, and ports are subject to continuous development. Both μC/OS-II and μC/OS-III are supported by popular SSL/TLS libraries such as wolfSSL, which ensure security across all connections.


== Licensing change ==
After acquisition by Silicon Labs, Micrium in 2020 changed to open-source model licensing in February 2020. This includes uC/OS III, all prior versions, all components: USB, file system, GUI, TCP/IP, etc.


== Documentation and support ==
Support is available via a typical support forum, and several comprehensive books, of which some are tailored to a given microcontroller architecture and development platform, as free PDFs, or as low-cost purchase in hard-cover. Paid support is available from Weston Embedded Solutions.


== References ==


== Sources ==
Protocol Support for μC/OS-II from Fusion Embedded
Micrium-uCOS-III-UsersManual 1st Edition
uC/OS-III: The Real-Time Kernel for the Renesas RX62N


== External links ==
Official website
SiliconLabs on GitHub
Summary of Commonly Used uC/OS-II Functions and Data Structures
NiosII GCC with MicroC/OS
μC/OS-II Reference Manual
How to Get a μC/OS-II Application Running