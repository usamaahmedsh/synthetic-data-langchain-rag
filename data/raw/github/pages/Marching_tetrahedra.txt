Marching tetrahedra is an algorithm in the field of computer graphics to render implicit surfaces. It clarifies a minor ambiguity problem of the marching cubes algorithm with some cube configurations. It was originally introduced in 1991.
While the original marching cubes algorithm was protected by a software patent, marching tetrahedrons offered an alternative algorithm that did not require a patent license. More than 20 years have passed from the patent filing date (June 5, 1985), and the marching cubes algorithm can now be used freely. Optionally, the minor improvements of marching tetrahedrons may be used to correct the aforementioned ambiguity in some configurations.
In marching tetrahedra, each cube is split into six irregular tetrahedra by cutting the cube in half three times, cutting diagonally through each of the three pairs of opposing faces. In this way, the tetrahedra all share one of the main diagonals of the cube. Instead of the twelve edges of the cube, we now have nineteen edges: the original twelve, six face diagonals, and the main diagonal. Just like in  marching cubes, the intersections of these edges with the isosurface are approximated by linearly interpolating the values at the grid points.
Adjacent cubes share all edges in the connecting face, including the same diagonal. This is an important property to prevent cracks in the rendered surface, because interpolation of the two distinct diagonals of a face usually gives slightly different intersection points. An added benefit is that up to five computed intersection points can be reused when handling the neighbor cube. This includes the computed surface normals and other graphics attributes at the intersection points.
Each tetrahedron has sixteen possible configurations, falling into three classes: no intersection, intersection in one triangle and intersection in two (adjacent) triangles. It is straightforward to enumerate all sixteen configurations and map them to vertex index lists defining the appropriate triangle strips.


== Comparison with marching cubes ==
Marching tetrahedra computes up to nineteen edge intersections per cube, where marching cubes only requires twelve. Only one of these intersections cannot be shared with an adjacent cube (the one on the main diagonal), but sharing on all faces of the cube complicates the algorithm and increases memory requirements considerably. On the other hand, the additional intersections provide for a slightly better sampling resolution.
The number of configurations, determining the size of the commonly used lookup tables, is much smaller, since only four rather than eight separate vertices are involved per tetrahedron. There are six tetrahedra to process instead of one single cube. The process is unambiguous, so no additional ambiguity handling is necessary.
The downside is that the tessellation of a cube with tetrahedra requires a choice regarding the orientation of the tetrahedra, which may produce artificial "bumps" in the isosurface because of interpolation along the face diagonals.


== Diamond Lattice Cell - Alternative Cube Slicing Method ==
The cubical cells to be meshed can also be sliced into 5 tetrahedra, using a (diamond cubic) lattice as a basis.  Cubes are mated on each side with another that has an opposite alignment of the tetrahedron around the centroid of the cube.  Alternating vertices have a different number of tetrahedra intersecting on it, resulting in a slightly different mesh depending on position.  When sliced this way, additional planes of symmetry are provided; having a tetrahedron around the centroid of the cube also generates very open spaces around points that are outside of the surface.

Diamond cubic has a variety of visualizations. Instead of empty cells, every cell should be filled, with alternating inner tetrahedrons.  For each tetrahedron inscribed in a cube, using the vertices of the cube and edges that cross the faces of the cube, the tetrahedron will occupy 4 points; the other 4 points form the corners of an inverted tetrahedron; the cubic cells are tiled such that the position of the cell (x+y+z+...) is odd, use one, else use the inverted; otherwise near cells would use a different diagonal to compute the intersection.

Calculation of color based on a spacial texture system can be done using the current fragment position to select from a repeating texture based on the pairs of texel coordinates (x,y), (y,z) and (x,z) and scaling those values by the absolute value of each respective component of the normal z, x, and y respectively.  Texture decalling can be applied as texture splatting by projecting the position of the current fragment in the direction of the decal' normal, to the plane of the texture given by an origin point and normal, then using a 'up' or 'right' directional vector to compute the texture coordinate.
This technique would be more closely compared with dual contouring which is listed under isosurfaces, as a potential technique.  DCL tetrahedra involves additional calculations for the diagonals across cube-faces, where dual contouring does not.  This technique also has not addressed when two near points 'inside' a surface are a combined distance < 1 from the surface, where they should generate two points on the edge instead of 1; the related modification is Manifold Dual Contouring.


== See also ==
Isosurface
Marching cubes
Asymptotic decider
Image-based meshing


== References ==


== External links ==
Visualization of Implicit Surfaces Using Adaptive Tetrahedrizations (Heinrich Muller, Michael Wehle)
An isosurface generator by Mikolalysenko which includes Marching Tetrahedra as one of its algorithms
Mikolalysenko's isosurface generator then DCL Marching Tetrahedra as an additional algorithm(WebGL)
Mikolalysenko's isosurface generator with spatial texturing based on voxel type added to DCL Marching Tetrahedra(WebGL2)
Regularised marching tetrahedra: improved iso-surface extraction