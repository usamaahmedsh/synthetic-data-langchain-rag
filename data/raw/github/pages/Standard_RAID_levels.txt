In computer storage, the standard RAID levels comprise a basic set of RAID ("redundant array of independent disks" or "redundant array of inexpensive disks") configurations that employ the techniques of striping, mirroring, or parity to create large reliable data stores from multiple general-purpose computer hard disk drives (HDDs). The most common types are RAID 0 (striping), RAID 1 (mirroring) and its variants, RAID 5 (distributed parity), and RAID 6 (dual parity). Multiple RAID levels can also be combined or nested, for instance RAID 10 (striping of mirrors) or RAID 01 (mirroring stripe sets). RAID levels and their associated data formats are standardized by the Storage Networking Industry Association (SNIA) in the Common RAID Disk Drive Format (DDF) standard. The numerical values only serve as identifiers and do not signify performance, reliability, generation, hierarchy, or any other metric.
While most RAID levels can provide good protection against and recovery from hardware defects or defective sectors/read errors (hard errors), they do not provide any protection against data loss due to catastrophic failures (fire, water) or soft errors such as user error, software malfunction, or malware infection. For valuable data, RAID is only one building block of a larger data loss prevention and recovery scheme – it cannot replace a backup plan.


== RAID 0 ==

RAID 0 (also known as a stripe set or striped volume) splits ("stripes") data evenly across two or more disks, without parity information, redundancy, or fault tolerance.  Since RAID 0 provides no fault tolerance or redundancy, the failure of one drive will cause the entire array to fail, due to data being striped across all disks. This configuration is typically implemented having speed as the intended goal.
A RAID 0 setup can be created with disks of differing sizes, but the storage space added to the array by each disk is limited to the size of the smallest disk. For example, if a 120 GB disk is striped together with a 320 GB disk, the size of the array will be 120 GB × 2 = 240 GB. However, some RAID implementations would allow the remaining 200 GB to be used for other purposes.
The diagram in this section shows how the data is distributed into stripes on two disks, with A1:A2 as the first stripe, A3:A4 as the second one, etc.  Once the stripe size is defined during the creation of a RAID 0 array, it needs to be maintained at all times.  Since the stripes are accessed in parallel, an n-drive RAID 0 array appears as a single large disk with a data rate n times higher than the single-disk rate.


=== Performance ===
A RAID 0 array of n drives provides data read and write transfer rates up to n times as high as the individual drive rates, but with no data redundancy.  As a result, RAID 0 is primarily used in applications that require high performance and are able to tolerate lower reliability, such as in scientific computing or gaming.
Some benchmarks of desktop applications show RAID 0 performance to be marginally better than a single drive.  Another article examined these claims and concluded that "striping does not always increase performance (in certain situations it will actually be slower than a non-RAID setup), but in most situations it will yield a significant improvement in performance".  Synthetic benchmarks show different levels of performance improvements when multiple HDDs or SSDs are used in a RAID 0 setup, compared with single-drive performance.  However, some synthetic benchmarks also show a drop in performance for the same comparison.


== RAID 1 ==

RAID 1 consists of an exact copy (or mirror) of a set of data on two or more disks; a classic RAID 1 mirrored pair contains two disks. This configuration offers no parity, striping, or spanning of disk space across multiple disks, since the data is mirrored on all disks belonging to the array, and the array can only be as big as the smallest member disk. This layout is useful when read performance or reliability is more important than write performance or the resulting data storage capacity.
The array will continue to operate so long as at least one member drive is operational.


=== Performance ===
Any read request can be serviced and handled by any drive in the array; thus, depending on the nature of I/O load, random read performance of a RAID 1 array may equal up to the sum of each member's performance, while the write performance remains at the level of a single disk.  However, if disks with different speeds are used in a RAID 1 array, overall write performance is equal to the speed of the slowest disk.
Synthetic benchmarks show varying levels of performance improvements when multiple HDDs or SSDs are used in a RAID 1 setup, compared with single-drive performance. However, some synthetic benchmarks also show a drop in performance for the same comparison.


== RAID 2 ==

RAID 2 splits data at the bit level across multiple disks, unlike most RAID levels, which divide data into blocks. It uses a type of error correction known as Hamming code, which introduces redundancy to detect and correct errors in stored data. The hard drives are synchronized by the controller so they spin in unison, reaching the same position at the same time. Due to this synchronization, the system typically processes only one read or write request at a time, limiting its ability to handle multiple operations concurrently.
In early computing, RAID 2 offered high data transfer rates by using a high-rate Hamming code and many disks operating in parallel. This design was used in specialized systems such as the Thinking Machines' DataVault, which transferred 32 bits of data simultaneously with 7 bits of parity: a (39,32) code. IBM's Stretch system employed a similar approach, transferring 64 data bits along with 8 bits of error correction: a (72,64) code. Both codes are not basic Hamming codes, but the improved SECDED code, meaning that they can both detect and correct single-bit errors, but only detect two-bit errors.
As modern hard drives incorporate built-in error correction, the added complexity of RAID 2's external Hamming code provides little benefit over simpler redundancy methods such as parity. Consequently, RAID 2 was rarely implemented and is the only original RAID level that is no longer used in practice.


== RAID 3 ==

RAID 3, which is also rarely used in practice, consists of byte-level striping with a dedicated parity disk. One of the characteristics of RAID 3 is that it generally cannot service multiple requests simultaneously, which happens because any single block of data will, by definition, be spread across all members of the set and will reside in the same physical location on each disk. Therefore, any I/O operation requires activity on every disk and usually requires synchronized spindles.
This makes it suitable for applications that demand the highest transfer rates in long sequential reads and writes, for example uncompressed video editing. Applications that make small reads and writes from random disk locations will get the worst performance out of this level.
The requirement that all disks spin synchronously (in a lockstep) added design considerations that provided no significant advantages over other RAID levels.  Both RAID 3 and RAID 4 were quickly replaced by RAID 5. RAID 3 was usually implemented in hardware, and the performance issues were addressed by using large disk caches.


== RAID 4 ==

RAID 4 consists of block-level striping with a dedicated parity disk.  As a result of its layout, RAID 4 provides good performance of random reads, while the performance of random writes is low due to the need to write all parity data to a single disk, unless the filesystem is RAID-4-aware and compensates for that.
An advantage of RAID 4 is that it can be quickly extended online, without parity recomputation, as long as the newly added disks are completely filled with 0-bytes.
In diagram 1, a read request for block A1 would be serviced by disk 0. A simultaneous read request for block B1 would have to wait, but a read request for B2 could be serviced concurrently by disk 1.


== RAID 5 ==

RAID 5 consists of block-level striping with distributed parity. Unlike in RAID 4, parity information is distributed among the drives. It requires that all drives but one be present to operate. Upon failure of a single drive, subsequent reads can be calculated from the distributed parity such that no data is lost. RAID 5 requires at least three disks.
There are many layouts of data and parity in a RAID 5 disk drive array depending upon the sequence of writing across the disks, that is:

the sequence of data blocks written, left to right or right to left on the disk array, of disks 0 to N.
the location of the parity block at the beginning or end of the stripe.
the location of the first block of a stripe with respect to parity of the previous stripe.
The figure shows 1) data blocks written left to right, 2) the parity block at the end of the stripe and 3) the first block of the next stripe not on the same disk as the parity block of the previous stripe.  It can be designated as a Left Asynchronous RAID 5 layout and this is the only layout identified in the last edition of The Raid Book published by the defunct Raid Advisory Board.  In a Synchronous layout the data first block of the next stripe is written on the same drive as the parity block of the previous stripe.
In comparison to RAID 4, RAID 5's distributed parity evens out the stress of a dedicated parity disk among all RAID members. Additionally, write performance is increased since all RAID members participate in the serving of write requests. Although it will not be as efficient as a striping (RAID 0) setup, because parity must still be written, this is no longer a bottleneck.
Since parity calculation is performed on the full stripe, small changes to the array experience write amplification: in the worst case when a single, logical sector is to be written, the original sector and the according parity sector need to be read, the original data is removed from the parity, the new data calculated into the parity and both the new data sector and the new parity sector are written.


== RAID 6 ==

RAID 6 extends RAID 5 by adding a second parity block; thus, it uses block-level striping with two parity blocks distributed across all member disks. RAID 6 requires at least four disks.
As in RAID 5, there are many layouts of RAID 6 disk arrays depending upon the direction the data blocks are written, the location of the parity blocks with respect to the data blocks and whether or not the first data block of a subsequent stripe is written to the same drive as the last parity block of the prior stripe.  The figure to the right is just one of many such layouts.
According to the Storage Networking Industry Association (SNIA), the definition of RAID 6 is: "Any form of RAID that can continue to execute read and write requests to all of a RAID array's virtual disks in the presence of any two concurrent disk failures. Several methods, including dual check data computations (parity and Reed–Solomon), orthogonal dual parity check data and diagonal parity, have been used to implement RAID Level 6."
The second block is usually labeled Q, with the first block labeled P. Typically the P block is calculated as the parity (XORing) of the data, the same as RAID 5. Different implementations of RAID 6 use different erasure codes to calculate the Q block. The classical choice is Reed-Solomon, but it requires CPU-intensive Galois field calculations, though this can be mitigated with a hardware implementation (ASIC or FPGA). There is a special choice of polynomial from Anvin used by Linux, which allows for efficient implementation using only addition and multiplication by two in GF(28) and opens the possibility of using SSSE3, AVX2, or other SIMD methods to implement efficiently.
Newer erasure codes specialized to the k = 2 case go further than Anvin's optimization. These include EVENODD (1996), Row Diagonal Parity (RDP, 2004), Liberation codes (2008), and Mojette (2015).


=== Performance ===
RAID 6 uses a second parity code in addition to the simple XOR. As a result it requires more processing power to both read and write. Performance varies greatly depending on how RAID 6 is implemented in the manufacturer's storage architecture—in software, firmware, or by using firmware and specialized hardware accelerators (ASICs or FPGAs) for intensive parity calculations.
RAID 6 generally do not show an obvious penalty for read operations: for undamaged data, only the simpler parity needs to be calculated and checked like in RAID 5. Only when there is a disagreement will the more complex parity be needed. Additional robustness can be obtained via background scrubbing instead of foreground reads. As a result, RAID 6 usually reads up to the same speed as RAID 5 with the same number of physical drives.
The delayed-check strategy does not work when writing data. As a result, the full performance penalty of RAID 6 is seen during writes.


== Comparison ==

The following table provides an overview of some considerations for standard RAID levels. In each case, array space efficiency is given as an expression in terms of the number of drives, n; this expression designates a fractional value between zero and one, representing the fraction of the sum of the drives' capacities that is available for use. For example, if three drives are arranged in RAID 3, this gives an array space efficiency of 1 − 1/n = 1 − 1/3 = 2/3 ≈ 67%; thus, if each drive in this example has a capacity of 250 GB, then the array has a total capacity of 750 GB but the capacity that is usable for data storage is only 500 GB.  Different RAID configurations can also detect failure during so called data scrubbing.  
Historically disks were subject to lower reliability and RAID levels were also used to detect which disk in the array had failed in addition to that a disk had failed.  Though as noted by Patterson et al. even at the inception of RAID many (though not all) disks were already capable of finding internal errors using error correcting codes. In particular it is/was sufficient to have a mirrored set of disks to detect a failure, but two disks were not sufficient to detect which had failed in a disk array without error correcting features.  Modern RAID arrays depend for the most part on a disk's ability to identify itself as faulty which can be detected as part of a scrub.  The redundant information is used to reconstruct the missing data, rather than to identify the faulted drive. Drives are considered to have faulted if they experience an unrecoverable read error, which occurs after a drive has retried many times to read data and failed. Enterprise drives may also report failure in far fewer tries than consumer drives as part of TLER to ensure a read request is fulfilled in a timely manner.

Notes:


== System implications ==
In measurement of the I/O performance of five filesystems with five storage configurations—single SSD, RAID 0, RAID 1, RAID 10, and RAID 5 it was shown that F2FS on RAID 0 and RAID 5 with eight SSDs outperforms EXT4 by 5 times and 50 times, respectively. The measurements also suggest that the RAID controller can be a significant bottleneck in building a RAID system with high speed SSDs.


== Nested RAID ==

Combinations of two or more standard RAID levels.  They are also known as RAID 0+1 or RAID 01, RAID 0+3 or RAID 03, RAID 1+0 or RAID 10, RAID 5+0 or RAID 50, RAID 6+0 or RAID 60, and RAID 10+0 or RAID 100.


== Non-standard variants ==

In addition to standard and nested RAID levels, alternatives include non-standard RAID levels, and non-RAID drive architectures. Non-RAID drive architectures are referred to by similar terms and acronyms, notably JBOD ("just a bunch of disks"), SPAN/BIG, and MAID ("massive array of idle disks").


== Notes ==


== References ==


== Further reading ==
"Learning About RAID". Support.Dell.com. Dell. 2009. Archived from the original on 2009-02-20. Retrieved 2016-04-15.
Redundant Arrays of Inexpensive Disks (RAIDs), chapter 38 from the Operating Systems: Three Easy Pieces book by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau


== External links ==
IBM summary on RAID levels
RAID Calculator for Standard RAID Levels
Sun StorEdge 3000 Family Configuration Service 2.5 User's Guide: RAID Basics