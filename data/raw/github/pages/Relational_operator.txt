In computer science, a relational operator is a  programming language construct or operator that defines syntactically a relationship between two entities. These include numerical equality (e.g., 5 = 5) and inequalities (e.g., 4 ≥ 3).
In programming languages that include a distinct boolean data type in their type system, like Pascal, Ada, Python or Java, these operators usually evaluate to true or false, depending on if the conditional relationship between the two operands holds or not.
In languages such as C, relational operators return the integers 0 or 1, where 0 stands for false and any non-zero value stands for true.
An expression created using a relational operator forms what is termed a relational expression or a condition. Relational operators can be seen as special cases of logical predicates.


== Equality ==


=== Usage ===
Equality is used in many programming language constructs and data types. It is used to test if an element already exists in a set, or to access to a value through a key. It is used in switch statements to dispatch the control flow to the correct branch, and during the unification process in logic programming.
There can be multiple valid definitions of equality, and any particular language might adopt one or more of them, depending on various design aspects. One possible meaning of equality is that "if a equals b, then either a or b can be used interchangeably in any context without noticing any difference". But this statement does not necessarily hold, particularly when taking into account mutability together with content equality.


=== Location equality vs. content equality ===
Sometimes, particularly in object-oriented programming, the comparison raises questions of data types and inheritance, equality, and identity. It is often necessary to distinguish between:

two different objects of the same type, e.g., two hands
two objects being equal but distinct, e.g., two $10 banknotes
two objects being equal but having different representation, e.g., a $1 bill and a $1 coin
two different references to the same object, e.g., two nicknames for the same person
In many modern programming languages, objects and data structures are accessed through references. In such languages, there becomes a need to test for two different types of equality:

Location equality (identity): if two references (A and B) reference the same object. Interactions with the object through A are indistinguishable from the same interactions through B, and in particular changes to the object through A are reflected through B.
Content equality: if the objects referenced by two references (A and B) are equivalent in some sense:
Structural equality (that is, their contents are the same). which may be either shallow (testing only immediate subparts), or deep (testing for equality of subparts recursively). A simple way to achieve this is through representational equality: checking that the values have the same representation.
Some other tailor-made equality, preserving the external behavior. For example, 1/2 and 2/4 are considered equal when seen as a rational number. A possible requirement would be that "A = B if and only if all operations on objects A and B will have the same result", in addition to reflexivity, symmetry, and transitivity.
The first type of equality usually implies the second (except for things like not a number (NaN) which are unequal to themselves), but the converse is not necessarily true. For example, two string objects may be distinct objects (unequal in the first sense) but contain the same sequence of characters (equal in the second sense). See identity for more of this issue.
Real numbers, including many simple fractions, cannot be represented exactly in floating-point arithmetic, and it may be necessary to test for equality within a given tolerance. Such tolerance, however, can easily break desired properties such as transitivity, whereas reflexivity breaks too: the IEEE floating-point standard requires that NaN ≠ NaN holds. In contrast, the (2022) private standard for posit arithmetic (posit proponents mean to replace IEEE floats) has a similar concept, NaR (Not a Real), where NaR = NaR holds.
Other programming elements such as computable functions, may either have no sense of equality, or an equality that is uncomputable. For these reasons, some languages define an explicit notion of "comparable", in the form of a base class, an interface, a trait or a protocol, which is used either explicitly, by declaration in source code, or implicitly, via the structure of the type involved.


=== Comparing values of different types ===
In JavaScript, PHP, VBScript and a few other dynamically typed languages, the standard equality operator follows so-called loose typing, that is it evaluates to true even if two values are not equal and are of incompatible types, but can be coerced to each other by some set of language-specific rules, making the number 4 compare equal to the text string "4", for instance. Although such behaviour is typically meant to make the language easier, it can lead to surprising and difficult to predict consequences that many programmers are unaware of. For example, JavaScript's loose equality rules can cause equality to be intransitive (i.e., a == b and b == c, but a != c), or make certain values be equal to their own negation.
A strict equality operator is also often available in those languages, returning true only for values with identical or equivalent types (in PHP, 4 === "4" is false although 4 == "4" is true). For languages where the number 0 may be interpreted as false, this operator may simplify things such as checking for zero (as x == 0 would be true for x being either 0 or "0" using the type agnostic equality operator).


== Ordering ==
Greater than and less than comparison of non-numeric data is performed according to a sort convention (such as, for text strings, lexicographical order) which may be built into the programming language and/or configurable by a programmer.
When it is desired to associate a numeric value with the result of a comparison between two data items, say a and b, the usual convention is to assign −1 if a < b, 0 if a = b and 1 if a > b. For example, the C function strcmp performs a three-way comparison and returns −1, 0, or 1 according to this convention, and qsort expects the comparison function to return values according to this convention. In sorting algorithms, the efficiency of comparison code is critical since it is one of the major factors contributing to sorting performance.
Comparison of programmer-defined data types (data types for which the programming language has no in-built understanding) may be carried out by custom-written or library functions (such as strcmp mentioned above), or, in some languages, by overloading a comparison operator – that is, assigning a programmer-defined meaning that depends on the data types being compared. Another alternative is using some convention such as member-wise comparison.


== Logical equivalence ==
Though perhaps unobvious at first, like the boolean logical operators XOR, AND, OR, and NOT, relational operators can be designed to have logical equivalence, such that they can all be defined in terms of one another. The following four conditional statements all have the same logical equivalence E (either all true or all false) for any given x and y values:

  
    
      
        E
        =
        
          
            {
            
              
                
                  x
                  <
                  y
                
              
              
                
                  y
                  >
                  x
                
              
              
                
                  x
                  ≱
                  y
                
              
              
                
                  y
                  ≰
                  x
                
              
            
            
          
        
      
    
    {\displaystyle E={\begin{cases}x<y\\y>x\\x\ngeq y\\y\nleq x\end{cases}}}
  

This relies on the domain being well ordered.


== Standard relational operators ==
The most common numerical relational operators used in programming languages are shown below. Standard SQL uses the same operators as BASIC, while many databases allow != in addition to <> from the standard. SQL follows strict boolean algebra, i.e. doesn't use short-circuit evaluation, which is common to most languages below. E.g. PHP has it, but otherwise it has these same two operators defined as aliases, like many SQL databases.

Other conventions are less common: Common Lisp and Macsyma/Maxima use Basic-like operators for numerical values, except for inequality, which is /= in Common Lisp and # in Macsyma/Maxima. Common Lisp has multiple other sets of equality and relational operators serving different purposes, including eq, eql, equal, equalp, and string=. Older Lisps used equal, greaterp, and lessp; and negated them using not for the remaining operators.


== Syntax ==
Relational operators are also used in technical literature instead of words. Relational operators are usually written in infix notation, if supported by the programming language, which means that they appear between their operands (the two expressions being related). For example, an expression in Python will print the message if the x is less than y:

Other programming languages, such as Lisp, use prefix notation, as follows:


=== Operator chaining ===
In mathematics, it is common practice to chain relational operators, such as in 3 < x < y < 20 (meaning 3 < x and x < y and y < 20). The syntax is clear since these relational operators in mathematics are transitive.
However, many recent programming languages would see an expression like 3 < x < y as consisting of two left (or right-) associative operators, interpreting it as something like (3 < x) < y. If we say that x=4, we then get (3 < 4) < y, and evaluation will give true < y which generally does not make sense. However, it does compile in C/C++ and some other languages, yielding surprising result (as true would be represented by the number 1 here).
It is possible to give the expression x < y < z its familiar mathematical meaning, and some programming languages such as Python and Raku do that. Others, such as C# and Java, do not, partly because it would differ from the way most other infix operators work in C-like languages. The D programming language does not do that since it maintains some compatibility with C, and "Allowing C expressions but with subtly different semantics (albeit arguably in the right direction) would add more confusion than convenience".
Some languages, like Common Lisp, use multiple argument predicates for this. In Lisp (<= 1 x 10) is true when x is between 1 and 10.


=== Confusion with assignment operators ===

Early FORTRAN (1956–57) was bounded by heavily restricted character sets where = was the only relational operator available. There were no < or > (and certainly no ≤ or ≥). This forced the designers to define symbols such as .GT., .LT., .GE., .EQ. etc. and subsequently made it tempting to use the remaining = character for copying, despite the obvious incoherence with mathematical usage (X=X+1 should be impossible).
International Algebraic Language (IAL, ALGOL 58) and ALGOL (1958 and 1960) thus introduced := for assignment, leaving the standard = available for equality, a convention followed by CPL, ALGOL W, ALGOL 68, Basic Combined Programming Language (BCPL), Simula, SET Language (SETL), Pascal, Smalltalk, Modula-2, Ada, Standard ML, OCaml, Eiffel, Object Pascal (Delphi), Oberon, Dylan, VHSIC Hardware Description Language (VHDL), and several other languages.


==== B and C ====
This uniform de facto standard among most programming languages was eventually changed, indirectly, by a minimalist compiled language named B. Its sole intended application was as a vehicle for a first port of (a then very primitive) Unix, but it also evolved into the very influential C language.
B started off as a syntactically changed variant of the systems programming language BCPL, a simplified (and typeless) version of CPL. In what has been described as a "strip-down" process, the and and or operators of BCPL were replaced with & and | (which would later become && and ||, respectively.). In the same process, the ALGOL style := of BCPL was replaced by = in B. The reason for all this being unknown. As variable updates had no special syntax in B (such as let or similar) and were allowed in expressions, this non standard meaning of the equal sign meant that the traditional semantics of the equal sign now had to be associated with another symbol. Ken Thompson used the ad hoc == combination for this.
As a small type system was later introduced, B then became C. The popularity of this language along with its association with Unix, led to Java, C#, and many other languages following suit, syntactically, despite this needless conflict with the mathematical meaning of the equal sign.


==== Languages ====
Assignments in C have a value and since any non-zero scalar value is interpreted as true in conditional expressions, the code if (x = y) is legal, but has a very different meaning from if (x == y). The former code fragment means "assign y to x, and if the new value of x is not zero, execute the following statement". The latter fragment means "if and only if x is equal to y, execute the following statement".

Though Java and C# have the same operators as C, this mistake usually causes a compile error in these languages instead, because the if-condition must be of type boolean, and there is no implicit way to convert from other types (e.g., numbers) into booleans. So unless the variable that is assigned to has type boolean (or wrapper type Boolean), there will be a compile error.
In ALGOL-like languages such as Pascal, Delphi, and Ada (in the sense that they allow nested function definitions), and in Python, and many functional languages, among others, assignment operators cannot appear in an expression (including if clauses), thus precluding this class of error. Some compilers, such as GNU Compiler Collection (GCC), provide a warning when compiling code containing an assignment operator inside an if statement, though there are some legitimate uses of an assignment inside an if-condition. In such cases, the assignment must be wrapped in an extra pair of parentheses explicitly, to avoid the warning.
Similarly, some languages, such as BASIC use just the = symbol for both assignment and equality, as they are syntactically separate (as with Pascal, Ada, Python, etc., assignment operators cannot appear in expressions).
Some programmers get in the habit of writing comparisons against a constant in the reverse of the usual order:

If = is used accidentally, the resulting code is invalid because 2 is not a variable. The compiler will generate an error message, on which the proper operator can be substituted. This coding style is termed left-hand comparison, or Yoda conditions.
This table lists the different mechanisms to test for these two types of equality in various languages:

Ruby uses a === b to mean "b is a member of the set a", though the details of what it means to be a member vary considerably depending on the data types involved. === is here known as the "case equality" or "case subsumption" operator.


== See also ==
Binary relation
Common operator notation
Conditional (computer programming)
Equality (mathematics)
Equals sign
Logical operator
Operation (mathematics)
Operator (mathematics)
Operator (computer programming)
Spaceship operator
Triadic relation


== Notes and references ==