SLIME, the Superior Lisp Interaction Mode for Emacs, is an Emacs mode for developing Common Lisp applications. SLIME originates in an Emacs mode called SLIM written by Eric Marsden. It is developed as an open-source public domain software project by Luke Gorrie and Helmut Eller. Over 100 Lisp developers have contributed code to SLIME since the project was started in 2003.
SLIME follows a client-server architecture, using a backend called Swank that is loaded into Common Lisp. In that regard, it is similar to the Language Server Protocol, which it predates. Some Common Lisp editors use a LSP client for Common Lisp.
SLIME works with the main Common Lisp implementations, such as:

Steel Bank Common Lisp (SBCL)
Clozure CL (former OpenMCL)
LispWorks
Allegro Common Lisp
CLISP
Embeddable Common Lisp (ECL)
Armed Bear Common Lisp (ABCL)
Other programming languages can leverage SLIME with an editor plugin, or have plugins inspired by SLIME:

Clojure
JavaScript
Scheme
Kawa, a Scheme implementation
GNU R
Ruby
MIT Scheme


== Features ==
SLIME offers an experience of an Integrated Development Environment. Once SLIME is loaded into the editor and the Swank back-end loaded into the running Common Lisp image, it is to be noted that all interactions are made live, interactively, effectively "talking" to the running program and adding features incrementally.
SLIME provides:

code completion.
code compilation (compile the function at point, a region, a file, a project).
compilation notes highlighted in source buffer and gathered in a dedicated buffer.
code evaluation.
documentation lookup.
an interactive object inspector.
definition finding.
a powerful interactive debugger, which lets the programmer inspect the call stack, fix and recompile a function while the debugger is open and execution is paused, then resume execution from any point in the stack.
the use of restarts in the debugger.
a stepper.
macro expansion,
automatic macro indentation.
cross references: find who calls a function or macro,  who sets a symbol, who depends on a symbol, who references one, who specializes a method, who macroexpands a macro.
manipulating objects through "presentations".
automatic export of symbols
calling the function at point in the REPL.
shortcut commands (print the current working directory, find and install a Quicklisp package, etc.).
a trace facility.
disassembly commands.


=== Remote use ===
SLIME, paired with the Swank back-end, allows to connect to a running Lisp program on another machine.
This allows a programmer to inspect the running program, change parameters, or even to load and compile new code, effectively upgrading the system with no down-time.


== References ==


== External links ==
SLIME project page
Using Emacs as an IDE on the Common Lisp Cookbook.
The birth of SLIME on the cmucl-imp mailing list (August 2003)
SLIME presentation by Tobias Rittweiler (2008) Archived 2011-09-27 at the Wayback Machine
Review of SLIME by Andy Wingo
Bill Clementson's "Slime Tips and Techniques" - Part 1 (See also Part 2, Part 3, Part 4, Part 5, Part 6, and Part 7)
Bill Clementson's "SLIME Refactoring" describes how to set up SLIME
Bill Clementson's "Emacs Keymaps and the SLIME scratch buffer
Bill Clementson's "CL, Music and SLIME Tutorials" contains a good SLIME tutorial
Marco Baringer's (SLIME guru) SLIME setup
Marco Baringer's "Editing Lisp Code with Emacs"
The slime-devel Archives
Up-to-date Swank for MIT/GNU Scheme for use with SLIME CVS