The year 2038 problem (also known as Y2038, Y2K38, Y2K38 superbug, or the Epochalypse) is a time computing problem that leaves some computer systems unable to represent times after 03:14:07 UTC on 19 January 2038.
The problem exists in systems which measure Unix time—the number of seconds elapsed since the Unix epoch (00:00:00 UTC on 1 January 1970)—and store it in a signed 32-bit integer. The data type is only capable of representing integers between −(231) and 231 − 1, meaning the latest time that can be properly encoded is 231 − 1 seconds after epoch (03:14:07 UTC on 19 January 2038). Attempting to increment to the following second (03:14:08) will cause the integer to overflow, setting its value to −(231) which systems will interpret as 231 seconds before epoch (20:45:52 UTC on 13 December 1901). Systems using unsigned 32-bit integers will overflow in 2106. The problem resembles the year 2000 problem but arises from limitations in base-2 (binary) time representation, rather than base-10.
Computer systems that use time for critical computations may encounter fatal errors if the year 2038 problem is not addressed. Some applications that use future dates have already encountered the bug. The most vulnerable systems are those which are infrequently or never updated, such as legacy and embedded systems. Modern systems and software updates to legacy systems address this problem by using signed 64-bit integers instead of 32-bit integers, which will take 292 billion years to overflow—approximately 21 times the estimated age of the universe.


== Cause ==
Many computer systems measure time and date using Unix time, an international standard for digital timekeeping. Unix time is defined as the number of seconds elapsed, ignoring leap seconds, since 00:00:00 UTC on 1 January 1970, known as the Unix epoch.
Unix time has historically been encoded as a signed 32-bit integer, a data type composed of 32 binary digits (bits) which represent an integer value, with 'signed' meaning that the number can represent both positive and negative numbers, as well as zero; and is usually stored in two's complement format. Thus, a signed 32-bit integer can only represent integer values from −(231) to 231 − 1 inclusive. Consequently, if a signed 32-bit integer is used to store Unix time, the latest time that can be stored is 231 − 1 (2,147,483,647)  seconds after epoch, which is 03:14:07 UTC on 19 January 2038. Systems that attempt to increment this value by one more second to 231 seconds after epoch (03:14:08) will suffer integer overflow, inadvertently flipping the sign bit to indicate a negative number. This changes the integer value to −(231), or 231 seconds before epoch rather than after, which systems will interpret as 20:45:52 UTC on 13 December 1901. From here, systems will continue to count up, toward zero, and then up through the positive integers again. As many computer systems use time computations to run critical functions, the bug may introduce serious problems.


== Vulnerable systems ==
Any system using data structures with signed 32-bit time representations has an inherent risk of failing. A full list of these data structures is virtually impossible to derive, but there are well-known data structures that have the Unix time problem:

File systems that use 32 bits to represent times in inodes, such as ext2, ext3, and reiserFS.
Databases with 32-bit time fields.
Database query languages (such as SQL) that have UNIX_TIMESTAMP()-like commands.
Many 32-bit Android devices on Android 4 or earlier, including ZTE Blade, Google Nexus 7 and 2012 Toshiba Android tablets.
OS X-era PowerPC Macs will have their system clock get stuck on the rollover time as of Mac OS X Tiger.
32-bit iOS devices as of iPhone 5 on circa iOS 9 will be unable to unlock or to consistently enter charging mode, and the lockscreen clock will not show up.
As of circa Windows 10 version 22H2, if an x86 (32-bit) device has not been turned on at the rollover point, but is started up after the rollover, the system clock skips ahead to April 12, 2160, and the date options in Windows 10's main settings menu does not show any selectable numbers.
Software built with Visual Studio has the _gmtime32 format (which serves as a mapping of time_t's 32-bit version) roll over at 19 January 2038 00:00:00. Software built with pre-2005 versions of Visual Studio were known to have _gmtime correspond to _gmtime32, and the correspondence can be forced when building with 32-bit versions of Visual Studio through Visual Studio 2019 by specifying _USE_32BIT_TIME_T.


=== Embedded systems ===
Embedded systems that use dates for either computation or diagnostic logging are most likely to be affected by the Y2038 problem. Despite the modern 18–24 month generational update in computer systems technology, embedded systems are designed to last the lifetime of the machine in which they are a component. It is conceivable that some of these systems may still be in use in 2038. It may be difficult or, in some cases, impossible to upgrade the software running these systems, ultimately requiring replacement if the 32-bit limitations are to be corrected.
Many transportation systems, from flight to automobiles, use embedded systems extensively.  In automotive systems, this may include anti-lock braking system (ABS), electronic stability control (ESC/ESP), traction control (TCS), and automatic four-wheel drive; aircraft may use inertial guidance systems and GPS receivers.
Another major use of embedded systems is in communications devices, including cell phones and Internet-enabled appliances (e.g. routers, wireless access points, IP cameras) which rely on storing an accurate time and date and are increasingly based on Unix-like operating systems.
However, this does not imply that all embedded systems will suffer from the Y2038 problem, since many such systems do not require access to dates. For those that do, those systems which only track the difference between times/dates and not absolute times/dates will, by the nature of the calculation, not experience a major problem. This is the case for automotive diagnostics based on legislated standards such as CARB (California Air Resources Board).


== Early problems ==
In May 2006, reports surfaced of an early manifestation of the Y2038 problem in the AOLserver software. The software was designed with a kludge to handle a database request that should "never" time out. Rather than specifically handling this special case, the initial design simply specified an arbitrary time-out date in the future with a default configuration specifying that requests should time out after a maximum of one billion seconds. However, one billion seconds before the 2038 cutoff date is 01:27:28 UTC on 13 May 2006, so requests sent after this time would result in a time-out date which is beyond the cutoff. This made time-out calculations overflow and return dates that were actually in the past, causing software to crash. When the problem was discovered, AOLServer operators had to edit the configuration file and set the time-out to a lower value.
Many types of self-signed CA certificates generated on 32-bit systems can have very long expiration dates that go beyond the rollover point, which will make them not work correctly, affecting HTTPS verifications on services (for instance VPNs) and sites that use them.
The MS Filtering Engine Update anti-malware functions of Microsoft Exchange Server installations broke on January 1, 2022 after an update. The functions mapped the processed UpdateVersion numbers (which used a 9- or 10-digit YY-MM-DD-n format) to the Unix time stamp numbers despite their times being very different, so when the engine received the 220101001 (22-01-01 v001) update, which it took to mean 2201010001 with an extra zero near the end, it tried mapping it to the 32-bit Unix time's number and failed due to being higher than 2147483647. Affected Exchange servers failed to work unless they turned off the anti-malware functions, and an automated fix was published on January 5, 2022.
In Oracle Access Management version 10.1.4.3 for Windows, the Identity Console component sets a cookie containing UI preferences with an expiry of 500,000,000 seconds in the future (approximately 15 years, 312 days). This is beyond 19 January 2038 and so it throws an exception for certain search activities after 02:20:48 UTC on 17 March 2022 because the gmtime_r() call cannot convert the number provided to a date to write to the cookie.
Some versions of Windows Media Player Legacy refuse to run or be set up if the system time is on or after January 1, 2038.


== Solutions ==
There is no universal solution for the Year 2038 problem. For example, in the C language, any change to the definition of the time_t data type would result in code-compatibility problems in any application in which date and time representations are dependent on the nature of the signed 32-bit time_t integer.  Changing time_t to an unsigned 32-bit integer, which would extend the range to 2106 (specifically, 06:28:15 UTC on Sunday, 7 February 2106), would adversely affect programs that store, retrieve, or manipulate dates prior to 1970, as such dates are represented by negative numbers. Increasing the size of the time_t type to 64 bits in an existing system would cause incompatible changes to the layout of structures and the binary interface of functions.
Most operating systems designed to run on 64-bit hardware already use signed 64-bit time_t integers. Using a signed 64-bit value introduces a new wraparound date that is over twenty times greater than the estimated age of the universe: approximately 292 billion years from now. The ability to make computations on dates is limited by the fact that tm_year uses a signed 32-bit integer value starting at 1900 for the year. This limits the year to a maximum of 2,147,485,547 (2,147,483,647 + 1900).
Alternative proposals have been made (some of which are already in use), such as storing either milliseconds or microseconds since an epoch (typically either 1 January 1970 or 1 January 2000) in a signed 64-bit integer, providing a minimum range of 292,000 years at microsecond resolution. In particular, Java's and JavaScript's use of 64-bit signed integers to represent absolute timestamps as "milliseconds since 1 January 1970" will work correctly for the next 292 million years.  Other proposals for new time representations provide different precisions, ranges, and sizes (almost always wider than 32 bits), as well as solving other related problems, such as the handling of leap seconds. In particular, TAI64 is an implementation of the International Atomic Time (TAI) standard, the current international real-time standard for defining a second and frame of reference.


=== Implemented solutions ===
Starting with Ruby version 1.9.2 (released on 18 August 2010), the bug with year 2038 is fixed, by storing time in a signed 64-bit integer on systems with 32-bit time_t.
Starting with NetBSD version 6.0 (released in October 2012), the NetBSD operating system uses a 64-bit time_t for both 32-bit and 64-bit architectures. Applications that were compiled for an older NetBSD release with 32-bit time_t are supported via a binary compatibility layer, but such older applications will still suffer from the Y2038 problem.
OpenBSD since version 5.5, released in May 2014, also uses a 64-bit time_t for both 32-bit and 64-bit architectures. In contrast to NetBSD, there is no binary compatibility layer. Therefore, applications expecting a 32-bit time_t and applications using anything different from time_t to store time values may break.
Linux originally used a 64-bit time_t for 64-bit architectures only; the pure 32-bit ABI was not changed due to backward compatibility. Starting with version 5.6 of 2020, 64-bit time_t is supported on 32-bit architectures, too. This was done primarily for the sake of embedded Linux systems.
GNU C Library since version 2.34 (released August 2021), added support for using 64-bit time_t on 32-bit platforms with appropriate Linux versions. This support can be activated by defining preprocessor macro _TIME_BITS to 64 when compiling source code.
FreeBSD uses 64-bit time_t for all 32-bit and 64-bit architectures except 32-bit i386, which uses signed 32-bit time_t instead.
The x32 ABI for Linux (which defines an environment for programs with 32-bit addresses but running the processor in 64-bit mode) uses a 64-bit time_t. Since it was a new environment, there was no need for special compatibility precautions.
Network File System version 4 has defined its time fields as struct nfstime4 {int64_t seconds; uint32_t nseconds;} since December 2000. Version 3 supports unsigned 32-bit values as struct nfstime3 {uint32 seconds; uint32 nseconds;};. Values greater than zero for the seconds field denote dates after the 0-hour, January 1, 1970. Values less than zero for the seconds field denote dates before the 0-hour, January 1, 1970. In both cases, the nseconds (nanoseconds) field is to be added to the seconds field for the final time representation.
The ext4 filesystem, when used with inode sizes larger than 128 bytes, has an extra 32-bit field per timestamp, of which 30 bits are used for the nanoseconds part of the timestamp, and the other 2 bits are used to extend the timestamp range to the year 2446.
The XFS filesystem, starting with Linux 5.10, has an optional "big timestamps" feature which extends the timestamp range to the year 2486.
While the native APIs of OpenVMS can support timestamps up to 31 July 31086, the C runtime library (CRTL) uses 32-bit integers for time_t. As part of Y2K compliance work that was carried out in 1998, the CRTL was modified to use unsigned 32-bit integers to represent time; extending the range of time_t up to 7 February 2106.
As of MySQL 8.0.28, released in January 2022, the functions FROM_UNIXTIME(), UNIX_TIMESTAMP(), and CONVERT_TZ() handle 64-bit values on platforms that support them. This includes 64-bit versions of Linux, macOS, and Windows. In older versions, built-in functions like UNIX_TIMESTAMP() will return 0 after 03:14:07 UTC on 19 January 2038.
As of MariaDB 11.5.1, released in May 2024, the data type TIMESTAMP and functions FROM_UNIXTIME(), UNIX_TIMESTAMP(), and CONVERT_TZ() handle unsigned 32-bit values on 64-bit versions of Linux, macOS, and Windows. This extended the range to 2106-02-07 06:28:15 and allowed users to store such timestamp values in tables without changing the storage layout and thus staying fully compatible with existing user data.
Starting with Visual C++ 2005, the CRT uses a 64-bit time_t unless the _USE_32BIT_TIME_T preprocessor macro is defined. However, the Windows API itself is unaffected by the year 2038 bug, as Windows internally tracks time as the number of 100-nanosecond intervals since 1 January 1601 in a 64-bit signed integer, which will not overflow until year 30,828.
The OS X rollover stuck system clock bug had been fixed as of Mac OS X El Capitan.
DOSBox-X removed a dependency on the Int32x32To64 macro for time calculation in version 2025.02.01.
For Windows devices whose clocks have jumped ahead, a number of software tools to edit system settings or to sync with time servers exist that can mitigate any effects.
Microsoft's syntax guides for Visual Studio have discouraged the use of _USE_32BIT_TIME_T, and it has not been allowed when building with 64-bit versions of Visual Studio.
Despite the age of the Oracle Access Manager version in question (18 June 2009), Oracle issued the patch 33983548 on 6 April 2022. Newer versions of Oracle Access Manager are not known to be affected by the problem.


== See also ==
Time formatting and storage bugs lists other similar problems, often caused by rollover similar to the cause of this year 2038 problem.
A GPS week number rollover will coincidentally happen later in 2038, but for a different reason.
A rollover in Network Time Protocol version 3 and earlier in 2036 is very similar to the 2038 problem, but is not identical.


== Notes ==


== References ==


== External links ==
Y2038 Proofness Design glibc Wiki
Entry in How Stuff Works
The Project 2038 Frequently Asked Questions
Critical and Significant Dates 2038 Archived 7 November 2020 at the Wayback Machine
A 2038-safe replacement for time.h on 32 bit systems
"Solving the Year 2038 problem in the Linux kernel".
Baraniuk, Chris (5 May 2015). "The number glitch that can lead to catastrophe". BBC Future.
Clewett, James. "2,147,483,647 – The End of Time [Unix]". Numberphile. Brady Haran. Archived from the original on 22 May 2017. Retrieved 7 April 2013.