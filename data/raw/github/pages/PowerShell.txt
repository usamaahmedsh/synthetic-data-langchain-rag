PowerShell is a shell program developed by Microsoft for task automation and configuration management. As is typical for a shell, it provides a command-line interpreter for interactive use and a script interpreter for automation via a language defined for it. Originally only for Windows, known as Windows PowerShell, it was made open-source and cross-platform on August 18, 2016, with the introduction of PowerShell Core. The former is built on the .NET Framework; the latter on .NET (previously .NET Core).
PowerShell is bundled with current versions of Windows and can be installed on macOS and Linux. Since Windows 10 build 14971, PowerShell replaced Command Prompt as the default command shell exposed by File Explorer.
In PowerShell, administrative tasks are generally performed via cmdlets (pronounced command-lets), which are specialized .NET classes implementing a particular operation. These work by accessing data in different data stores, like the file system or Windows Registry, which are made available to PowerShell via providers. Third-party developers can add cmdlets and providers to PowerShell. Cmdlets may be used by scripts, which may in turn be packaged into modules. Cmdlets work in tandem with the .NET API.
PowerShell's support for .NET Remoting, WS-Management, CIM, and SSH enables administrators to perform administrative tasks on both local and remote Windows systems. PowerShell also provides a hosting API with which the PowerShell runtime can be embedded inside other applications. These applications can then use PowerShell functionality to implement certain operations, including those exposed via the graphical interface. This capability has been used by Microsoft Exchange Server 2007 to expose its management functionality as PowerShell cmdlets and providers and implement the graphical management tools as PowerShell hosts which invoke the necessary cmdlets. Other Microsoft applications including Microsoft SQL Server 2008 also expose their management interface via PowerShell cmdlets.
PowerShell includes its own extensive, console-based help (similar to man pages in Unix shells) accessible via the Get-Help cmdlet. Updated local help contents can be retrieved from the Internet via the Update-Help cmdlet. Alternatively, help from the web can be acquired on a case-by-case basis via the -online switch to Get-Help.


== Background ==
Shell programs, including PowerShell, trace lineage to shells in older operating systems such as MS-DOS and Xenix which exposed system functionality to the user almost exclusively via a command-line interface (CLI) – although MS-DOS 5 also came with a complementary graphical DOS Shell. The Windows 9x family came bundled with COMMAND.COM, the command-line environment of MS-DOS. The Windows NT and Windows CE families, however, came with the newer cmd.exe – a significant upgrade from COMMAND.COM. Both environments provide CLI for both internal and external commands and automation via batch files – a relatively primitive language for scripting.
To address limitations of these shells – including the inability to directly use a software component exposed via COM – Microsoft introduced the Windows Script Host in 1998 with Windows 98, and its command-line based host, cscript.exe. It integrates with the Active Script engine and allows scripts to be written in compatible languages, such as JScript and VBScript. These scripts can use COM components directly, but it has relatively inaccessible documentation and gained a reputation as a system vulnerability vector after several high-profile computer viruses exploited weaknesses in its security provisions. 
Different versions of Windows provided various special-purpose command-line interpreters (such as netsh and WMIC) with their own command sets but they were not interoperable. Windows Server 2003 further attempted to improve the command-line experience but scripting support was still unsatisfactory.


=== Kermit ===

By the late 1990s, Intel had come to Microsoft asking for help in making Windows, which ran on Intel CPUs, a more appropriate platform to support the development of future Intel CPUs. At the time, Intel CPU development was accomplished on Sun Microsystems computers which ran Solaris (a Unix variant) on RISC-architecture CPUs. The ability to run Intel's many KornShell automation scripts on Windows was identified as a key capability. Internally, Microsoft began an effort to create a Windows port of Korn Shell, which was code-named Kermit. Intel ultimately pivoted to a Linux-based development platform that could run on Intel CPUs, rendering the Kermit project redundant. However, with a fully funded team, Microsoft program manager Jeffrey Snover realized there was an opportunity to create a more general-purpose solution to Microsoft's problem of administrative automation.


=== Monad ===
By 2002, Microsoft had started to develop a new approach to command-line management, including a CLI called Monad (also known as Microsoft Shell or MSH). The ideas behind it were published in August 2002 in a white paper called the "Monad Manifesto" by its chief architect, Jeffrey Snover. In a 2017 interview, Snover explains the genesis of PowerShell, saying that he had been trying to make Unix tools available on Windows, which didn't work due to "core architectural difference[s] between Windows and Linux". Specifically, he noted that Linux considers everything a text file, whereas Windows considers everything an "API that returns structured data". They were fundamentally incompatible, which led him to take a different approach.
Monad was to be a new extensible CLI with a fresh design capable of automating a range of core administrative tasks. Microsoft first demonstrated Monad publicly at the Professional Development Conference in Los Angeles in October 2003. A few months later, they opened up private beta, which eventually led to a public beta. Microsoft published the first Monad public beta release on June 17, 2005, and the Beta 2 on September 11, 2005, and Beta 3 on January 10, 2006.


=== PowerShell ===

On April 25, a year and a half after the initial Monad announcement, Microsoft announced that Monad had been renamed Windows PowerShell, positioning it as a significant part of its management technology offerings.  Release Candidate (RC) 1 of PowerShell was released at the same time. A significant aspect of both the name change and the RC was that this was now a component of Windows, rather than a mere add-on.
Release Candidate 2 of PowerShell version 1 was released on September 26, 2006, with final release to the web on November 14, 2006. PowerShell for earlier versions of Windows was released on January 30, 2007. PowerShell v2.0 development began before PowerShell v1.0 shipped. During the development, Microsoft shipped three community technology previews (CTP). Microsoft made these releases available to the public. The last CTP release of Windows PowerShell v2.0 was made available in December 2008.
PowerShell v2.0 was completed and released to manufacturing in August 2009, as an integral part of Windows 7 and Windows Server 2008 R2. Versions of PowerShell for Windows XP, Windows Server 2003, Windows Vista and Windows Server 2008 were released in October 2009 and are available for download for both 32-bit and 64-bit platforms. In an October 2009 issue of TechNet Magazine, Microsoft called proficiency with PowerShell "the single most important skill a Windows administrator will need in the coming years".
Windows 10 shipped with Pester, a script validation suite for PowerShell.

On August 18, 2016, Microsoft announced that they had made PowerShell open-source and cross-platform with support for Windows, macOS, CentOS and Ubuntu. The source code was published on GitHub. The move to open source created a second incarnation of PowerShell called "PowerShell Core", which runs on .NET Core. It is distinct from "Windows PowerShell", which runs on the full .NET Framework. Starting with version 5.1, PowerShell Core is bundled with Windows Server 2016 Nano Server.


=== Pash ===
A project named Pash, a pun on the widely known "bash" Unix shell, has been an open-source and cross-platform reimplementation of PowerShell via the Mono framework. Pash was created by Igor Moochnick, written in C# and was released under the GNU General Public License. Pash development stalled in 2008, was restarted on GitHub in 2012, and finally ceased in 2016 when PowerShell was officially made open-source and cross-platform.


== Design ==


=== Philosophy ===
A key design goal for PowerShell was to leverage the large number of APIs that already existed in Windows, Windows Management Instrumentation, .NET Framework, and other software. PowerShell cmdlets generally wrap and expose existing functionality instead of implementing new functionality. The intent was to provide an administrator-friendly, more-consistent interface between administrators and a wide range of underlying functionality. With PowerShell, an administrator doesn't need to know .NET, WMI, or low-level API coding, and can instead focus on using the cmdlets exposed by PowerShell. In this regard, PowerShell creates little new functionality, instead focusing on making existing functionality more accessible to a particular audience.


=== Grammar ===
PowerShell's developers based the core grammar of the tool on that of the POSIX 1003.2 KornShell.
However, PowerShell's language was also influenced by PHP, Perl, and many other existing languages.


=== Named commands ===
PowerShell can execute four kinds of named commands:

cmdlets (.NET Framework programs designed to interact with PowerShell)
PowerShell scripts (files suffixed by .ps1)
PowerShell functions
Standalone executable programs
If a command is a standalone executable program, PowerShell launches it in a separate process; if it is a cmdlet, it executes in the PowerShell process. PowerShell provides an interactive command-line interface, where the commands can be entered and their output displayed. The user interface offers customizable tab completion. PowerShell enables the creation of aliases for cmdlets, which PowerShell textually translates into invocations of the original commands.  PowerShell supports both named and positional parameters for commands. In executing a cmdlet, the job of binding the argument value to the parameter is done by PowerShell itself, but for external executables, arguments are parsed by the external executable independently of PowerShell interpretation.


=== Extended Type System ===
The PowerShell Extended Type System (ETS) is based on the .NET type system, but with extended semantics (for example, propertySets and third-party extensibility). For example, it enables the creation of different views of objects by exposing only a subset of the data fields, properties, and methods, as well as specifying custom formatting and sorting behavior. These views are mapped to the original object using XML-based configuration files.


=== Cmdlets ===
A cmdlet is a .NET class that derives either from Cmdlet or from PSCmdlet; the latter used when it needs to interact with the PowerShell runtime. The base classes specify methods – BeginProcessing(), ProcessRecord() and EndProcessing() – which a cmdlet overrides to provide functionality based on the events that these functions represent. ProcessRecord() is called if the object receives pipeline input. If a collection of objects is piped, the method is invoked for each object in the collection. The cmdlet class must have the attribute CmdletAttribute which specifies the verb and the noun that make up the name of the cmdlet.
A cmdlet name follows a Verb-Noun naming pattern, such as Get-ChildItem, which tends to make it self-documented. Common verbs are provided as an enum.
If a cmdlet receives either pipeline input or command-line parameter input, there must be a corresponding property in the class, with a mutator implementation. PowerShell invokes the mutator with the parameter value or pipeline input, which is saved by the mutator implementation in class variables. These values are then referred to by the methods which implement the functionality. Properties that map to command-line parameters are marked by ParameterAttribute and are set before the call to BeginProcessing(). Those which map to pipeline input are also flanked by ParameterAttribute, but with the ValueFromPipeline attribute parameter set.
A cmdlet can use any .NET API and may be written in any .NET language. In addition, PowerShell makes certain APIs available, such as WriteObject(), which is used to access PowerShell-specific functionality, such as writing objects to the pipeline. A cmdlet can use .NET a data access API directly or use the PowerShell infrastructure of Providers, which make data stores addressable using unique paths. Data stores are exposed using drive letters, and hierarchies within them, addressed as directories. PowerShell ships with providers for the file system, registry, the certificate store, as well as the namespaces for command aliases, variables, and functions. PowerShell also includes various cmdlets for managing various Windows systems, including the file system, or using Windows Management Instrumentation to control Windows components. Other applications can register cmdlets with PowerShell, thus allowing it to manage them, and, if they enclose any datastore (such as a database), they can add specific providers as well.
A cmdlet can be added to the shell via modules or before v2 snap-ins. Users are not limited to the cmdlets included in the base PowerShell installation.
The number of cmdlets included in the base PowerShell install for various versions:

Windows PowerShell 1.0: 129
Windows PowerShell 2.0: 632
Windows PowerShell 3.0: ≈1,000
Windows PowerShell 5.0: ≈1,300
Windows PowerShell 5.1: 1,586
PowerShell 7.0: 1,507
PowerShell 7.4: 1,656


=== Pipeline ===
To enable pipeline semantics, similar to the Unix pipeline, a cmdlet receives input and outputs result as objects. If a cmdlet outputs multiple objects, each object of the collection is passed through the pipeline before the next object is processed. A PowerShell pipeline enables complex logic using the pipe (|) operator to connect stages. However, the PowerShell pipeline differs from Unix pipelines in that stages execute within the PowerShell runtime rather than as a set of processes coordinated by the operating system. Additionally, structured .NET objects, rather than byte streams, are passed from one stage to the next. Using objects and executing stages within the PowerShell runtime eliminates the need to serialize data structures, or to extract them by explicitly parsing text output. An object can also encapsulate certain functions that work on the contained data, which become available to the recipient command for use. For the last cmdlet in a pipeline, PowerShell automatically pipes its output object to the Out-Default cmdlet, which transforms the objects into a stream of format objects and then renders those to the screen.
Because a PowerShell object is a .NET object, it has a .ToString() method which is used to serialize object state. In addition, PowerShell allows formatting definitions to be specified, so the text representation of objects can be customized by choosing which data elements to display, and in what manner. However, in order to maintain backward compatibility, if an external executable is used in a pipeline, it receives a text stream representing the object, instead of directly integrating with the PowerShell type system.


=== Scripting ===
PowerShell includes a dynamically typed language for scripting which can implement complex operations using cmdlets imperatively. The language supports variables, functions, branching (if-then-else), loops (while, do, for, and foreach), structured error/exception handling and closures/lambda expressions, as well as integration with .NET. Variables in PowerShell scripts are prefixed with $.  Variables can be assigned any value, including the output of cmdlets. Strings can be enclosed either in single quotes or in double quotes: when using double quotes, variables will be expanded even if they are inside the quotation marks. Enclosing the path to a file in braces preceded by a dollar sign (as in ${C:\foo.txt}), known as namespace variable notation, creates a reference to the contents of the file. If it is used as an L-value, anything assigned to it will be written to the file. When used as an R-value, the contents of the file will be read. If an object is assigned, it is serialized before being stored.

Object members can be accessed using . notation, as in C# syntax. PowerShell provides special variables, such as $args, which is an array of all the command-line arguments passed to a function from the command line, and $_, which refers to the current object in the pipeline. PowerShell also provides arrays and associative arrays. The PowerShell language also evaluates arithmetic expressions entered on the command line immediately, and it parses common abbreviations, such as GB, MB, and KB.
Using the function keyword, PowerShell provides for the creation of functions. A simple function has the following general look:

However, PowerShell allows for advanced functions that support named parameters, positional parameters, switch parameters and dynamic parameters.

The defined function is invoked in either of the following forms:

PowerShell allows any static .NET methods to be called by providing their namespaces enclosed in brackets ([]), and then using a pair of colons (::) to indicate the static method. For example:There are dozens of ways to create objects in PowerShell. Once created, one can access the properties and instance methods of an object using the . notation.
PowerShell accepts strings, both raw and escaped. A string enclosed between single quotation marks is a raw string while a string enclosed between double quotation marks is an escaped string. PowerShell treats straight and curly quotes as equivalent.
The following list of special characters is supported by PowerShell:

For error handling, PowerShell provides a .NET-based exception-handling mechanism. In case of errors, objects containing information about the error (Exception object) are thrown, which are caught using the try ... catch construct (although a trap construct is supported as well). PowerShell can be configured to silently resume execution, without actually throwing the exception; this can be done either on a single command, a single session or perpetually.
Scripts written using PowerShell can be made to persist across sessions in either a .ps1 file or a .psm1 file (the latter is used to implement a module). Later, either the entire script or individual functions in the script can be used. Scripts and functions operate analogously with cmdlets, in that they can be used as commands in pipelines, and parameters can be bound to them. Pipeline objects can be passed between functions, scripts, and cmdlets seamlessly. To prevent unintentional running of scripts, script execution is disabled by default and must be enabled explicitly. Enabling of scripts can be performed either at system, user or session level. PowerShell scripts can be signed to verify their integrity, and are subject to Code Access Security.
The PowerShell language supports binary prefix notation similar to the scientific notation supported by many programming languages in the C-family.


=== Hosting ===
One can also use PowerShell embedded in a management application, which uses the PowerShell runtime to implement the management functionality. For this, PowerShell provides a managed hosting API. Via the APIs, the application can instantiate a runspace (one instantiation of the PowerShell runtime), which runs in the application's process and is exposed as a Runspace object. The state of the runspace is encased in a SessionState object. When the runspace is created, the PowerShell runtime initializes the instantiation, including initializing the providers and enumerating the cmdlets, and updates the SessionState object accordingly. The Runspace then must be opened for either synchronous processing or asynchronous processing. After that it can be used to execute commands.
To execute a command, a pipeline (represented by a Pipeline object) must be created and associated with the runspace. The pipeline object is then populated with the cmdlets that make up the pipeline. For sequential operations (as in a PowerShell script), a Pipeline object is created for each statement and nested inside another Pipeline object. When a pipeline is created, PowerShell invokes the pipeline processor, which resolves the cmdlets into their respective assemblies (the command processor) and adds a reference to them to the pipeline, and associates them with InputPipe, OutputPipe and ErrorOutputPipe objects, to represent the connection with the pipeline. The types are verified and parameters bound using reflection. Once the pipeline is set up, the host calls the Invoke() method to run the commands, or its asynchronous equivalent, InvokeAsync(). If the pipeline has the Write-Host cmdlet at the end of the pipeline, it writes the result onto the console screen. If not, the results are handed over to the host, which might either apply further processing or display the output itself.
Microsoft Exchange Server 2007 uses the hosting APIs to provide its management GUI. Each operation exposed in the GUI is mapped to a sequence of PowerShell commands (or pipelines). The host creates the pipeline and executes them. In fact, the interactive PowerShell console itself is a PowerShell host, which interprets the scripts entered at command line and creates the necessary Pipeline objects and invokes them.


=== Desired State Configuration ===
DSC allows for declaratively specifying how a software environment should be configured.
Upon running a configuration, DSC will ensure that the system gets the state described in the configuration. DSC configurations are idempotent.  The Local Configuration Manager (LCM) periodically polls the system using the control flow described by resources (imperative pieces of DSC) to make sure that the state of a configuration is maintained.


== Versions ==
All major releases are still supported, and each major release has featured backwards compatibility with preceding versions.


=== Project Monad ===
Initially using the code name "Monad", PowerShell was first shown publicly at the Professional Developers Conference in October 2003 in Los Angeles. 


=== Windows PowerShell ===


==== 1.0 ====
Named Windows PowerShell, version 1.0 was released in November 2006 for Windows XP SP2, Windows Server 2003 SP1 and Windows Vista and as an optional component of Windows Server 2008.


==== 2.0 ====

Version 2.0 integrates with Windows 7 and Windows Server 2008 R2 and is released for Windows XP with Service Pack 3, Windows Server 2003 with Service Pack 2, and Windows Vista with Service Pack 1.
The version includes changes to the language and hosting API, in addition to including more than 240 new cmdlets.
New features include:

Remoting: Using WS-Management, Allows scripts and cmdlets to be invoked on a remote machine or a large set of remote machines.
Background jobs: Also called a PSJob, it allows a command sequence (script) or pipeline to be invoked asynchronously.  Jobs can be run on the local machine or on multiple remote machines. An interactive cmdlet in a PSJob blocks the execution of the job until user input is provided.
Transactions: Enable cmdlet and developers can perform transactional operations. Includes transaction cmdlets for starting, committing, and rolling back a PSTransaction as well as features to manage and direct the transaction to the participating cmdlet and provider operations. The PowerShell Registry provider supports transactions.
Advanced functions: Initially called "script cmdlets", these bundled cmdlets was later renamed "advanced functions".
SteppablePipelines: This allows the user to control when the BeginProcessing(), ProcessRecord() and EndProcessing() functions of a cmdlet are called.
Modules: Allows script developers and administrators to organize and partition scripts in self-contained, reusable units. Code from a module executes in its own self-contained context and does not affect the state outside the module. Modules can define a restricted runspace environment by using a script. They have a persistent state as well as public and private members.
Data language: A domain-specific subset of the language that allows data definitions to be decoupled from the scripts and allows localized string resources to be imported into the script at runtime (Script Internationalization).
Script debugging: Allows breakpoints to be set in a script or function. Breakpoints can be set on lines, line & columns, commands and read or write access of variables.  It includes a set of cmdlets to control the breakpoints via script.
Eventing: Allows listening, forwarding, and acting on management and system events. Eventing allows hosts to be notified about state changes to their managed entities. It also enables scripts to subscribe to ObjectEvents, PSEvents, and WmiEvents and process them synchronously and asynchronously.
Integrated Scripting Environment (ISE): GUI-based host that provides integrated debugger, syntax highlighting, tab completion and up to 8 Unicode-enabled consoles (Runspaces) in a tabbed UI, as well as the ability to run only the selected parts in a script.
Network file transfer: Native support for prioritized, throttled, and asynchronous transfer of files between machines using the Background Intelligent Transfer Service (BITS).
New cmdlets: Including Out-GridView, which displays tabular data in the WPF GridView object, on systems that allow it, and if ISE is installed and enabled.
New operators: -Split, -Join, and Splatting (@) operators.
Exception handling with Try-Catch-Finally: Unlike other .NET languages, this allows multiple exception types for a single catch block.
Nestable Here-Strings: Here-Strings have been improved and can now nest.
Block comments: Support for block comments using <# and #> as delimiters.
New APIs: The new APIs range from handing more control over the parser and runtime to the host, to creating and managing collection of Runspaces (RunspacePools) as well as the ability to create Restricted Runspaces which only allow a configured subset of PowerShell to be invoked. The new APIs also support participation in a transaction


==== 3.0 ====
Version 3.0 integrates with Windows 8, Windows Server 2012, Windows 7 with Service Pack 1, Windows Server 2008 with Service Pack 1, and Windows Server 2008 R2 with Service Pack 1.
Version 3.0 is part of a larger package, Windows Management Framework 3.0 (WMF3), which also contains the WinRM service to support remoting. Microsoft made several Community Technology Preview releases of WMF3. An early community technology preview 2 (CTP 2) version of Windows Management Framework 3.0 was released on December 2, 2011. Windows Management Framework 3.0 was released for general availability in December 2012 and is included with Windows 8 and Windows Server 2012 by default.
New features include:

Scheduled jobs: Jobs can be scheduled to run on a preset time and date using the Windows Task Scheduler infrastructure.
Session connectivity: Sessions can be disconnected and reconnected. Remote sessions have become more tolerant of temporary network failures.
Improved code writing: Code completion (IntelliSense) and snippets are added. ISE allows users to use dialog boxes to fill in parameters for cmdlets.
Delegation support: Administrative tasks can be delegated to users who do not have permissions for that type of task, without granting them perpetual additional permissions.
Help update: Help documentations can be updated via Update-Help command.
Automatic module detection: Modules are loaded implicitly whenever a command from that module is invoked. Code completion works for unloaded modules as well.
New commands: Dozens of new modules were added, including functionality to manage disks get-WmiObject win32_logicaldisk, volumes, firewalls, network connections, and printers, which had previously been performed via WMI.


==== 4.0 ====
Version 4.0 integrates with Windows 8.1, Windows Server 2012 R2, Windows 7 SP1, Windows Server 2008 R2 SP1 and Windows Server 2012.
New features include:

Desired State Configuration: Declarative language extensions and tools that enable the deployment and management of configuration data for systems using the DMTF management standards and WS-Management Protocol
New default execution policy: On Windows Servers, the default execution policy is now RemoteSigned.
Save-Help: Help can now be saved for modules that are installed on remote computers.
Enhanced debugging: The debugger now supports debugging workflows, remote script execution and preserving debugging sessions across session reconnections.
-PipelineVariable switch: A new ubiquitous parameter to expose the current pipeline object as a variable for programming purposes
Network diagnostics to manage physical and Hyper-V's virtualized network switches
Where and ForEach method syntax provides an alternate method of filtering and iterating over objects.


==== 5.0 ====

Version 5.0 was re-released with Windows Management Framework (WMF) 5.0 on February 24, 2016, following an initial release with a severe bug.
Key features included:

The new class keyword that creates classes for object-oriented programming
The new enum keyword that creates enums
OneGet cmdlets to support the Chocolatey package manager
Extending support for switch management to layer 2 network switches.
Debugging for background jobs and instances hosted in other processes (each of which is called a "runspace")
Desired State Configuration (DSC) Local Configuration Manager (LCM) version 2.0
DSC partial configurations
DSC Local Configuration Manager meta-configurations
Authoring of DSC resources using classes


===== 5.1 =====
Version 5.1 was released along with the Windows 10 Anniversary Update on August 2, 2016, and in Windows Server 2016. PackageManagement now supports proxies, PSReadLine now has ViMode support, and two new cmdlets were added: Get-TimeZone and Set-TimeZone. The LocalAccounts module allows for adding/removing local user accounts. A preview for was released for Windows 7, Windows Server 2008, Windows Server 2008 R2, Windows Server 2012, and Windows Server 2012 R2 on July 16, 2016, and was released on January 19, 2017.
Version 5.1 is the first to come in two editions of "Desktop" and "Core". The "Desktop" edition is the continuation product line that uses the .NET Framework, and the "Core" edition runs on .NET Core and is bundled with Windows Server 2016 Nano Server. In exchange for smaller footprint, the latter lacks some features such as the cmdlets to manage clipboard or join a computer to a domain, WMI version 1 cmdlets, Event Log cmdlets and profiles. This was the final version exclusively for Windows. Version 5.1 remains pre-installed on Windows 10, Windows 11 and Windows Server 2022, while the .NET version needs to be installed separately and can run side-by-side with the .NET Framework version.


=== PowerShell Core ===


==== 6.0 ====
Renamed to PowerShell Core, version 6.0 was first announced on August 18, 2016, when Microsoft unveiled its decision to make the product cross-platform, independent of Windows, free and open source. It achieved general availability on January 10, 2018, for Windows, macOS and Linux. It has its own support lifecycle and adheres to the Microsoft lifecycle policy that is introduced with Windows 10: Only the latest version of PowerShell Core is supported. Microsoft expects to release one minor version for PowerShell Core 6.0 every six months.
The most significant change in this version is the expansion to the other platforms. For Windows administrators, this version did not include any major new features. In an interview with the community on January 11, 2018, the development team was asked to list the top 10 most exciting things that would happen for a Windows IT professional who would migrate from version 5.1 to version 6.0. In response, Angel Calvo of Microsoft could only name two: cross-platform and open-source. PowerShell 6 changed to UTF-8 as default encoding, with some exceptions. (version 7.4 changes more to UTF-8)


===== 6.1 =====
According to Microsoft, one of the new features of version 6.1 is "Compatibility with 1900+ existing cmdlets in Windows 10 and Windows Server 2019." Still, no details of these cmdlets can be found in the full version of the change log. Microsoft later professes that this number was insufficient as PowerShell Core failed to replace Windows PowerShell 5.1 and gain traction on Windows. It was, however, popular on Linux.


===== 6.2 =====
Version 6.2 is focused primarily on performance improvements, bug fixes, and smaller cmdlet and language enhancements that improved developer productivity.


=== PowerShell ===


==== 7.0 ====
Renamed to simply PowerShell, version 7 replaces the previous product lines: PowerShell Core and Windows PowerShell. The focus in development was to make version 7 a viable replacement for version 5.1, i.e. to have near parity with it in terms of compatibility with modules that ship with Windows.
New features include:

The -Parallel switch for the ForEach-Object cmdlet to help handle parallel processing
A new error view
The Get-Error cmdlet
Pipeline chaining operators (&& and ||) that allow conditional execution of the next cmdlet in the pipeline
The ?: operator for ternary operation
The ?? operator for null coalescing
The ??= operator for null coalescing assignment
Cross-platform Invoke-DscResource (experimental)
Return of the Out-GridView cmdlet
Return of the -ShowWindow switch for the Get-Help


===== 7.2 =====
Version 7.2 is the next long-term support version, after version 7.0. It uses .NET 6.0 and features universal installer packages for Linux. On Windows, updates to version 7.2 and later come via the Microsoft Update service; this feature has been missing from versions 6.0 through 7.1.


===== 7.3 =====
Version 7.3 includes some general Cmdlet updates and fixes, testing for framework dependent package in release pipeline as well as build and packaging improvements.


===== 7.4 =====
Version 7.4 is based on .NET 8 and is considered the long term support (LTS) release.
Changes include:

webcmdlets default to UTF-8 encoding (changing from ASCII-superset ISO-8859-1, that does not support Unicode). Previously UTF-8 was default for other, but not all, things.


===== 7.5 =====
Version 7.5, is the latest stable release; released January 2025; built on .NET 9.0.1. It includes enhancements for performance, usability, and security. Key updates include improvements to tab completion, such as better type inference and new argument completers, as well as fixes for Invoke-WebRequest and Invoke-RestMethod. This release also adds the new ConvertTo-CliXml and ConvertFrom-CliXml cmdlets, and updates core modules like PSReadLine and Microsoft.PowerShell.PSResourceGet. Breaking changes include updates to Test-Path parameter handling, and default settings for New-FileCatalog.
Prior to GA Release there were 5 preview releases and 1 RC release of PowerShell v7.5.0, with a full release blog post for this version expected soon.


===== 7.6 =====
Version 7.6 is based on .NET 9 and is the latest preview release. The first preview release v7.6.0-preview.2 was released on January 15, 2025.
Changes include: TBD


== Comparison of cmdlets with similar commands ==
The following table contains various cmdlets that ship with PowerShell that have notably similar functionality to commands in other shells. Many of these cmdlets are exposed to the user via predefined aliases to make their use familiar to users of the other shells.

Notes


== Filename extensions ==


== Application support ==


== See also ==
Common Information Model (computing)
Comparison of command shells
Comparison of programming languages
Web-Based Enterprise Management
Windows Script Host
Windows Terminal


== References ==


== Further reading ==
Finke, Douglas (2012). Windows PowerShell for Developers. O'Reilly Media. ISBN 978-1-4493-2270-0.
Holmes, Lee (2006). Windows PowerShell Quick Reference. O'Reilly Media. ISBN 0-596-52813-2.
Holmes, Lee (2007). Windows PowerShell Cookbook. O'Reilly Media. ISBN 978-0-596-52849-2.
Jones, Don; Hicks, Jeffery (2010). Windows PowerShell 2.0: TFM (3rd ed.). Sapien Technologies. ISBN 978-0-9821314-2-8.
Jones, Don (2020). Shell of an Idea: The Untold History of PowerShell. Self-published. ISBN 978-1-9536450-3-6.
Kopczynski, Tyson; Handley, Pete; Shaw, Marco (2009). Windows PowerShell Unleashed (2nd ed.). Pearson Education. ISBN 978-0-672-32988-3.
Kumaravel, Arul; White, Jon; Naixin Li, Michael; Happell, Scott; Xie, Guohui; Vutukuri, Krishna C. (2008). Professional Windows PowerShell Programming: Snapins, Cmdlets, Hosts and Providers. Wrox Press. ISBN 978-0-470-17393-0.
Oakley, Andy (2005). Monad (AKA PowerShell). O'Reilly Media. ISBN 0-596-10009-4.
Watt, Andrew (2007). Professional Windows PowerShell. Wrox Press. ISBN 978-0-471-94693-9.
Wilson, Ed (2013). Windows PowerShell 3.0 Step by Step. Microsoft Press. ISBN 978-0-7356-6339-8.
Wilson, Ed (2014). Windows PowerShell Best Practices. Microsoft Press. ISBN 978-0-7356-6649-8.


== External links ==

Official website 
PowerShell on GitHub
Windows PowerShell Survival Guide Archived September 15, 2012, at the Wayback Machine on TechNet Wiki