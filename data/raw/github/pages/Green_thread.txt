In computer programming, a green thread is a thread that is scheduled by a runtime library or virtual machine (VM) instead of natively by the underlying operating system (OS). Green threads emulate multithreaded environments without relying on any native OS abilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support.


== Etymology ==
Green threads refers to the name of the original thread library for Java programming language (that was released in version 1.1 and then Green threads were abandoned in version 1.3 to native threads). It was designed by The Green Team at Sun Microsystems.


== History ==
Green threads were briefly available in Java between 1997 and 2000.
Green threads share a single operating system thread through co-operative concurrency and can therefore not achieve parallelism performance gains like operating system threads. The main benefit of coroutines and green threads is ease of implementation.


== Performance ==

On a multi-core processor, native thread implementations can automatically assign work to multiple processors, whereas green thread implementations normally cannot. Green threads can be started much faster on some VMs. On uniprocessor computers, however, the most efficient model has not yet been clearly determined.
Benchmarks on computers running the Linux kernel version 2.2 (released in 1999) have shown that:

Green threads significantly outperform Linux native threads on thread activation and synchronization.
Linux native threads have slightly better performance on input/output (I/O) and context switching operations.
When a green thread executes a blocking system call, not only is that thread blocked, but all of the threads within the process are blocked. To avoid that problem, green threads must use non-blocking I/O or asynchronous I/O operations, although the increased complexity on the user side can be reduced if the virtual machine implementing the green threads spawns specific I/O processes (hidden to the user) for each I/O operation.
There are also mechanisms which allow use of native threads and reduce the overhead of thread activation and synchronization:

Thread pools reduce the cost of spawning a new thread by reusing a limited number of threads.
Languages which use virtual machines and native threads can use escape analysis to avoid synchronizing blocks of code when unneeded.


== Green threads in the Java Virtual Machine ==
In Java 1.1, green threads were the only threading model used by the Java virtual machine (JVM), at least on Solaris. As green threads have some limitations compared to native threads, subsequent Java versions dropped them in favor of native threads.
An exception to this is the Squawk virtual machine, which is a mixture between an operating system for low-power devices and a Java virtual machine. It uses green threads to minimize the use of native code, and to support migrating its isolates.
Kilim and Quasar
are open-source projects which implement green threads on later versions of the JVM by modifying the Java bytecode produced by the Java compiler (Quasar also supports Kotlin and Clojure).


== Green threads in other languages ==
There are some other programming languages that implement equivalents of green threads instead of native threads. Examples:

C (POSIX) In C for POSIX systems, makecontext provides for lightweight co-operative threads. Not included in POSIX.1-2008 specifications due to differences among systems.
Chicken Scheme uses lightweight user-level threads based on first-class continuations
Common Lisp
CPython natively supports asyncio since Version 3.4, alternative implementations exist like greenlet, eventlet and gevent, PyPy
Crystal offers fibers
D offers fibers, used for asynchronous I/O
Dyalog APL terms them threads
Erlang
Go implements so called goroutines
Haskell
Julia uses green threads for its Tasks.
Limbo
Lua uses coroutines for concurrency. Lua 5.2 also offers true C coroutine semantics through the functions lua_yieldk, lua_callk, and lua_pcallk. The CoCo extension allows true C coroutine semantics for Lua 5.1.
Nim provides asynchronous I/O and coroutines
OCaml, since version 5.0, supports green threads through the Domainslib.Task module
occam, which prefers the term process instead of thread due to its origins in communicating sequential processes
Perl supports green threads through coroutines
PHP supports green threads through fibers and coroutines
Racket (native threads are also available through Places)
Ruby before version 1.9
SML/NJ's implementation of Concurrent ML
Smalltalk (most dialects: Squeak, VisualWorks, GNU Smalltalk, etc.)
Stackless Python supports either preemptive multitasking or cooperative multitasking through microthreads (termed tasklets).
Tcl has coroutines and an event loop
The Erlang virtual machine has what might be called green processes â€“ they are like operating system processes (they do not share state like threads do) but are implemented within the Erlang Run Time System (erts). These are sometimes termed green threads, but have significant differences from standard green threads.
In the case of GHC Haskell, a context switch occurs at the first allocation after a configurable timeout. GHC threads are also potentially run on one or more OS threads during their lifetime (there is a many-to-many relationship between GHC threads and OS threads), allowing for parallelism on symmetric multiprocessing machines, while not creating more costly OS threads than needed to run on the available number of cores.
Most Smalltalk virtual machines do not count evaluation steps; however, the VM can still preempt the executing thread on external signals (such as expiring timers, or I/O becoming available). Usually round-robin scheduling is used so that a high-priority process that wakes up regularly will effectively implement time-sharing preemption:

Other implementations, e.g., QKS Smalltalk, are always time-sharing. Unlike most green thread implementations, QKS also supports preventing priority inversion.


== Differences to virtual threads in the Java Virtual Machine ==
Virtual threads were introduced as a preview feature in Java 19 and stabilized in Java 21. Important differences between virtual threads and green threads are:

Virtual threads coexist with existing (non-virtual) platform threads and thread pools.
Virtual threads protect their abstraction:
Unlike with green threads, sleeping on a virtual thread does not block the underlying carrier thread.
Working with thread-local variables is deemphasized, and scoped values are suggested as a more lightweight replacement.
Virtual threads can be cheaply suspended and resumed, making use of JVM support for the special jdk.internal.vm.Continuation class.
Virtual threads handle blocking calls by transparently unmounting from the carrier thread where possible, otherwise compensating by increasing the number of platform threads.


== See also ==
Async/await
Light-weight process
Coroutine
Java virtual machine
Global interpreter lock
Fiber (computer science)
GNU Portable Threads
Protothreads


== References ==


== External links ==
"Four for the ages", JavaWorld article about Green threads
Green threads on Java threads FAQ