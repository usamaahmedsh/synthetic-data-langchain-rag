SDXF (Structured Data eXchange Format) is a data serialization format defined by RFC 3072. It allows arbitrary structured data of different types to be assembled in one file for exchanging between arbitrary computers.
The ability to arbitrarily serialize data into a self-describing format is reminiscent of XML, but SDXF is not a text format (as XML) — SDXF is not compatible with text editors. The maximal length of a datum (composite as well as elementary) encoded using SDXF is 16777215 bytes (one less than 16 MB).


== Technical structure format ==
SDXF data can express arbitrary levels of structural depth. Data elements are self-documenting, meaning that the metadata (numeric, character string or structure) are encoded into the data elements. The design of this format is simple and transparent: computer programs access SDXF data with the help of well-defined functions, exempting programmers from learning the precise data layout.
The word "exchange" in the name reflects another kind of transparency: the SDXF functions provide a computer architecture independent conversion of the data. Serializations can be exchanged among computers (via direct network, file transfer or CD) without further measures. The SDXF functions on the receiving side handle architectural adaptation.
Structured data is data with patterns predictable more complex than strings of text.


== Example ==
A commercial example: two companies want to exchange digital invoices. The invoices have the following hierarchical nested structure:

INVOICE
│
├─ INVOICE_NO  
├─ DATE
├─ ADDRESS_SENDER
│    ├─ NAME
│    ├─ NAME
│    ├─ STREET
│    ├─ ZIP
│    ├─ CITY
│    └─ COUNTRY
├─ ADDRESS_RECIPIENT
│    ├─ NAME
│    ├─ NAME
│    ├─ STREET
│    ├─ ZIP
│    ├─ CITY
│    └─ COUNTRY
├─ INVOICE_SUM
├─ SINGLE_ITEMS
│    ├─ SINGLE_ITEM
│    │    ├─ QUANTITY
│    │    ├─ ITEM_NUMBER
│    │    ├─ ITEM_TEXT
│    │    ├─ CHARGE
│    │    └─ SUM
│    └─ ...           
├─ CONDITIONS
...


== Structure ==
The basic element is a chunk. An SDXF serialization is itself a chunk. A chunk can consist of a set of smaller chunks.
Chunks are composed of a header prefix of six bytes, followed by data. The header contains a chunk identifier as a 2-byte binary number (Chunk_ID), the chunk length and type. It may contain additional information about compression, encryption and more.
The chunk type indicates whether the data consists of text (a string of characters), a binary number (integer or floating point) or if the chunk a composite of other chunks.
Structured chunks enable the programmer to pack hierarchical constructions such as the INVOICE above into an SDXF structure as follow:
Every named term (INVOICE, INVOICE_NO, DATE, ADDRESS_SENDER, etc.) is given a unique number out in the range 1 to 65535 (2 byte unsigned binary integer without sign). The top/outermost chunk is constructed with the ID INVOICE (that means with the associated numerical chunk_ID) as a structured chunk on level 1. This INVOICE chunk is filled with other chunks on level 2 and beyond: INVOICE_NO, DATE, ADDRESS_SENDER, ADDRESS_RECIPIENT, INVOICE_SUM, SINGLE_ITEMS, CONDITIONS. Some level 2 chunks are structured in turn as for the two addresses and SINGLE_ITEMS.
For a precise description see page 2 of the RFC or alternatively here.
SDXF allows programmer to work on SDXF structures with a compact function set.
There are only few of them:

The following pseudocode creates invoices:

Pseudocode to extract the INVOICE structure could look like:

SDXF is not designed for readability or to be modified by text editors. A related editable structure is SDEF - Structured Data Editable Format.


== See also ==
External Data Representation
Protocol Buffers
Abstract Syntax Notation One
Apache Thrift
Etch (protocol)
Internet Communications Engine
Comparison of data serialization formats


== References ==


== External links ==
Introduction chapter of a more detailed description