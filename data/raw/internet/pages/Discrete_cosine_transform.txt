A discrete cosine transform (DCT) expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different frequencies. The DCT, first proposed by Nasir Ahmed in 1972, is a widely used transformation technique in signal processing and data compression. It is used in most digital media, including digital images (such as JPEG and HEIF), digital video (such as MPEG and H.26x), digital audio (such as Dolby Digital, MP3 and AAC), digital television (such as SDTV, HDTV and VOD), digital radio (such as AAC+ and DAB+), and speech coding (such as AAC-LD, Siren and Opus). DCTs are also important to numerous other applications in science and engineering, such as digital signal processing, telecommunication devices, reducing network bandwidth usage, and spectral methods for the numerical solution of partial differential equations.
A DCT is a Fourier-related transform similar to the discrete Fourier transform (DFT), but using only real numbers. The DCTs are generally related to Fourier series coefficients of a periodically and symmetrically extended sequence whereas DFTs are related to Fourier series coefficients of only periodically extended sequences. DCTs are equivalent to DFTs of roughly twice the length, operating on real data with even symmetry (since the Fourier transform of a real and even function is real and even), whereas in some variants the input or output data are shifted by half a sample.
There are eight standard DCT variants, of which four are common.
The most common variant of discrete cosine transform is the type-II DCT, which is often called simply the DCT. This was the original DCT as first proposed by Ahmed. Its inverse, the type-III DCT, is correspondingly often called simply the inverse DCT or the IDCT. Two related transforms are the discrete sine transform (DST), which is equivalent to a DFT of real and odd functions, and the modified discrete cosine transform   (MDCT), which is based on a DCT of overlapping data. Multidimensional DCTs (MD DCTs) are developed to extend the concept of DCT to multidimensional signals. A variety of fast algorithms have been developed to reduce the computational complexity of implementing DCT. One of these is the integer DCT (IntDCT), an integer approximation of the standard DCT, used in several ISO/IEC and ITU-T international standards.
DCT compression, also known as block compression, compresses data in sets of discrete DCT blocks. DCT blocks sizes including 8x8 pixels for the standard DCT, and varied integer DCT sizes between 4x4 and 32x32 pixels. The DCT has a strong energy compaction property, capable of achieving high quality at high data compression ratios. However, blocky compression artifacts can appear when heavy DCT compression is applied.


== History ==
The DCT was first conceived by Nasir Ahmed while working at Kansas State University. The concept was proposed to the National Science Foundation in 1972. The DCT was originally intended for image compression. Ahmed developed a practical DCT algorithm with his PhD students T. Raj Natarajan and K. R. Rao at the University of Texas at Arlington in 1973. They presented their results in a January 1974 paper, titled Discrete Cosine Transform. It described what is now called the type-II DCT (DCT-II), as well as the type-III inverse DCT (IDCT).
Since its introduction in 1974, there has been significant research on the DCT. In 1977, Wen-Hsiung Chen published a paper with C. Harrison Smith and Stanley C. Fralick presenting a fast DCT algorithm. Further developments include a 1978 paper by M. J. Narasimha and A. M. Peterson, and a 1984 paper by B. G. Lee. These research papers, along with the original 1974 Ahmed paper and the 1977 Chen paper, were cited by the Joint Photographic Experts Group as the basis for JPEG's lossy image compression algorithm in 1992.
The discrete sine transform (DST) was derived from the DCT, by replacing the Neumann condition at x=0 with a Dirichlet condition. The DST was described in the 1974 DCT paper by Ahmed, Natarajan and Rao. A type-I DST (DST-I) was later described by Anil K. Jain in 1976, and a type-II DST (DST-II) was then described by H.B. Kekra and J.K. Solanka in 1978.
In 1975, John A. Roese and Guner S. Robinson adapted the DCT for inter-frame motion-compensated video coding. They experimented with the DCT and the fast Fourier transform (FFT), developing inter-frame hybrid coders for both, and found that the DCT is the most efficient due to its reduced complexity, capable of compressing image data down to 0.25-bit per pixel for a videotelephone scene with image quality comparable to an intra-frame coder requiring 2-bit per pixel. In 1979, Anil K. Jain and Jaswant R. Jain further developed motion-compensated DCT video compression, also called block motion compensation. This led to Chen developing a practical video compression algorithm, called motion-compensated DCT or adaptive scene coding, in 1981. Motion-compensated DCT later became the standard coding technique for video compression from the late 1980s onwards.
A DCT variant, the modified discrete cosine transform (MDCT), was developed by John P. Princen, A.W. Johnson and Alan B. Bradley at the University of Surrey in 1987, following earlier work by Princen and Bradley in 1986. The MDCT is used in most modern audio compression formats, such as Dolby Digital (AC-3), MP3 (which uses a hybrid DCT-FFT algorithm), Advanced Audio Coding (AAC), and Vorbis (Ogg).
Nasir Ahmed also developed a lossless DCT algorithm with Giridhar Mandyam and Neeraj Magotra at the University of New Mexico in 1995. This allows the DCT technique to be used for lossless compression of images. It is a modification of the original DCT algorithm, and incorporates elements of inverse DCT and delta modulation. It is a more effective lossless compression algorithm than entropy coding. Lossless DCT is also known as LDCT.


== Applications ==
The DCT is the most widely used transformation technique in signal processing, and by far the most widely used linear transform in data compression. Uncompressed digital media as well as lossless compression have high memory and bandwidth requirements, which is significantly reduced by the DCT lossy compression technique, capable of achieving data compression ratios from 8:1 to 14:1 for near-studio-quality, up to 100:1 for acceptable-quality content. DCT compression standards are used in digital media technologies, such as digital images, digital photos, digital video, streaming media, digital television, streaming television, video on demand (VOD), digital cinema, high-definition video (HD video), and high-definition television (HDTV).
The DCT, and in particular the DCT-II, is often used in signal and image processing, especially for lossy compression, because it has a strong energy compaction property. In typical applications, most of the signal information tends to be concentrated in a few low-frequency components of the DCT. For strongly correlated Markov processes, the DCT can approach the compaction efficiency of the Karhunen-Loève transform (which is optimal in the decorrelation sense). As explained below, this stems from the boundary conditions implicit in the cosine functions.
DCTs are widely employed in solving partial differential equations by spectral methods, where the different variants of the DCT correspond to slightly different even and odd boundary conditions at the two ends of the array.
DCTs are closely related to Chebyshev polynomials, and fast DCT algorithms (below) are used in Chebyshev approximation of arbitrary functions by series of Chebyshev polynomials, for example in Clenshaw–Curtis quadrature.


=== General applications ===
The DCT is widely used in many applications, which include the following.


=== Visual media standards ===
The DCT-II is an important image compression technique. It is used in image compression standards such as JPEG, and video compression standards such as H.26x, MJPEG, MPEG, DV, Theora and Daala. There, the two-dimensional DCT-II of 
  
    
      
        N
        ×
        N
      
    
    {\displaystyle N\times N}
  
 blocks are computed and the results are quantized and entropy coded. In this case, 
  
    
      
        N
      
    
    {\displaystyle N}
  
 is typically 8 and the DCT-II formula is applied to each row and column of the block. The result is an 8 × 8 transform coefficient array in which the 
  
    
      
        (
        0
        ,
        0
        )
      
    
    {\displaystyle (0,0)}
  
 element (top-left) is the DC (zero-frequency) component and entries with increasing vertical and horizontal index values represent higher vertical and horizontal spatial frequencies.
The integer DCT, an integer approximation of the DCT, is used in Advanced Video Coding (AVC), introduced in 2003, and High Efficiency Video Coding (HEVC), introduced in 2013. The integer DCT is also used in the High Efficiency Image Format (HEIF), which uses a subset of the HEVC video coding format for coding still images. AVC uses 4 x 4 and 8 x 8 blocks. HEVC and HEIF use varied block sizes between 4 x 4 and 32 x 32 pixels. As of 2019, AVC is by far the most commonly used format for the recording, compression and distribution of video content, used by 91% of video developers, followed by HEVC which is used by 43% of developers.


==== Image formats ====


==== Video formats ====


=== MDCT audio standards ===


==== General audio ====


==== Speech coding ====


=== Multidimensional DCT ===

Multidimensional DCTs (MD DCTs) have several applications, mainly 3-D DCTs such as the 3-D DCT-II, which has several new applications like Hyperspectral Imaging coding systems, variable temporal length 3-D DCT coding, video coding algorithms, adaptive video coding and 3-D Compression. Due to enhancement in the hardware, software and introduction of several fast algorithms, the necessity of using MD DCTs is rapidly increasing. DCT-IV has gained popularity for its applications in fast implementation of real-valued polyphase filtering banks, lapped orthogonal transform and cosine-modulated wavelet bases.


=== Digital signal processing ===
DCT plays an important role in digital signal processing specifically data compression. The DCT is widely implemented in digital signal processors (DSP), as well as digital signal processing software. Many companies have developed DSPs based on DCT technology. DCTs are widely used for applications such as encoding, decoding, video, audio, multiplexing, control signals, signaling, and analog-to-digital conversion. DCTs are also commonly used for high-definition television (HDTV) encoder/decoder chips.


=== Compression artifacts ===
A common issue with DCT compression in digital media are blocky compression artifacts, caused by DCT blocks. In a DCT algorithm, an image (or frame in an image sequence) is divided into square blocks which are processed independently from each other, then the DCT blocks is taken within each block and the resulting DCT coefficients are quantized. This process can cause blocking artifacts, primarily at high data compression ratios. This can also cause the mosquito noise effect, commonly found in digital video.
DCT blocks are often used in glitch art. The artist Rosa Menkman makes use of DCT-based compression artifacts in her glitch art, particularly the DCT blocks found in most digital media formats such as JPEG digital images and MP3 audio. Another example is Jpegs by German photographer Thomas Ruff, which uses intentional JPEG artifacts as the basis of the picture's style.


== Informal overview ==
Like any Fourier-related transform, DCTs express a function or a signal in terms of a sum of sinusoids with different frequencies and amplitudes. Like the DFT, a DCT operates on a function at a finite number of discrete data points. The obvious distinction between a DCT and a DFT is that the former uses only cosine functions, while the latter uses both cosines and sines (in the form of complex exponentials). However, this visible difference is merely a consequence of a deeper distinction: a DCT implies different boundary conditions from the DFT or other related transforms.
The Fourier-related transforms that operate on a function over a finite domain, such as the DFT or DCT or a Fourier series, can be thought of as implicitly defining an extension of that function outside the domain. That is, once you write a function 
  
    
      
        f
        (
        x
        )
      
    
    {\displaystyle f(x)}
  
 as a sum of sinusoids, you can evaluate that sum at any 
  
    
      
        x
      
    
    {\displaystyle x}
  
, even for 
  
    
      
        x
      
    
    {\displaystyle x}
  
 where the original 
  
    
      
        f
        (
        x
        )
      
    
    {\displaystyle f(x)}
  
 was not specified. The DFT, like the Fourier series, implies a periodic extension of the original function. A DCT, like a cosine transform, implies an even extension of the original function.

However, because DCTs operate on finite, discrete sequences, two issues arise that do not apply for the continuous cosine transform. First, one has to specify whether the function is even or odd at both the left and right boundaries of the domain (i.e. the min-n and max-n boundaries in the definitions below, respectively). Second, one has to specify around what point the function is even or odd. In particular, consider a sequence abcd of four equally spaced data points, and say that we specify an even left boundary. There are two sensible possibilities: either the data are even about the sample a, in which case the even extension is dcbabcd, or the data are even about the point halfway between a and the previous point, in which case the even extension is dcbaabcd (a is repeated).
Each boundary can be either even or odd (2 choices per boundary) and can be symmetric about a data point or the point halfway between two data points (2 choices per boundary), for a total of 2 × 2 × 2 × 2 = 16 possibilities. These choices lead to all the standard variations of DCTs and also discrete sine transforms (DSTs). Half of these possibilities, those where the left boundary is even, correspond to the 8 types of DCT; the other half are the 8 types of DST.
These different boundary conditions strongly affect the applications of the transform and lead to uniquely useful properties for the various DCT types. Most directly, when using Fourier-related transforms to solve partial differential equations by spectral methods, the boundary conditions are directly specified as a part of the problem being solved. Or, for the MDCT (based on the type-IV DCT), the boundary conditions are intimately involved in the MDCT's critical property of time-domain aliasing cancellation. In a more subtle fashion, the boundary conditions are responsible for the energy compactification properties that make DCTs useful for image and audio compression, because the boundaries affect the rate of convergence of any Fourier-like series.
In particular, it is well known that any discontinuities in a function reduce the rate of convergence of the Fourier series so that more sinusoids are needed to represent the function with a given accuracy. The same principle governs the usefulness of the DFT and other transforms for signal compression; the smoother a function is, the fewer terms in its DFT or DCT are required to represent it accurately, and the more it can be compressed. However, the implicit periodicity of the DFT means that discontinuities usually occur at the boundaries: any random segment of a signal is unlikely to have the same value at both the left and right boundaries. In contrast, a DCT where both boundaries are even always yields a continuous extension at the boundaries (although the slope is generally discontinuous). This is why DCTs, and in particular DCTs of types I, II, V, and VI (the types that have two even boundaries) generally perform better for signal compression than DFTs and DSTs. In practice, a type-II DCT is usually preferred for such applications, in part for reasons of computational convenience.


== Formal definition ==
Formally, the discrete cosine transform is a linear, invertible function 
  
    
      
        f
        :
        
          
            R
          
          
            N
          
        
        →
        
          
            R
          
          
            N
          
        
      
    
    {\displaystyle f:\mathbb {R} ^{N}\to \mathbb {R} ^{N}}
  
 (where 
  
    
      
        
          R
        
      
    
    {\displaystyle \mathbb {R} }
  
 denotes the set of real numbers), or equivalently an invertible N × N square matrix. There are several variants of the DCT with slightly modified definitions. The N real numbers 
  
    
      
         
        
          x
          
            0
          
        
        ,
         
        …
         
        
          x
          
            N
            −
            1
          
        
         
      
    
    {\displaystyle ~x_{0},\ \ldots \ x_{N-1}~}
  
 are transformed into the N real numbers 
  
    
      
        
          X
          
            0
          
        
        ,
        
        …
        ,
        
        
          X
          
            N
            −
            1
          
        
      
    
    {\displaystyle X_{0},\,\ldots ,\,X_{N-1}}
  
 according to one of the formulas:


=== DCT-I ===

  
    
      
        
          X
          
            k
          
        
        =
        
          
            1
            2
          
        
        (
        
          x
          
            0
          
        
        +
        (
        −
        1
        
          )
          
            k
          
        
        
          x
          
            N
            −
            1
          
        
        )
        +
        
          ∑
          
            n
            =
            1
          
          
            N
            −
            2
          
        
        
          x
          
            n
          
        
        cos
        ⁡
        
          [
          
            
            
              
                
                  
                     
                    π
                  
                  
                    
                    N
                    −
                    1
                    
                  
                
              
            
            
            n
            
            k
            
          
          ]
        
        
        
           for 
        
         
        k
        =
        0
        ,
         
        …
         
        N
        −
        1
         
        .
      
    
    {\displaystyle X_{k}={\frac {1}{2}}(x_{0}+(-1)^{k}x_{N-1})+\sum _{n=1}^{N-2}x_{n}\cos \left[\,{\tfrac {\ \pi }{\,N-1\,}}\,n\,k\,\right]\qquad {\text{ for }}~k=0,\ \ldots \ N-1~.}
  

Some authors further multiply the 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 and 
  
    
      
        
          x
          
            N
            −
            1
          
        
      
    
    {\displaystyle x_{N-1}}
  
 terms by 
  
    
      
        
          
            2
            
          
        
        
      
    
    {\displaystyle {\sqrt {2\,}}\,}
  
 and correspondingly multiply the 
  
    
      
        
          X
          
            0
          
        
      
    
    {\displaystyle X_{0}}
  
 and 
  
    
      
        
          X
          
            N
            −
            1
          
        
      
    
    {\displaystyle X_{N-1}}
  
 terms by 
  
    
      
        1
        
          /
        
        
          
            2
            
          
        
        
      
    
    {\displaystyle 1/{\sqrt {2\,}}\,}
  
 which, if one further multiplies by an overall scale factor of 
  
    
      
        
          
            
              
                
                  2
                  
                    N
                    −
                    1
                    
                  
                
              
            
            
          
        
      
    
    {\textstyle {\sqrt {{\tfrac {2}{N-1\,}}\,}}}
  
, makes the DCT-I matrix orthogonal but breaks the direct correspondence with a real-even DFT.
The DCT-I is exactly equivalent (up to an overall scale factor of 2), to a DFT of 
  
    
      
        2
        (
        N
        −
        1
        )
      
    
    {\displaystyle 2(N-1)}
  
 real numbers with even symmetry. For example, a DCT-I of 
  
    
      
        N
        =
        5
      
    
    {\displaystyle N=5}
  
 real numbers 
  
    
      
        a
         
        b
         
        c
         
        d
         
        e
      
    
    {\displaystyle a\ b\ c\ d\ e}
  
 is exactly equivalent to a DFT of eight real numbers 
  
    
      
        a
         
        b
         
        c
         
        d
         
        e
         
        d
         
        c
         
        b
      
    
    {\displaystyle a\ b\ c\ d\ e\ d\ c\ b}
  
 (even symmetry), divided by two. (In contrast, DCT types II-IV involve a half-sample shift in the equivalent DFT.)
Note, however, that the DCT-I is not defined for 
  
    
      
        N
      
    
    {\displaystyle N}
  
 less than 2, while all other DCT types are defined for any positive 
  
    
      
        N
      
    
    {\displaystyle N}
  
.
Thus, the DCT-I corresponds to the boundary conditions: 
  
    
      
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{n}}
  
 is even around 
  
    
      
        n
        =
        0
      
    
    {\displaystyle n=0}
  
 and even around 
  
    
      
        n
        =
        N
        −
        1
      
    
    {\displaystyle n=N-1}
  
; similarly for 
  
    
      
        
          X
          
            k
          
        
      
    
    {\displaystyle X_{k}}
  
.


=== DCT-II ===

  
    
      
        
          X
          
            k
          
        
        =
        
          ∑
          
            n
            =
            0
          
          
            N
            −
            1
          
        
        
          x
          
            n
          
        
        cos
        ⁡
        
          [
          
            
            
              
                
                  
                    
                    π
                    
                  
                  N
                
              
            
            
              (
              
                n
                +
                
                  
                    
                      1
                      2
                    
                  
                
              
              )
            
            k
            
          
          ]
        
        
        
           for 
        
         
        k
        =
        0
        ,
         
        …
         
        N
        −
        1
         
        .
      
    
    {\displaystyle X_{k}=\sum _{n=0}^{N-1}x_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(n+{\tfrac {1}{2}}\right)k\,\right]\qquad {\text{ for }}~k=0,\ \dots \ N-1~.}
  

The DCT-II is probably the most commonly used form, and is often simply referred to as the DCT.
This transform is exactly equivalent (up to an overall scale factor of 2) to a DFT of 
  
    
      
        4
        N
      
    
    {\displaystyle 4N}
  
 real inputs of even symmetry, where the even-indexed elements are zero. That is, it is half of the DFT of the 
  
    
      
        4
        N
      
    
    {\displaystyle 4N}
  
 inputs 
  
    
      
        
          y
          
            n
          
        
        ,
      
    
    {\displaystyle y_{n},}
  
 where 
  
    
      
        
          y
          
            2
            n
          
        
        =
        0
      
    
    {\displaystyle y_{2n}=0}
  
, 
  
    
      
        
          y
          
            2
            n
            +
            1
          
        
        =
        
          x
          
            n
          
        
      
    
    {\displaystyle y_{2n+1}=x_{n}}
  
 for 
  
    
      
        0
        ≤
        n
        <
        N
      
    
    {\displaystyle 0\leq n<N}
  
, 
  
    
      
        
          y
          
            2
            N
          
        
        =
        0
      
    
    {\displaystyle y_{2N}=0}
  
, and 
  
    
      
        
          y
          
            4
            N
            −
            n
          
        
        =
        
          y
          
            n
          
        
      
    
    {\displaystyle y_{4N-n}=y_{n}}
  
 for 
  
    
      
        0
        <
        n
        <
        2
        N
      
    
    {\displaystyle 0<n<2N}
  
. DCT-II transformation is also possible using 
  
    
      
        2
        N
      
    
    {\displaystyle 2N}
  
 signal followed by a multiplication by half shift. This is demonstrated by Makhoul.
Some authors further multiply the 
  
    
      
        
          X
          
            0
          
        
      
    
    {\displaystyle X_{0}}
  
 term by 
  
    
      
        1
        
          /
        
        
          
            N
            
          
        
        
      
    
    {\displaystyle 1/{\sqrt {N\,}}\,}
  
 and multiply the rest of the matrix by an overall scale factor of 
  
    
      
        
          
            
              2
            
            
              /
            
            
              N
            
          
        
      
    
    {\textstyle {\sqrt {{2}/{N}}}}
  
 (see below for the corresponding change in DCT-III). This makes the DCT-II matrix orthogonal, but breaks the direct correspondence with a real-even DFT of half-shifted input. This is the normalization used by Matlab. In many applications, such as JPEG, the scaling is arbitrary because scale factors can be combined with a subsequent computational step (e.g. the quantization step in JPEG), and a scaling can be chosen that allows the DCT to be computed with fewer multiplications.
The DCT-II implies the boundary conditions: 
  
    
      
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{n}}
  
 is even around 
  
    
      
        n
        =
        −
        1
        
          /
        
        2
      
    
    {\displaystyle n=-1/2}
  
 and even around 
  
    
      
        n
        =
        N
        −
        1
        
          /
        
        2
        
      
    
    {\displaystyle n=N-1/2\,}
  
; 
  
    
      
        
          X
          
            k
          
        
      
    
    {\displaystyle X_{k}}
  
 is even around 
  
    
      
        k
        =
        0
      
    
    {\displaystyle k=0}
  
 and odd around 
  
    
      
        k
        =
        N
      
    
    {\displaystyle k=N}
  
.


=== DCT-III ===

  
    
      
        
          X
          
            k
          
        
        =
        
          
            
              1
              2
            
          
        
        
          x
          
            0
          
        
        +
        
          ∑
          
            n
            =
            1
          
          
            N
            −
            1
          
        
        
          x
          
            n
          
        
        cos
        ⁡
        
          [
          
            
            
              
                
                  
                    
                    π
                    
                  
                  N
                
              
            
            
              (
              
                k
                +
                
                  
                    
                      1
                      2
                    
                  
                
              
              )
            
            n
            
          
          ]
        
        
        
           for 
        
         
        k
        =
        0
        ,
         
        …
         
        N
        −
        1
         
        .
      
    
    {\displaystyle X_{k}={\tfrac {1}{2}}x_{0}+\sum _{n=1}^{N-1}x_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\left(k+{\tfrac {1}{2}}\right)n\,\right]\qquad {\text{ for }}~k=0,\ \ldots \ N-1~.}
  

Because it is the inverse of DCT-II up to a scale factor (see below), this form is sometimes simply referred to as the inverse DCT (IDCT).
Some authors divide the 
  
    
      
        
          x
          
            0
          
        
      
    
    {\displaystyle x_{0}}
  
 term by 
  
    
      
        
          
            2
          
        
      
    
    {\displaystyle {\sqrt {2}}}
  
 instead of by 2 (resulting in an overall 
  
    
      
        
          x
          
            0
          
        
        
          /
        
        
          
            2
          
        
      
    
    {\displaystyle x_{0}/{\sqrt {2}}}
  
 term) and multiply the resulting matrix by an overall scale factor of 
  
    
      
        
          
            2
            
              /
            
            N
          
        
      
    
    {\textstyle {\sqrt {2/N}}}
  
 (see above for the corresponding change in DCT-II), so that the DCT-II and DCT-III are transposes of one another. This makes the DCT-III matrix orthogonal, but breaks the direct correspondence with a real-even DFT of half-shifted output.
The DCT-III implies the boundary conditions: 
  
    
      
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{n}}
  
 is even around 
  
    
      
        n
        =
        0
      
    
    {\displaystyle n=0}
  
 and odd around 
  
    
      
        n
        =
        N
        ;
      
    
    {\displaystyle n=N;}
  
 
  
    
      
        
          X
          
            k
          
        
      
    
    {\displaystyle X_{k}}
  
 is even around 
  
    
      
        k
        =
        −
        1
        
          /
        
        2
      
    
    {\displaystyle k=-1/2}
  
 and even around 
  
    
      
        k
        =
        N
        −
        1
        
          /
        
        2.
      
    
    {\displaystyle k=N-1/2.}
  


=== DCT-IV ===

  
    
      
        
          X
          
            k
          
        
        =
        
          ∑
          
            n
            =
            0
          
          
            N
            −
            1
          
        
        
          x
          
            n
          
        
        cos
        ⁡
        
          [
          
            
            
              
                
                  
                    
                    π
                    
                  
                  N
                
              
            
            
            
              (
              
                n
                +
                
                  
                    
                      1
                      2
                    
                  
                
              
              )
            
            
              (
              
                k
                +
                
                  
                    
                      1
                      2
                    
                  
                
              
              )
            
            
          
          ]
        
        
        
           for 
        
        k
        =
        0
        ,
         
        …
         
        N
        −
        1
         
        .
      
    
    {\displaystyle X_{k}=\sum _{n=0}^{N-1}x_{n}\cos \left[\,{\tfrac {\,\pi \,}{N}}\,\left(n+{\tfrac {1}{2}}\right)\left(k+{\tfrac {1}{2}}\right)\,\right]\qquad {\text{ for }}k=0,\ \ldots \ N-1~.}
  

The DCT-IV matrix becomes orthogonal (and thus, being clearly symmetric, its own inverse) if one further multiplies by an overall scale factor of 
  
    
      
        
          
            2
            
              /
            
            N
          
        
        .
      
    
    {\textstyle {\sqrt {2/N}}.}
  

A variant of the DCT-IV, where data from different transforms are overlapped, is called the modified discrete cosine transform (MDCT).
The DCT-IV implies the boundary conditions: 
  
    
      
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{n}}
  
 is even around 
  
    
      
        n
        =
        −
        1
        
          /
        
        2
      
    
    {\displaystyle n=-1/2}
  
 and odd around 
  
    
      
        n
        =
        N
        −
        1
        
          /
        
        2
      
    
    {\displaystyle n=N-1/2}
  
; similarly for 
  
    
      
        
          X
          
            k
          
        
      
    
    {\displaystyle X_{k}}
  
.


=== DCT V-VIII ===
DCTs of types I–IV treat both boundaries consistently regarding the point of symmetry: they are even or odd around either a data point for both boundaries or halfway between two data points for both boundaries. By contrast, DCTs of types V-VIII imply boundaries that are even or odd around a data point for one boundary and halfway between two data points for the other boundary.
In other words, DCT types I–IV are equivalent to real-even DFTs of even order (regardless of whether 
  
    
      
        N
      
    
    {\displaystyle N}
  
 is even or odd), since the corresponding DFT is of length 
  
    
      
        2
        (
        N
        −
        1
        )
      
    
    {\displaystyle 2(N-1)}
  
 (for DCT-I) or 
  
    
      
        4
        N
      
    
    {\displaystyle 4N}
  
 (for DCT-II and III) or 
  
    
      
        8
        N
      
    
    {\displaystyle 8N}
  
 (for DCT-IV). The four additional types of discrete cosine transform correspond essentially to real-even DFTs of logically odd order, which have factors of 
  
    
      
        N
        ±
        
          1
        
        
          /
        
        
          2
        
      
    
    {\displaystyle N\pm {1}/{2}}
  
 in the denominators of the cosine arguments.
However, these variants seem to be rarely used in practice. One reason, perhaps, is that FFT algorithms for odd-length DFTs are generally more complicated than FFT algorithms for even-length DFTs (e.g., the simplest radix-2 algorithms are only for even lengths), and this increased intricacy carries over to the DCTs as described below. Not that the trivial real-even array, a length-one DFT (odd length) of a single number 
  
    
      
        a
      
    
    {\displaystyle a}
  
, corresponds to a DCT-V of length 
  
    
      
        N
        =
        1
      
    
    {\displaystyle N=1}
  
.


== Inverse transforms ==
Using the normalization conventions above, the inverse of DCT-I is DCT-I multiplied by 2/(N − 1). The inverse of DCT-IV is DCT-IV multiplied by 2/N. The inverse of DCT-II is DCT-III multiplied by 2/N and vice versa.
Like for the DFT, the normalization factor in front of these transform definitions is merely a convention and differs between treatments. For example, some authors multiply the transforms by 
  
    
      
        
          
            2
            
              /
            
            N
          
        
      
    
    {\textstyle {\sqrt {2/N}}}
  
 so that the inverse does not require any additional multiplicative factor. Combined with appropriate factors of √2 (see above), this can be used to make the transform matrix orthogonal.


== Multidimensional DCTs ==
Multidimensional variants of the various DCT types follow straightforwardly from the one-dimensional definitions: they are simply a separable product (equivalently, a composition) of DCTs along each dimension.


=== M-D DCT-II ===
For example, a two-dimensional DCT-II of an image or a matrix is simply the one-dimensional DCT-II, from above, performed along the rows and then along the columns (or vice versa). The inverse of a multi-dimensional DCT is just a separable product of the inverses of the corresponding one-dimensional DCTs (see above), e.g., the one-dimensional inverses applied along one dimension at a time in a row-column algorithm.
The 2D DCT-II is given by the formula (omitting normalization and other scale factors, as above)

  
    
      
        
          
            
              
                
                  X
                  
                    
                      k
                      
                        1
                      
                    
                    ,
                    
                      k
                      
                        2
                      
                    
                  
                
              
              
                
                =
                
                  ∑
                  
                    
                      n
                      
                        1
                      
                    
                    =
                    0
                  
                  
                    
                      N
                      
                        1
                      
                    
                    −
                    1
                  
                
                
                  (
                  
                    
                      ∑
                      
                        
                          n
                          
                            2
                          
                        
                        =
                        0
                      
                      
                        
                          N
                          
                            2
                          
                        
                        −
                        1
                      
                    
                    
                      x
                      
                        
                          n
                          
                            1
                          
                        
                        ,
                        
                          n
                          
                            2
                          
                        
                      
                    
                    cos
                    ⁡
                    
                      [
                      
                        
                          
                            π
                            
                              N
                              
                                2
                              
                            
                          
                        
                        
                          (
                          
                            
                              n
                              
                                2
                              
                            
                            +
                            
                              
                                1
                                2
                              
                            
                          
                          )
                        
                        
                          k
                          
                            2
                          
                        
                      
                      ]
                    
                  
                  )
                
                cos
                ⁡
                
                  [
                  
                    
                      
                        π
                        
                          N
                          
                            1
                          
                        
                      
                    
                    
                      (
                      
                        
                          n
                          
                            1
                          
                        
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                    
                      k
                      
                        1
                      
                    
                  
                  ]
                
              
            
            
              
              
                
                =
                
                  ∑
                  
                    
                      n
                      
                        1
                      
                    
                    =
                    0
                  
                  
                    
                      N
                      
                        1
                      
                    
                    −
                    1
                  
                
                
                  ∑
                  
                    
                      n
                      
                        2
                      
                    
                    =
                    0
                  
                  
                    
                      N
                      
                        2
                      
                    
                    −
                    1
                  
                
                
                  x
                  
                    
                      n
                      
                        1
                      
                    
                    ,
                    
                      n
                      
                        2
                      
                    
                  
                
                cos
                ⁡
                
                  [
                  
                    
                      
                        π
                        
                          N
                          
                            1
                          
                        
                      
                    
                    
                      (
                      
                        
                          n
                          
                            1
                          
                        
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                    
                      k
                      
                        1
                      
                    
                  
                  ]
                
                cos
                ⁡
                
                  [
                  
                    
                      
                        π
                        
                          N
                          
                            2
                          
                        
                      
                    
                    
                      (
                      
                        
                          n
                          
                            2
                          
                        
                        +
                        
                          
                            1
                            2
                          
                        
                      
                      )
                    
                    
                      k
                      
                        2
                      
                    
                  
                  ]
                
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}X_{k_{1},k_{2}}&=\sum _{n_{1}=0}^{N_{1}-1}\left(\sum _{n_{2}=0}^{N_{2}-1}x_{n_{1},n_{2}}\cos \left[{\frac {\pi }{N_{2}}}\left(n_{2}+{\frac {1}{2}}\right)k_{2}\right]\right)\cos \left[{\frac {\pi }{N_{1}}}\left(n_{1}+{\frac {1}{2}}\right)k_{1}\right]\\&=\sum _{n_{1}=0}^{N_{1}-1}\sum _{n_{2}=0}^{N_{2}-1}x_{n_{1},n_{2}}\cos \left[{\frac {\pi }{N_{1}}}\left(n_{1}+{\frac {1}{2}}\right)k_{1}\right]\cos \left[{\frac {\pi }{N_{2}}}\left(n_{2}+{\frac {1}{2}}\right)k_{2}\right].\end{aligned}}}
  

The 3-D DCT-II is only the extension of 2-D DCT-II in three-dimensional space and mathematically can be calculated by the formula

  
    
      
        
          X
          
            
              k
              
                1
              
            
            ,
            
              k
              
                2
              
            
            ,
            
              k
              
                3
              
            
          
        
        =
        
          ∑
          
            
              n
              
                1
              
            
            =
            0
          
          
            
              N
              
                1
              
            
            −
            1
          
        
        
          ∑
          
            
              n
              
                2
              
            
            =
            0
          
          
            
              N
              
                2
              
            
            −
            1
          
        
        
          ∑
          
            
              n
              
                3
              
            
            =
            0
          
          
            
              N
              
                3
              
            
            −
            1
          
        
        
          x
          
            
              n
              
                1
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
          
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    1
                  
                
              
            
            
              (
              
                
                  n
                  
                    1
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                1
              
            
          
          ]
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    2
                  
                
              
            
            
              (
              
                
                  n
                  
                    2
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                2
              
            
          
          ]
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    3
                  
                
              
            
            
              (
              
                
                  n
                  
                    3
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                3
              
            
          
          ]
        
        ,
        
        
          for 
        
        
          k
          
            i
          
        
        =
        0
        ,
        1
        ,
        2
        ,
        …
        ,
        
          N
          
            i
          
        
        −
        1.
      
    
    {\displaystyle X_{k_{1},k_{2},k_{3}}=\sum _{n_{1}=0}^{N_{1}-1}\sum _{n_{2}=0}^{N_{2}-1}\sum _{n_{3}=0}^{N_{3}-1}x_{n_{1},n_{2},n_{3}}\cos \left[{\frac {\pi }{N_{1}}}\left(n_{1}+{\frac {1}{2}}\right)k_{1}\right]\cos \left[{\frac {\pi }{N_{2}}}\left(n_{2}+{\frac {1}{2}}\right)k_{2}\right]\cos \left[{\frac {\pi }{N_{3}}}\left(n_{3}+{\frac {1}{2}}\right)k_{3}\right],\quad {\text{for }}k_{i}=0,1,2,\dots ,N_{i}-1.}
  

The inverse of 3-D DCT-II is 3-D DCT-III and can be computed from the formula

  
    
      
        
          x
          
            
              n
              
                1
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
          
        
        =
        
          ∑
          
            
              k
              
                1
              
            
            =
            0
          
          
            
              N
              
                1
              
            
            −
            1
          
        
        
          ∑
          
            
              k
              
                2
              
            
            =
            0
          
          
            
              N
              
                2
              
            
            −
            1
          
        
        
          ∑
          
            
              k
              
                3
              
            
            =
            0
          
          
            
              N
              
                3
              
            
            −
            1
          
        
        
          X
          
            
              k
              
                1
              
            
            ,
            
              k
              
                2
              
            
            ,
            
              k
              
                3
              
            
          
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    1
                  
                
              
            
            
              (
              
                
                  n
                  
                    1
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                1
              
            
          
          ]
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    2
                  
                
              
            
            
              (
              
                
                  n
                  
                    2
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                2
              
            
          
          ]
        
        cos
        ⁡
        
          [
          
            
              
                π
                
                  N
                  
                    3
                  
                
              
            
            
              (
              
                
                  n
                  
                    3
                  
                
                +
                
                  
                    1
                    2
                  
                
              
              )
            
            
              k
              
                3
              
            
          
          ]
        
        ,
        
        
          for 
        
        
          n
          
            i
          
        
        =
        0
        ,
        1
        ,
        2
        ,
        …
        ,
        
          N
          
            i
          
        
        −
        1.
      
    
    {\displaystyle x_{n_{1},n_{2},n_{3}}=\sum _{k_{1}=0}^{N_{1}-1}\sum _{k_{2}=0}^{N_{2}-1}\sum _{k_{3}=0}^{N_{3}-1}X_{k_{1},k_{2},k_{3}}\cos \left[{\frac {\pi }{N_{1}}}\left(n_{1}+{\frac {1}{2}}\right)k_{1}\right]\cos \left[{\frac {\pi }{N_{2}}}\left(n_{2}+{\frac {1}{2}}\right)k_{2}\right]\cos \left[{\frac {\pi }{N_{3}}}\left(n_{3}+{\frac {1}{2}}\right)k_{3}\right],\quad {\text{for }}n_{i}=0,1,2,\dots ,N_{i}-1.}
  

Technically, computing a two-, three- (or -multi) dimensional DCT by sequences of one-dimensional DCTs along each dimension is known as a row-column algorithm. As with multidimensional FFT algorithms, however, there exist other methods to compute the same thing while performing the computations in a different order (i.e., interleaving or combining the algorithms for the different dimensions). Owing to the rapid growth in the applications based on the 3-D DCT, several fast algorithms have been developed for the computation of 3-D DCT-II. Vector-Radix algorithms are applied for computing M-D DCT to reduce the computational complexity and to increase the computational speed. Vector-Radix Decimation in Frequency (VR DIF) is an example of an algorithm to compute a 3-D DCT-II efficiently.


==== 3-D DCT-II VR DIF ====
In order to apply the VR DIF algorithm the input data is to be formulated and rearranged as follows. The transform size N × N × N is assumed to be 2.

  
    
      
        
          
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                
                  n
                  
                    1
                  
                
                ,
                
                  n
                  
                    2
                  
                
                ,
                
                  n
                  
                    3
                  
                
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                ,
                2
                
                  n
                  
                    2
                  
                
                ,
                2
                
                  n
                  
                    3
                  
                
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                
                  n
                  
                    1
                  
                
                ,
                
                  n
                  
                    2
                  
                
                ,
                N
                −
                
                  n
                  
                    3
                  
                
                −
                1
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                ,
                2
                
                  n
                  
                    2
                  
                
                ,
                2
                
                  n
                  
                    3
                  
                
                +
                1
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                
                  n
                  
                    1
                  
                
                ,
                N
                −
                
                  n
                  
                    2
                  
                
                −
                1
                ,
                
                  n
                  
                    3
                  
                
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                ,
                2
                
                  n
                  
                    2
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    3
                  
                
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                
                  n
                  
                    1
                  
                
                ,
                N
                −
                
                  n
                  
                    2
                  
                
                −
                1
                ,
                N
                −
                
                  n
                  
                    3
                  
                
                −
                1
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                ,
                2
                
                  n
                  
                    2
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    3
                  
                
                +
                1
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                N
                −
                
                  n
                  
                    1
                  
                
                −
                1
                ,
                
                  n
                  
                    2
                  
                
                ,
                
                  n
                  
                    3
                  
                
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    2
                  
                
                ,
                2
                
                  n
                  
                    3
                  
                
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                N
                −
                
                  n
                  
                    1
                  
                
                −
                1
                ,
                
                  n
                  
                    2
                  
                
                ,
                N
                −
                
                  n
                  
                    3
                  
                
                −
                1
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    2
                  
                
                ,
                2
                
                  n
                  
                    3
                  
                
                +
                1
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                N
                −
                
                  n
                  
                    1
                  
                
                −
                1
                ,
                N
                −
                
                  n
                  
                    2
                  
                
                −
                1
                ,
                
                  n
                  
                    3
                  
                
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    2
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    3
                  
                
                )
              
            
            
              
                
                  
                    
                      x
                      ~
                    
                  
                
                (
                N
                −
                
                  n
                  
                    1
                  
                
                −
                1
                ,
                N
                −
                
                  n
                  
                    2
                  
                
                −
                1
                ,
                N
                −
                
                  n
                  
                    3
                  
                
                −
                1
                )
                =
                x
                (
                2
                
                  n
                  
                    1
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    2
                  
                
                +
                1
                ,
                2
                
                  n
                  
                    3
                  
                
                +
                1
                )
              
            
          
        
      
    
    {\displaystyle {\begin{array}{lcl}{\tilde {x}}(n_{1},n_{2},n_{3})=x(2n_{1},2n_{2},2n_{3})\\{\tilde {x}}(n_{1},n_{2},N-n_{3}-1)=x(2n_{1},2n_{2},2n_{3}+1)\\{\tilde {x}}(n_{1},N-n_{2}-1,n_{3})=x(2n_{1},2n_{2}+1,2n_{3})\\{\tilde {x}}(n_{1},N-n_{2}-1,N-n_{3}-1)=x(2n_{1},2n_{2}+1,2n_{3}+1)\\{\tilde {x}}(N-n_{1}-1,n_{2},n_{3})=x(2n_{1}+1,2n_{2},2n_{3})\\{\tilde {x}}(N-n_{1}-1,n_{2},N-n_{3}-1)=x(2n_{1}+1,2n_{2},2n_{3}+1)\\{\tilde {x}}(N-n_{1}-1,N-n_{2}-1,n_{3})=x(2n_{1}+1,2n_{2}+1,2n_{3})\\{\tilde {x}}(N-n_{1}-1,N-n_{2}-1,N-n_{3}-1)=x(2n_{1}+1,2n_{2}+1,2n_{3}+1)\\\end{array}}}
  

where 
  
    
      
        0
        ≤
        
          n
          
            1
          
        
        ,
        
          n
          
            2
          
        
        ,
        
          n
          
            3
          
        
        ≤
        
          
            N
            2
          
        
        −
        1
      
    
    {\displaystyle 0\leq n_{1},n_{2},n_{3}\leq {\frac {N}{2}}-1}
  

The figure to the adjacent shows the four stages that are involved in calculating 3-D DCT-II using VR DIF algorithm. The first stage is the 3-D reordering using the index mapping illustrated by the above equations. The second stage is the butterfly calculation. Each butterfly calculates eight points together as shown in the figure just below, where 
  
    
      
        c
        (
        
          φ
          
            i
          
        
        )
        =
        cos
        ⁡
        (
        
          φ
          
            i
          
        
        )
      
    
    {\displaystyle c(\varphi _{i})=\cos(\varphi _{i})}
  
.
The original 3-D DCT-II now can be written as

  
    
      
        X
        (
        
          k
          
            1
          
        
        ,
        
          k
          
            2
          
        
        ,
        
          k
          
            3
          
        
        )
        =
        
          ∑
          
            
              n
              
                1
              
            
            =
            1
          
          
            N
            −
            1
          
        
        
          ∑
          
            
              n
              
                2
              
            
            =
            1
          
          
            N
            −
            1
          
        
        
          ∑
          
            
              n
              
                3
              
            
            =
            1
          
          
            N
            −
            1
          
        
        
          
            
              x
              ~
            
          
        
        (
        
          n
          
            1
          
        
        ,
        
          n
          
            2
          
        
        ,
        
          n
          
            3
          
        
        )
        cos
        ⁡
        (
        φ
        
          k
          
            1
          
        
        )
        cos
        ⁡
        (
        φ
        
          k
          
            2
          
        
        )
        cos
        ⁡
        (
        φ
        
          k
          
            3
          
        
        )
      
    
    {\displaystyle X(k_{1},k_{2},k_{3})=\sum _{n_{1}=1}^{N-1}\sum _{n_{2}=1}^{N-1}\sum _{n_{3}=1}^{N-1}{\tilde {x}}(n_{1},n_{2},n_{3})\cos(\varphi k_{1})\cos(\varphi k_{2})\cos(\varphi k_{3})}
  

where 
  
    
      
        
          φ
          
            i
          
        
        =
        
          
            π
            
              2
              N
            
          
        
        (
        4
        
          N
          
            i
          
        
        +
        1
        )
        ,
        
           and 
        
        i
        =
        1
        ,
        2
        ,
        3.
      
    
    {\displaystyle \varphi _{i}={\frac {\pi }{2N}}(4N_{i}+1),{\text{ and }}i=1,2,3.}
  

If the even and the odd parts of 
  
    
      
        
          k
          
            1
          
        
        ,
        
          k
          
            2
          
        
      
    
    {\displaystyle k_{1},k_{2}}
  
 and 
  
    
      
        
          k
          
            3
          
        
      
    
    {\displaystyle k_{3}}
  
 and are considered, the general formula for the calculation of the 3-D DCT-II can be expressed as 

  
    
      
        X
        (
        
          k
          
            1
          
        
        ,
        
          k
          
            2
          
        
        ,
        
          k
          
            3
          
        
        )
        =
        
          ∑
          
            
              n
              
                1
              
            
            =
            1
          
          
            
              
                
                  N
                  2
                
              
            
            −
            1
          
        
        
          ∑
          
            
              n
              
                2
              
            
            =
            1
          
          
            
              
                
                  N
                  2
                
              
            
            −
            1
          
        
        
          ∑
          
            
              n
              
                1
              
            
            =
            1
          
          
            
              
                
                  N
                  2
                
              
            
            −
            1
          
        
        
          
            
              
                x
                ~
              
            
          
          
            i
            j
            l
          
        
        (
        
          n
          
            1
          
        
        ,
        
          n
          
            2
          
        
        ,
        
          n
          
            3
          
        
        )
        cos
        ⁡
        (
        φ
        (
        2
        
          k
          
            1
          
        
        +
        i
        )
        cos
        ⁡
        (
        φ
        (
        2
        
          k
          
            2
          
        
        +
        j
        )
        cos
        ⁡
        (
        φ
        (
        2
        
          k
          
            3
          
        
        +
        l
        )
        )
      
    
    {\displaystyle X(k_{1},k_{2},k_{3})=\sum _{n_{1}=1}^{{\tfrac {N}{2}}-1}\sum _{n_{2}=1}^{{\tfrac {N}{2}}-1}\sum _{n_{1}=1}^{{\tfrac {N}{2}}-1}{\tilde {x}}_{ijl}(n_{1},n_{2},n_{3})\cos(\varphi (2k_{1}+i)\cos(\varphi (2k_{2}+j)\cos(\varphi (2k_{3}+l))}
  

where

  
    
      
        
          
            
              
                x
                ~
              
            
          
          
            i
            j
            l
          
        
        (
        
          n
          
            1
          
        
        ,
        
          n
          
            2
          
        
        ,
        
          n
          
            3
          
        
        )
        =
        
          
            
              x
              ~
            
          
        
        (
        
          n
          
            1
          
        
        ,
        
          n
          
            2
          
        
        ,
        
          n
          
            3
          
        
        )
        +
        (
        −
        1
        
          )
          
            l
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
            +
            
              
                n
                2
              
            
          
          )
        
      
    
    {\displaystyle {\tilde {x}}_{ijl}(n_{1},n_{2},n_{3})={\tilde {x}}(n_{1},n_{2},n_{3})+(-1)^{l}{\tilde {x}}\left(n_{1},n_{2},n_{3}+{\frac {n}{2}}\right)}
  

  
    
      
        +
        (
        −
        1
        
          )
          
            j
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            ,
            
              n
              
                2
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                3
              
            
          
          )
        
        +
        (
        −
        1
        
          )
          
            j
            +
            l
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            ,
            
              n
              
                2
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                3
              
            
            +
            
              
                n
                2
              
            
          
          )
        
      
    
    {\displaystyle +(-1)^{j}{\tilde {x}}\left(n_{1},n_{2}+{\frac {n}{2}},n_{3}\right)+(-1)^{j+l}{\tilde {x}}\left(n_{1},n_{2}+{\frac {n}{2}},n_{3}+{\frac {n}{2}}\right)}
  

  
    
      
        +
        (
        −
        1
        
          )
          
            i
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
          
          )
        
        +
        (
        −
        1
        
          )
          
            i
            +
            j
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            +
            
              
                n
                2
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
          
          )
        
      
    
    {\displaystyle +(-1)^{i}{\tilde {x}}\left(n_{1}+{\frac {n}{2}},n_{2},n_{3}\right)+(-1)^{i+j}{\tilde {x}}\left(n_{1}+{\frac {n}{2}}+{\frac {n}{2}},n_{2},n_{3}\right)}
  

  
    
      
        +
        (
        −
        1
        
          )
          
            i
            +
            l
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                2
              
            
            ,
            
              n
              
                3
              
            
            +
            
              
                n
                3
              
            
          
          )
        
      
    
    {\displaystyle +(-1)^{i+l}{\tilde {x}}\left(n_{1}+{\frac {n}{2}},n_{2},n_{3}+{\frac {n}{3}}\right)}
  

  
    
      
        +
        (
        −
        1
        
          )
          
            i
            +
            j
            +
            l
          
        
        
          
            
              x
              ~
            
          
        
        
          (
          
            
              n
              
                1
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                2
              
            
            +
            
              
                n
                2
              
            
            ,
            
              n
              
                3
              
            
            +
            
              
                n
                2
              
            
          
          )
        
        
           where 
        
        i
        ,
        j
        ,
        l
        =
        0
        
           or 
        
        1.
      
    
    {\displaystyle +(-1)^{i+j+l}{\tilde {x}}\left(n_{1}+{\frac {n}{2}},n_{2}+{\frac {n}{2}},n_{3}+{\frac {n}{2}}\right){\text{ where }}i,j,l=0{\text{ or }}1.}
  


===== Arithmetic complexity =====
The whole 3-D DCT calculation needs 
  
    
      
         
        [
        
          log
          
            2
          
        
        ⁡
        N
        ]
         
      
    
    {\displaystyle ~[\log _{2}N]~}
  
 stages, and each stage involves 
  
    
      
         
        
          
            
              1
              8
            
          
        
         
        
          N
          
            3
          
        
         
      
    
    {\displaystyle ~{\tfrac {1}{8}}\ N^{3}~}
  
 butterflies. The whole 3-D DCT requires 
  
    
      
         
        
          [
          
            
              
                
                  1
                  8
                
              
            
             
            
              N
              
                3
              
            
            
              log
              
                2
              
            
            ⁡
            N
          
          ]
        
         
      
    
    {\displaystyle ~\left[{\tfrac {1}{8}}\ N^{3}\log _{2}N\right]~}
  
 butterflies to be computed. Each butterfly requires seven real multiplications (including trivial multiplications) and 24 real additions (including trivial additions). Therefore, the total number of real multiplications needed for this stage is 
  
    
      
         
        
          [
          
            
              
                
                  7
                  8
                
              
            
             
            
              N
              
                3
              
            
             
            
              log
              
                2
              
            
            ⁡
            N
          
          ]
        
         
        ,
      
    
    {\displaystyle ~\left[{\tfrac {7}{8}}\ N^{3}\ \log _{2}N\right]~,}
  
 and the total number of real additions i.e. including the post-additions (recursive additions) which can be calculated directly after the butterfly stage or after the bit-reverse stage are given by 
  
    
      
         
        
          
            
              
                [
                
                  
                    
                      3
                      2
                    
                  
                  
                    N
                    
                      3
                    
                  
                  
                    log
                    
                      2
                    
                  
                  ⁡
                  N
                
                ]
              
              ⏟
            
          
          
            Real
          
        
        +
        
          
            
              
                [
                
                  
                    
                      3
                      2
                    
                  
                  
                    N
                    
                      3
                    
                  
                  
                    log
                    
                      2
                    
                  
                  ⁡
                  N
                  −
                  3
                  
                    N
                    
                      3
                    
                  
                  +
                  3
                  
                    N
                    
                      2
                    
                  
                
                ]
              
              ⏟
            
          
          
            Recursive
          
        
        =
        
          [
          
            
              
                9
                2
              
            
            
              N
              
                3
              
            
            
              log
              
                2
              
            
            ⁡
            N
            −
            3
            
              N
              
                3
              
            
            +
            3
            
              N
              
                2
              
            
          
          ]
        
         
        .
      
    
    {\displaystyle ~\underbrace {\left[{\frac {3}{2}}N^{3}\log _{2}N\right]} _{\text{Real}}+\underbrace {\left[{\frac {3}{2}}N^{3}\log _{2}N-3N^{3}+3N^{2}\right]} _{\text{Recursive}}=\left[{\frac {9}{2}}N^{3}\log _{2}N-3N^{3}+3N^{2}\right]~.}
  

The conventional method to calculate MD-DCT-II is using a Row-Column-Frame (RCF) approach which is computationally complex and less productive on most advanced recent hardware platforms. The number of multiplications required to compute VR DIF Algorithm when compared to RCF algorithm are quite a few in number. The number of Multiplications and additions involved in RCF approach are given by 
  
    
      
         
        
          [
          
            
              
                3
                2
              
            
            
              N
              
                3
              
            
            
              log
              
                2
              
            
            ⁡
            N
          
          ]
        
         
      
    
    {\displaystyle ~\left[{\frac {3}{2}}N^{3}\log _{2}N\right]~}
  
 and 
  
    
      
         
        
          [
          
            
              
                9
                2
              
            
            
              N
              
                3
              
            
            
              log
              
                2
              
            
            ⁡
            N
            −
            3
            
              N
              
                3
              
            
            +
            3
            
              N
              
                2
              
            
          
          ]
        
         
        ,
      
    
    {\displaystyle ~\left[{\frac {9}{2}}N^{3}\log _{2}N-3N^{3}+3N^{2}\right]~,}
  
 respectively. From Table 1, it can be seen that the total number

of multiplications associated with the 3-D DCT VR algorithm is less than that associated with the RCF approach by more than 40%. In addition, the RCF approach involves matrix transpose and more indexing and data swapping than the new VR algorithm. This makes the 3-D DCT VR algorithm more efficient and better suited for 3-D applications that involve the 3-D DCT-II such as video compression and other 3-D image processing applications.
The main consideration in choosing a fast algorithm is to avoid computational and structural complexities. As the technology of computers and DSPs advances, the execution time of arithmetic operations (multiplications and additions) is becoming very fast, and regular computational structure becomes the most important factor. Therefore, although the above proposed 3-D VR algorithm does not achieve the theoretical lower bound on the number of multiplications, it has a simpler computational structure as compared to other 3-D DCT algorithms. It can be implemented in place using a single butterfly and possesses the properties of the Cooley–Tukey FFT algorithm in 3-D. Hence, the 3-D VR presents a good choice for reducing arithmetic operations in the calculation of the 3-D DCT-II, while keeping the simple structure that characterize butterfly-style Cooley–Tukey FFT algorithms.

The image to the right shows a combination of horizontal and vertical frequencies for an  8 × 8  
  
    
      
        (
         
        
          N
          
            1
          
        
        =
        
          N
          
            2
          
        
        =
        8
         
        )
      
    
    {\displaystyle (~N_{1}=N_{2}=8~)}
  
 two-dimensional DCT. Each step from left to right and top to bottom is an increase in frequency by 1/2 cycle.
For example, moving right one from the top-left square yields a half-cycle increase in the horizontal frequency. Another move to the right yields two half-cycles. A move down yields two half-cycles horizontally and a half-cycle vertically. The source data ( 8×8 ) is transformed to a linear combination of these 64 frequency squares.


=== MD-DCT-IV ===
The M-D DCT-IV is just an extension of 1-D DCT-IV on to M dimensional domain. The 2-D DCT-IV of a matrix or an image is given by

  
    
      
        
          X
          
            k
            ,
            ℓ
          
        
        =
        
          ∑
          
            n
            =
            0
          
          
            N
            −
            1
          
        
        
        
          ∑
          
            m
            =
            0
          
          
            M
            −
            1
          
        
         
        
          x
          
            n
            ,
            m
          
        
        cos
        ⁡
        
          (
          
             
            
              
                
                  
                  (
                  2
                  m
                  +
                  1
                  )
                  (
                  2
                  k
                  +
                  1
                  )
                   
                  π
                  
                
                
                  4
                  N
                
              
            
             
          
          )
        
        cos
        ⁡
        
          (
          
             
            
              
                
                  
                  (
                  2
                  n
                  +
                  1
                  )
                  (
                  2
                  ℓ
                  +
                  1
                  )
                   
                  π
                  
                
                
                  4
                  M
                
              
            
             
          
          )
        
         
        ,
      
    
    {\displaystyle X_{k,\ell }=\sum _{n=0}^{N-1}\;\sum _{m=0}^{M-1}\ x_{n,m}\cos \left(\ {\frac {\,(2m+1)(2k+1)\ \pi \,}{4N}}\ \right)\cos \left(\ {\frac {\,(2n+1)(2\ell +1)\ \pi \,}{4M}}\ \right)~,}
  

for 
  
    
      
         
         
        k
        =
        0
        ,
         
        1
        ,
         
        2
         
        …
         
        N
        −
        1
         
         
      
    
    {\displaystyle ~~k=0,\ 1,\ 2\ \ldots \ N-1~~}
  
 and 
  
    
      
         
         
        ℓ
        =
        0
        ,
         
        1
        ,
         
        2
        ,
         
        …
         
        M
        −
        1
         
        .
      
    
    {\displaystyle ~~\ell =0,\ 1,\ 2,\ \ldots \ M-1~.}
  

We can compute the MD DCT-IV using the regular row-column method or we can use the polynomial transform method for the fast and efficient computation. The main idea of this algorithm is to use the Polynomial Transform to convert the multidimensional DCT into a series of 1-D DCTs directly. MD DCT-IV also has several applications in various fields.


== Computation ==
Although the direct application of these formulas would require 
  
    
      
         
        
          
            O
          
        
        (
        
          N
          
            2
          
        
        )
         
      
    
    {\displaystyle ~{\mathcal {O}}(N^{2})~}
  
 operations, it is possible to compute the same thing with only 
  
    
      
         
        
          
            O
          
        
        (
        N
        log
        ⁡
        N
        )
         
      
    
    {\displaystyle ~{\mathcal {O}}(N\log N)~}
  
 complexity by factorizing the computation similarly to the fast Fourier transform (FFT). One can also compute DCTs via FFTs combined with 
  
    
      
         
        
          
            O
          
        
        (
        N
        )
         
      
    
    {\displaystyle ~{\mathcal {O}}(N)~}
  
 pre- and post-processing steps. In general, 
  
    
      
         
        
          
            O
          
        
        (
        N
        log
        ⁡
        N
        )
         
      
    
    {\displaystyle ~{\mathcal {O}}(N\log N)~}
  
 methods to compute DCTs are known as fast cosine transform (FCT) algorithms.
The most efficient algorithms, in principle, are usually those that are specialized directly for the DCT, as opposed to using an ordinary FFT plus 
  
    
      
         
        
          
            O
          
        
        (
        N
        )
         
      
    
    {\displaystyle ~{\mathcal {O}}(N)~}
  
 extra operations (see below for an exception). However, even "specialized" DCT algorithms (including all of those that achieve the lowest known arithmetic counts, at least for power-of-two sizes) are typically closely related to FFT algorithms – since DCTs are essentially DFTs of real-even data, one can design a fast DCT algorithm by taking an FFT and eliminating the redundant operations due to this symmetry. This can even be done automatically (Frigo & Johnson 2005). Algorithms based on the Cooley–Tukey FFT algorithm are most common, but any other FFT algorithm is also applicable. For example, the Winograd FFT algorithm leads to minimal-multiplication algorithms for the DFT, albeit generally at the cost of more additions, and a similar algorithm was proposed by (Feig & Winograd 1992a) for the DCT. Because the algorithms for DFTs, DCTs, and similar transforms are all so closely related, any improvement in algorithms for one transform will theoretically lead to immediate gains for the other transforms as well (Duhamel & Vetterli 1990).
While DCT algorithms that employ an unmodified FFT often have some theoretical overhead compared to the best specialized DCT algorithms, the former also have a distinct advantage: Highly optimized FFT programs are widely available. Thus, in practice, it is often easier to obtain high performance for general lengths N with FFT-based algorithms.
Specialized DCT algorithms, on the other hand, see widespread use for transforms of small, fixed sizes such as the  8 × 8  DCT-II used in JPEG compression, or the small DCTs (or MDCTs) typically used in audio compression. (Reduced code size may also be a reason to use a specialized DCT for embedded-device applications.)
In fact, even the DCT algorithms using an ordinary FFT are sometimes equivalent to pruning the redundant operations from a larger FFT of real-symmetric data, and they can even be optimal from the perspective of arithmetic counts. For example, a type-II DCT is equivalent to a DFT of size 
  
    
      
         
        4
        N
         
      
    
    {\displaystyle ~4N~}
  
 with real-even symmetry whose even-indexed elements are zero. One of the most common methods for computing this via an FFT (e.g. the method used in FFTPACK and FFTW) was described by Narasimha & Peterson (1978) and Makhoul (1980), and this method in hindsight can be seen as one step of a radix-4 decimation-in-time Cooley–Tukey algorithm applied to the "logical" real-even DFT corresponding to the DCT-II.
Because the even-indexed elements are zero, this radix-4 step is exactly the same as a split-radix step. If the subsequent size 
  
    
      
         
        N
         
      
    
    {\displaystyle ~N~}
  
 real-data FFT is also performed by a real-data split-radix algorithm (as in Sorensen et al. (1987)), then the resulting algorithm actually matches what was long the lowest published arithmetic count for the power-of-two DCT-II (
  
    
      
         
        2
        N
        
          log
          
            2
          
        
        ⁡
        N
        −
        N
        +
        2
         
      
    
    {\displaystyle ~2N\log _{2}N-N+2~}
  
 real-arithmetic operations).
A recent reduction in the operation count to 
  
    
      
         
        
          
            
              17
              9
            
          
        
        N
        
          log
          
            2
          
        
        ⁡
        N
        +
        
          
            O
          
        
        (
        N
        )
      
    
    {\displaystyle ~{\tfrac {17}{9}}N\log _{2}N+{\mathcal {O}}(N)}
  
 also uses a real-data FFT. So, there is nothing intrinsically bad about computing the DCT via an FFT from an arithmetic perspective – it is sometimes merely a question of whether the corresponding FFT algorithm is optimal. (As a practical matter, the function-call overhead in invoking a separate FFT routine might be significant for small 
  
    
      
         
        N
         
        ,
      
    
    {\displaystyle ~N~,}
  
 but this is an implementation rather than an algorithmic question since it can be solved by unrolling or inlining.)


== Example of IDCT ==

Consider this 8 × 8 grayscale image of capital letter A.

Each basis function is multiplied by its coefficient and then this product is added to the final image.


== See also ==
Discrete wavelet transform
JPEG - Discrete cosine transform - Contains a potentially easier to understand example of DCT transformation
List of Fourier-related transforms
Modified discrete cosine transform


== Notes ==


== References ==


== Further reading ==
Narasimha, M.; Peterson, A. (June 1978). "On the Computation of the Discrete Cosine Transform". IEEE Transactions on Communications. 26 (6): 934–936. doi:10.1109/TCOM.1978.1094144.
Makhoul, J. (February 1980). "A fast cosine transform in one and two dimensions". IEEE Transactions on Acoustics, Speech, and Signal Processing. 28 (1): 27–34. doi:10.1109/TASSP.1980.1163351.
Sorensen, H.; Jones, D.; Heideman, M.; Burrus, C. (June 1987). "Real-valued fast Fourier transform algorithms". IEEE Transactions on Acoustics, Speech, and Signal Processing. 35 (6): 849–863. CiteSeerX 10.1.1.205.4523. doi:10.1109/TASSP.1987.1165220.
Plonka, G.; Tasche, M. (January 2005). "Fast and numerically stable algorithms for discrete cosine transforms". Linear Algebra and Its Applications. 394 (1): 309–345. doi:10.1016/j.laa.2004.07.015.
Duhamel, P.; Vetterli, M. (April 1990). "Fast fourier transforms: A tutorial review and a state of the art". Signal Processing (Submitted manuscript). 19 (4): 259–299. Bibcode:1990SigPr..19..259D. doi:10.1016/0165-1684(90)90158-U.
Ahmed, N. (January 1991). "How I came up with the discrete cosine transform". Digital Signal Processing. 1 (1): 4–9. Bibcode:1991DSP.....1....4A. doi:10.1016/1051-2004(91)90086-Z.
Feig, E.; Winograd, S. (September 1992b). "Fast algorithms for the discrete cosine transform". IEEE Transactions on Signal Processing. 40 (9): 2174–2193. Bibcode:1992ITSP...40.2174F. doi:10.1109/78.157218.
Malvar, Henrique (1992), Signal Processing with Lapped Transforms, Boston: Artech House, ISBN 978-0-89006-467-2
Martucci, S. A. (May 1994). "Symmetric convolution and the discrete sine and cosine transforms". IEEE Transactions on Signal Processing. 42 (5): 1038–1051. Bibcode:1994ITSP...42.1038M. doi:10.1109/78.295213.
Oppenheim, Alan; Schafer, Ronald; Buck, John (1999), Discrete-Time Signal Processing (2nd ed.), Upper Saddle River, N.J: Prentice Hall, ISBN 978-0-13-754920-7
Frigo, M.; Johnson, S. G. (February 2005). "The Design and Implementation of FFTW3" (PDF). Proceedings of the IEEE. 93 (2): 216–231. Bibcode:2005IEEEP..93..216F. CiteSeerX 10.1.1.66.3097. doi:10.1109/JPROC.2004.840301. S2CID 6644892.
Boussakta, Said.; Alshibami, Hamoud O. (April 2004). "Fast Algorithm for the 3-D DCT-II" (PDF). IEEE Transactions on Signal Processing. 52 (4): 992–1000. Bibcode:2004ITSP...52..992B. doi:10.1109/TSP.2004.823472. S2CID 3385296.
Cheng, L. Z.; Zeng, Y. H. (2003). "New fast algorithm for multidimensional type-IV DCT". IEEE Transactions on Signal Processing. 51 (1): 213–220. doi:10.1109/TSP.2002.806558.
Wen-Hsiung Chen; Smith, C.; Fralick, S. (September 1977). "A Fast Computational Algorithm for the Discrete Cosine Transform". IEEE Transactions on Communications. 25 (9): 1004–1009. doi:10.1109/TCOM.1977.1093941.
Press, WH; Teukolsky, SA; Vetterling, WT; Flannery, BP (2007), "Section 12.4.2. Cosine Transform", Numerical Recipes: The Art of Scientific Computing (3rd ed.), New York: Cambridge University Press, ISBN 978-0-521-88068-8, archived from the original on 2011-08-11, retrieved 2011-08-13


== External links ==

Syed Ali Khayam: The Discrete Cosine Transform (DCT): Theory and Application
Implementation of MPEG integer approximation of 8x8 IDCT (ISO/IEC 23002-2)
Matteo Frigo and Steven G. Johnson: FFTW, FFTW Home Page. A free (GPL) C library that can compute fast DCTs (types I-IV) in one or more dimensions, of arbitrary size.
Takuya Ooura: General Purpose FFT Package, FFT Package 1-dim / 2-dim. Free C & FORTRAN libraries for computing fast DCTs (types II–III) in one, two or three dimensions, power of 2 sizes.
Tim Kientzle: Fast algorithms for computing the 8-point DCT and IDCT, Algorithm Alley.
LTFAT is a free Matlab/Octave toolbox with interfaces to the FFTW implementation of the DCTs and DSTs of type I-IV.