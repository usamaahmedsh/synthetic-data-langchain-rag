Bash (short for "Bourne Again SHell") is an interactive command interpreter and programming language developed for Unix-like operating systems. Created in 1989 by Brian Fox for the GNU Project, it is designed as a completely free software alternative for the Bourne shell, sh, and other proprietary Unix shells, supported by the Free Software Foundation. Having gained widespread adoption, Bash is commonly used as the default login shell for numerous Linux distributions. It also supports the execution of commands from files, known as shell scripts, facilitating automation.
The Bash command syntax is a superset of the Bourne shell's syntax, from which all basic features of the Bash syntax were copied. As a result, Bash can execute the vast majority of Bourne shell scripts without modification. Some other ideas were borrowed from the C shell, its successor tcsh, and the Korn Shell. It is available on nearly all modern operating systems, making it a versatile tool in various computing environments.


== Definitions ==


=== ASCII, strings and numbers ===
 The input language to the shell shall be first recognized at the character level.

Any series of characters is called a "string", or sometimes a "string literal". In Unix-like operating systems, all characters, printable and non-printing, except for a few such as the null character and forward slash /, can be used in filenames. In addition, all strings are case-sensitive.
Bash, like many other programming languages, uses zero-based numbering.


=== Control+key combinations ===
The Control+key functionality is provided by GNU Readline and is available in interactive mode only.
Certain keypress combinations allow a user to operate Bash to use tab completion and to search the command history.

Tab ↹ – Activate tab completion
↑ – Scroll up (i.e. backward) in the command history
↓ – Scroll down (i.e. forward) in the command history
Ctrl+r – Search the command history
Some keypress combinations also allow a user to operate the terminal emulator in order to move the cursor within the terminal window and to control the emulator program. By default, these keypress combinations in Bash mirror those of Emacs.
Default keybindings for control codes include:

Ctrl+f – Move the cursor one character to the right
Ctrl+b – Move the cursor one character to the left
Alt+f – Move the cursor one word to the right
Alt+b – Move the cursor one word to the left
Ctrl+a – Move the cursor to the beginning of the current commandline
Ctrl+c – Cancels the current command and presents a new prompt
Ctrl+d – Closes the current Bash instance, possibly also closing the terminal-emulator
Ctrl+e – Move the cursor to the end of the current commandline
Ctrl+q – Wake the terminal; buffered keypresses are then processed
Ctrl+s – Put the terminal to sleep
Ctrl+w – Remove one word to the left of the cursor
Ctrl+z – Stop a foregrounded process
Vi keybindings are also available and can be enabled by running set -o vi.


=== Syntax ===
When Bash reads a full command line, the complete string is broken down into tokens.
"Tokens" are identified using, and separated from each other using metacharacters.
As of Bash 5.3, the 10 metacharacters are the space, tab, and newline, as well as the following characters: |&;()<>
"Blanks" are composed entirely of unquoted metacharacters, "operators" each contain at least one unquoted metacharacter and "words" may not include any unquoted metacharacters.
In practice, Bash breaks down full command strings into tokens or groups of tokens that do contain metacharacters and tokens or groups of tokens that do not contain any metacharacters—called "words".
From there it further breaks words down into more specific, meaningful pieces like command names, variable assignment statements, etc.
The two blanks are space and tab.


==== Operators ====
Control operators perform a control function. They can be either a newline or one of the following: ||, &&, &, ;, ;;, ;&, ;;&, |, |&, (, or ).
Redirection operators redirect the input or output streams. They include <, >, &>, <<, and <<<.


==== Words ====
A word is a sequence of (non-meta-) characters treated as a single unit by the shell. A reserved word is a kind of a word that has a special meaning to the shell.
A name is a kind of a word separate from reserved words. Names consist solely of letters, underscores and numbers; which begins with either a letter or an underscore; which, however, may not begin with a number.
Names also called identifiers, may be used for naming variables and functions.
Sixteen of the twenty-two "reserved words", which may be characters or words are as follows:

Names may only contain the characters ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.
In the following example of a full command string, metacharacters have a comma placed above them, ,, reserved words have a caret placed beneath them, ^, and other tokens have a backtick placed also beneath them, `.


=== Subshells ===
A "subshell" is an additional instance of the shell which has been initialized by a current instance of the shell.
When a "parent" shell creates a subshell, or a "child" shell, an exact copy of the parent's environment information is re-created and becomes the environment of the subshell.
In Bash, in non-arithmetic contexts, one can force the use of a subshell by enclosing a full command string in single parentheses.

For this simple case, the preceding two commands are equivalent, however, use of subshells can have certain unexpected side effects.
There are numerous different forms of syntax which can cause the initialization of a subshell.


=== Expansion ===


=== Data structures ===
Bash offers variables and arrays as data structures, and though there are numerous kinds of each of these available, the data structures are relatively simple compared to other languages like C or Java. All data is stored in memory as a string.
Beginning a word with a dollar character signifies that the word is the name of a variable or array. 
Surrounding the dollar / variable name syntax in double quotes is always advised. This practice shields the value(s) held by the parameter(s) from unwanted side effects.
Wrapping the variable name in curly brackets (braces) {} is recommended for readability and consistency between variables and arrays. When writing variables, curly brackets are optional and square brackets would be a syntax error. The parameter names are always on the left side of the equals sign and values are always on the right.


==== Variables ====
A variable is assigned to using the syntax name=value.
To use a variable, the syntax $name is used, or ${name}, which expands to the value assigned to the variable.
The latter syntax must be used for certain names to prevent unwanted side effects. For example, $10 will be parsed as ${1}0, so using ${10} means it will be parsed as intended.
Positional parameters, usually passed to a bash script, are denoted by the variables numbered starting from $0.
Special parameters are signified by punctuation characters. For example, $@ expands to a list of the first through last positional parameters, "individually requoted, separated by spaces".
Environment variables are signified by all capital letters. Environment variables include UNIX variables like LESS_SIGUSR1, and Bourne shell variables such as HOME. Scripting variables are signified by all lower case letters or CamelCase. This is only convention; any variable can be passed to the export command to be made into an environment variable.


==== Arrays ====
Arrays are data structures which hold multiple values. Arrays have a set of square brackets placed at the end of the variable name and inside the curly braces. When writing arrays, curly braces and square brackets are required.
An array is assigned using the syntax name=( one or more elements ). It is expanded using ${quux[@]} or ${quux[*]} or ${quux[1]}, depending on the use case.
Each kind of parameter is distinguished by a specific naming convention.
Since Bash 4.0, Bash also supports associative arrays.
In this article, examples of variables from this section include ${foo}, PID, PWD, EUID, $$, ${quux}  and ${zork} .


=== Execution ===

"Execution" of a given program occurs when a user (or some other program) asks the operating system to act upon the instructions contained in the given program.
By default, Bash reads user code one line at a time, interprets any newline or semi-colon character ; as the end of the current command, and executes commands in sequence. If an interactive command extends beyond the width of the terminal emulator, it is usually possible to keep typing and the command will wrap around. To extend a command beyond a newline onto an additional line, it is necessary that the final character of the first line be an unescaped backslash, \, which signals "line continuation".
Bash always finishes parsing and executing one full commandline before moving on to and beginning with the parsing of the next commandline.

The first word of a command line is known as the "command position".
Under UNIX coventionality, the first word of the command line is always some kind of command, and the rest of the words in the command line string are either options for the command, arguments for the options, or some kind of input upon which the command will operate. "Options" are also called "flags", "switches", or, more formally, "operators". When Bash attempts to locate a command for execution, the directories it searches are those listed in the $PATH variable and the current working directory.


=== Users and PS1 ===
A user account can be created for either a human or a programmatic user.
In Unix-like operating systems, there are two kinds of users: "privileged" and "regular". A privileged user, such as root or the operating system kernel, is allowed to do anything whatsoever on the machine. Unprivileged users are limited in various ways.
When an interactive shell session waits for user input, by default it prints a particular string of characters to the screen. In Bash, the value of this waiting-string is held in the shell variable $PS1. For regular users, a common default value for $PS1 is the dollar character, $. For the superuser, a common default value is hashtag (#)


== Modes ==


=== Programming paradigm ===
Although most users think of the shell as an interactive command interpreter, it is really a programming language in which each statement runs a command. Because it must satisfy both the interactive and programming aspects of command execution, it is a strange language, shaped as much by history as by design.

Bash is written in C. A modular style can be approximated through good style and careful design. It is often used in an imperative or procedural style.


=== Interactive and non-interactive modes ===
As a command processor, Bash can operate in two modes: interactive or non-interactive.
In interactive mode, commands are usually read from a terminal emulator. In non-interactive mode, which facilitates automation, commands are usually read from named files known today as shell scripts. When executed as a standalone command at the command-line interface (CLI), by default Bash opens a new shell in interactive mode.


=== Scripts ===
Shell scripts are text files that contain code, often commands, intended to be read and acted upon by some particular interpreter in a batch process in a non-interactive mode and without any further user interaction. Interpreted scripts are programs that do not require their source code to be compiled: all of the relevant source code is contained within the script.
There are many programs which can serve as a script interpreter: Perl, AWK, etc. Interpreted scripts are most often written for Unix shells.
The first two characters of the first line of any (executable) shell script begins with a something called a shebang: literally the characters hashtag (#) and bang (!) side by side.

If a script is intended to be run by a user as a stand-alone program on the commandline, then it is referred to as an "executable". By convention, the filenames of executable unix shell scripts are identified the suffix .sh. The "execute" bit can be enabled on a shell script with the utility chmod:


=== The source builtin ===
With the source, or synonymous . command, Bash reads and executes shell commands from any text file by name.


=== Login and non-login shells ===

Bash can be executed as a login shell, or "session leader," in both interactive and non-interactive modes via the --login option. "Logging in" requires user authentication. For this reason, only one login shell exists per user session. In GNU/Linux, a user's login shell is identified in the /etc/passwd file.

When a human user initiates a login session, this procedure often occurs in a graphical user interface (GUI).
When a user opens a terminal emulator, the emulator executes a non-login instance of the user's login shell.
Logging out of a shell session from within a terminal emulator can be accomplished with the  exit command or, by default in Bash, pressing  Ctrl+d.


=== Startup source files ===

When Bash starts, it uses source to execute commands in a variety of dotfiles (see lists below).
These dotfiles, unlike shell scripts, typically have neither the execute permission enabled nor a hash-bang. By default Bash will source a somewhat different set of files, and in a different sequence, depending on:

How Bash is called: interactively, non-interactively, invoked with name sh
Which options are used: --login, --rcfile, --norc, --posix
Which environment variables are defined: BASH_ENV, ENV, and
Which files exist:
/etc/profile
~/.bash_profile
~/.bash_login
~/.profile
~/.bash_logout, and
~/.bashrc among others.
Of course, any startup file can also execute commands from any other file. 
Startup files can affect shell behavior, terminal emulators, the X window system and the window manager.


=== POSIX mode ===

The POSIX IEEE 1003.1 standard specifies a common set of definitions that any shell system application (bash, dash, zsh, etc.) may conform to.
Any shell user script (./myscript.sh) written in conformance with POSIX guidelines should be executable by any shell system application that has implemented the POSIX specification. As a result, there can be a reasonable expectation that POSIX-compliant scripts can be executed with success on any Unix or Unix-like operating systems which implements the POSIX standard (Linux, OpenBSD, Oracle Linux, HP-UX, etc.). These scripts are considered "portable" as they are and without any further modifications. The portion of POSIX that applies to shells and command line utilities is a subset of a larger group of POSIX standards that further specify how terminals and terminal emulators aught to function in order to also be considered portable.
When Bash is operating in POSIX mode, fewer features are available but the resulting code can be  executed on a greater variety of operating systems.
To enable POSIX mode at the initialization of an interactive shell, Bash can be executed as either sh, bash --posix or bash -o posix. To cause a script to be initialized in POSIX mode, one would use the either the hashbang #! /bin/env sh or the less portable #!/bin/sh. When an instance of Bash is operating in POSIX mode, the environment variable $POSIXLY_CORRECT is defined, and the value of the environment variable SHELLOPTS includes the string posix.

The full list of features available in Bash which are not specified by POSIX is considerable. Here is a partial list:

Any arrays other than the array of positional parameters, $@, are not POSIX
The double bracket extended test construct, [[...]], is not POSIX
[...] and test are POSIX
One of the double-parentheses arithmetic-evaluation syntaxes, ((...)), is not POSIX
$((...)) is POSIX
Brace expansion, kernel{,-headers}, is not POSIX
Dynamic scoping of parameters and the local builtin are not POSIX
Process substitution, <(...), is not POSIX
Certain string-manipulation operations in parameter expansions are not POSIX
Most Bash builtin commands are not POSIX
The command enable -s prints the list of Bourne special builtins, which are POSIX
The enable builtin itself is not POSIX
In Bash, in non-POSIX mode, the . and source builtins are synonymous
The . (i.e., 'dot') builtin is POSIX, however
The source builtin is not POSIX
The $EPOCHSECONDS and $EPOCHREALTIME shell variables are not POSIX
System commands which are available in modern Unix-like operating systems, and which are also specified by POSIX, may have fewer option flags or fewer relevant environment variables available under POSIX. Most (such as ls) are standalone programs in the /bin, /usr/bin, /sbin or /usr/sbin directories (in Linux, typically provided by GNU coreutils or BusyBox) rather than Bash builtins.
Because of these and other differences, modern (version 5) Bash shell scripts are rarely runnable "as-is" under the Bourne or legacy Korn shell interpreters. Scripting with portability in mind is becoming less common as GNU/Linux becomes more widespread.
Code that is valid syntax in Bash but not specified by POSIX is called a "bashism". The program checkbashisms can be used to make sure that a script can be executed in Debian Linux without any portability errors. Vidar Holen's shellcheck is another static linter written in Haskell which can parse script syntax for compatibility with any or all of bash, dash, ksh, and Bourne sh.
The syntax requirements for each shell are each a little different. For example, Debian's policy allows some extensions in their scripts (as they are in the dash shell), while a script intending to support pre-POSIX Bourne shells, like autoconf's configure, are even more limited in the features they can use.


=== Other modes ===


==== Restricted mode ====
A restricted shell is used to set up an environment more controlled than the standard shell. A restricted shell behaves identically to bash with the exception that numerous actions are disallowed or not performed, including:

Changing directories with the cd builtin.
Setting or unsetting the values of the SHELL, PATH, HISTFILE, ENV, or BASH_ENV variables.
Specifying command names containing slashes on the CLI.
Using absolute pathnames as arguments to the ., history, or hash -p commands.
Specifying a path search with . -p or command -p.
Importing function definitions and parsing the value of SHELLOPTS from the shell environment at startup.
Redirecting output using the >, >, <>, >&, &>, and >> redirection operators.
Using the exec builtin to replace the shell with another command.
Altering shell builtins.
Once restricted mode is enabled, it cannot be disabled. These restrictions are enforced after any startup files are read, and it does not apply to shell scripts. Restricted mode is rarely used.


==== Privileged mode ====
In Bash, "privileged mode" is a rarely used option inherited from the SVR4.2 UNIX System V shell (circa 1992). It can be enabled with set -p and disabled with set +p. When privileged mode is enabled, the SHELLOPTS shell variables includes the string "privileged".


==== Extended debugging mode ====
Enabled via bash --debugger at invocation or via shopt -s extdebug during either interactive or non-interactive modes. It uses a separate program called bashdb. extdebug is not available in POSIX mode. See documentation for more information. See also § Debugging.


==== Compatibility modes ====
 Bash-4.0 introduced the concept of a shell compatibility level, specified as a set of options to the shopt builtin (compat31, compat32, compat40, compat41, and so on). There is only one current compatibility level – each option is mutually exclusive. The compatibility level is intended to allow users to select behavior from previous versions that is incompatible with newer versions while they migrate scripts to use current features and behavior. It's intended to be a temporary solution.


== Observability ==


=== The  xtrace option ===
When  xtrace is enabled, simple debugging content is printed to the terminal.
It can be enabled with set -o xtrace or set -x, and disabled with set +o xtrace, set +x or set -.
These options are also accepted at the commandline and at hash-bangs: #!/bin/bash -x, etc.

The  xtrace shell setting is specified by POSIX.
See also § Debugging.


=== The  verbose option ===
The verbose option prints strings to the terminal as they are read, and before any expansions are performed. Rarely used.


=== Comments ===
Comments can be a valuable way of clarifying information or explaining a script or source file to someone else who might not be familiar with the scripter's intentions or context.
Standard comments in Bash are denoted with a hash character: #.
Any text to the right of the hash to the end of the line will be ignored.
Inline comments are allowed, but hash comments will not print during debugging. See also: § xtrace.
Comments denoted with a colon character, :, originated with the Thompson shell.
Any arguments to the right of colon : builtin are ignored.
Inline comments are not possible, but colon comments will print during debugging and any parameters will have been expanded.


=== Exit codes ===
When bash executes commands, exit status codes, also called "return codes," are produced which can offer some insight into the manner in which a program ceased running.
The value of the most recently captured exit code is held within the shell parameter, 'question mark:' $?.
In non-arithmetic contexts, (i.e., most of the time) the numerical or "Boolean" value of "true" is zero (0), and the value of "false" is one (1).
When a system command has executed, the intended meaning of its exit status can most often be found in its man page; usually a zero indicates success and a nonzero exit status indicates some kind of failure condition or partial success.
ping is a well known command with three meaningful exit codes: 0, 1, and 2.
In Bash, within arithmetic contexts, the numerical truth values are reversed: "true" is one and "false" is zero.
An arithmetic context can usually be identified by the syntax ((...)) or $((...)).
If an arithmetic statement evaluates to the integer zero, then the statement is considered "true," and the exit code is one.
If the statement evaluates to any number other than zero the arithmetic statement is "false" and the exit code is zero.
Not all Linux/UNIX commands provide meaningful exit codes beyond zero and one, and there is no standard system for definitions of exit codes in Linux.


=== Job control ===

The Bash shell has two modes of execution for commands: batch (asynchronous), and concurrent (synchronous).
To execute commands in batch mode (i.e., in sequence) they must be separated by the character ;, or on separate lines:

In this example, when  command1 is finished,  command2 is executed, and when  command2 has completed,  command3 will execute.
A background execution of  command1 can occur using symbol & at the end of an execution command, and process will be executed in background while immediately returning control to the shell and allowing continued execution of commands.

Or to have a concurrent execution of  command1 and  command2, they must be executed in the Bash shell in the following way:

In this case  command1 is executed in the background, & symbol, returning immediate control to the shell that executes  command2 in the foreground.
A process can be stopped and control returned to bash by typing Ctrl+z while the process is running in the foreground.
A list of all processes, both in the background and stopped, can be achieved by running jobs:

In the output, the number in brackets refers to the job id.
The plus sign signifies the default process for bg and fg.
The text "Running" and "Stopped" refer to the process state.
The last string is the command that started the process.
The state of a process can be changed using various commands.
The fg command brings a process to the foreground, while bg sets a stopped process running in the background.
bg and fg can take a job id as their first argument, to specify the process to act on.
Without one, they use the default process, identified by a plus sign in the output of jobs.
The kill command can be used to end a process prematurely, by sending it a signal.
The job id must be specified after a percent sign:

Job control, also known as "Monitor mode," is enabled by default in interactive shells, and can be disabled with set +m.


=== Signals ===
Signaling is a means of inter-process communication (IPC). Sometimes a commandline process may seem to freeze in the middle of execution.
In these instances it may become necessary to identify which process may be blocked and to manually end the offending process.
At an interactive terminal, it is usually sufficient to press  Ctrl-c to end the current foreground process and return control back to the user prompt, or to press  Ctrl-z to suspend it.
Occasionally attempting to suspend a process will succeed when attempts to cancel a process appear unresponsive.
In other cases it may be necessary to use the  kill program to send an IPC signal.
In this example, we use the  kill command from a second terminal screen to terminate the process with PID 4331.

In Unix-like operating systems, a user is allowed to instruct the kernel to send a signal to a process that is owned by the user.
A regular user may not send a signal to a privileged process.
Signals can be sent to a process using the  kill builtin or using the system binary of the same name.

The most commonly used signals can be viewed with kill -L | head -n 4.
Each IPC signal is associated with a signal number, but exit codes and signal codes are two different things. 
While sending a process an IPC signal of 9 (a "KILL" signal) will almost certainly terminate the process immediately, it will most likely not result in the process returning an exit code of 9.
By default in Bash, builtin kill sends a TERM ("terminate") signal.
It's common for commandline utilities to respond to a SIGTERM by shutting down and exiting cleanly. (TERM and SIGTERM are the same, the SIG- prefix to all signal names can be omitted.)
The Ctrl-c keypress sequence in Bash sends a SIGINT, interrupt signal, to the foreground process.
The Ctrl-z keypress sequence sends the SIGSTOP, stop signal.
When a process receives a SIGKILL, the process terminates immediately and messily.
It is recommended to use SIGKILL only as a last resort.
The SIGKILL signal cannot be blocked or handled.
Processes can "catch" and "handle" IPC signals they receive.
A user can use the kill builtin to "send" an IPC signal to another process.
That target process can set up a mechanism, some plan beforehand, for how to repsond whenever any particular signal might be received, or "caught."
The way a target program responds is referred to as how the program "handles" receiving the signal.
In the man pages one can see how some system commands will print out certain information to the terminal when they receive a SIGHUP: for example, the dd command.

 When bash is interactive, in the absence of any traps, it ignores SIGTERM (so that kill 0 does not kill an interactive shell), and catches and handles SIGINT (so that the  wait builtin is interruptible). When bash receives SIGINT, it breaks out of any executing loops. In all cases, bash ignores SIGQUIT. If job control is in effect, bash ignores SIGTTIN, SIGTTOU, and SIGTSTP.

By default Bash shell scripts receive and respond to any and all IPC signals sent to them, however, Bash scripts can utilize the  trap builtin to catch and handle signals.

There are a few signals which are only available from within Bash as GNU extensions: ERR, EXIT, RETURN and DEBUG.
These signals can be useful in debugging, and can only be sent and handled by shell builtins.
See also § Debugging.


=== Values of parameters ===
There are many different implementations of echo. Some have the -e option, and some don't.
The list of options is not uniform across implementations, though echo and printf are both specified by POSIX.
If a scripter wishes to know the precise value of a string contained by a variable, then the most consistent way of doing so is to use printf.
For any string containing any character (besides null?) including digits, the format specifier is %s.

For digits only, the format specifier is %d.

With printf, a newline is never included in the output unless the scripter includes a newline in the format string.
In the example below, where a newline has been omitted from the format string, the value of PS1 is printed on the same line as the output of the previous command.

Another very consistent method is to use declare -p.
The output of declare -p can be reused as input.
However, not all variables and parameters can be printed using declare -p, for example, the values of the Special Parameters.
The Special Parameter hashtag, "$#", reports how many Positional Parameters are currently defined.

For a full string of input at an interactive shell...

...the hashtag would be interpreted by Bash as an inline comment.
With the comment and all text to the right of it removed, the command that Bash would execute would be declare -p.
This command would, according to help declare, "display the values and attributes of each NAME," i.e., each variable, and, "if no NAMEs are given, display the values and attributes and values of all variables," which can be over 100 lines of output.
On the other hand, printf cannot display variables' attributes.
See also § Debugging.


=== Environment ===

Configurable execution environment(s):

Shell and session startup files such as ~/.bashrc and ~/.profile (i.e., dotfiles);
Settings (set built-in) and shell options (shopt built-in) which alter shell behavior;
Shell and session startup Files (a.k.a., "dot files")
When Bash starts, it executes the commands in a variety of dot files.
Unlike Bash shell scripts, dot files typically have neither the execute permission enabled nor an interpreter directive like #!/bin/bash.

Legacy-compatible Bash startup example
The example ~/.bash_profile below is compatible with the Bourne shell and gives semantics similar to csh for the ~/.bashrc and ~/.bash_login.
The [ -r filename ] && cmd is a short-circuit evaluation that tests if filename exists and is readable, skipping the part after the && if it is not.

Operating system issues in Bash startup
Some versions of Unix and Linux contain Bash system startup scripts, generally under the /etc directory.
Bash executes these files as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence.
The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup.
The startup scripts that launch the X window system may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the window manager.
These issues can often be addressed using a ~/.xsession or ~/.xprofile file to read the ~/.profile — which provides the environment variables that Bash shell windows spawned from the window manager need, such as xterm or Gnome Terminal.


=== Standard streams ===
Standard streams - STDIN, STDOUT and STDERR


== Commands ==


=== System commands ===


=== Aliases ===
 Aliases allow a string to be substituted for a word that is in a position in the input where it can be the first word of a simple command. Aliases have names and corresponding values that are set and unset using the alias and unalias builtin commands. 


=== Keywords and reversed words ===
function
Bash function declarations which include this particular keyword are not compatible with Bourne/Korn/POSIX scripts, however, Bash does accepts the function declaration syntax used by Bourne, Korn and POSIX-compliant shells.


=== Functions ===
 Shell functions are a way to group commands for later execution using a single name for the group. They are executed just like a "regular" simple command. When the name of a shell function is used as a simple command name, the shell executes the list of commands associated with that function name. Shell functions are executed in the current shell context; there is no new process created to interpret them.


=== Builtin commands ===
Various Built-In Commands:
POSIX Special builtins:
cd, pwd, etc.
set
Xtrace: [ set -x | set -o xtrace ].   The shell's primary means of debugging.   Both xtrace and verbose can be turned off at the same time with the command set -.
Verbose: [ set -v | set -o verbose ].   Prints a command to the terminal as Bash reads it.   Bash reads constructs all at once, such as compound commands which include if-fi and case-esac blocks.   If a set -v is included within a compound command, then "verbose" will be enabled the next time Bash reads code as input, i.e., after the end of the currently executing construct.
Both xtrace and verbose can be turned off at the same time with the command set -.
shopt
expand-aliases: On by default in interactive shells.   Some developers discourage its use in scripts.


=== PATH and system commands ===
When the shell looks for external commands, it relies on the Bourne shell variable $PATH. $PATH contains a list of directories separated by colons, :.
Beginning with the leftmost directory and selecting directories in a left to right pattern, each directory is searched until a match is found.
In Linux, so that a user can locate additional commands, it's common practice for distribution administrators and package developers to alter the value of an end user's $PATH by including source files in /etc/profile.d and other locations.
When looking for the command, chmod, for instance, after considering internal commands and finding nothing, Bash will search the directories in $PATH and will select the absolute path of the first executable found that has a basename which matches the search string.
If there is more than one command echo available in the directories listed in $PATH, during the process of parsing and executing a commandline, by default only the first command found will be selected.
$PATH lookups are slow.
The shell speeds up the commandline execution process by remembering command locations in a hash table.
To perform a full $PATH search without any interference from the hash table, remove the current table with hash -r and search for all kinds of commands with type -a.

In order to execute a commandline with a command found later in the $PATH string, you can specify an absolute path or you can anchor path resolution relative to the current working directory.

For security reasons it is advisable to make sure the directories in PATH are not world-writeable, or are writeable only by root and trusted users.


=== Command lookup ===
Command position: after expansions, the first word of the full text of the command line.
Command name lookup is performed, in the following order:
Commands internal to the shell:
Shell aliases,
Shell reserved words,
Shell functions, and
Shell built-in commands;
Commands external to the shell, using the PATH shell variable:
Separate UNIX-style programs such as ls or ln, and
Shell scripts, which are files containing executable commands.
The resulting string is executed as a command.


== Control structures ==


=== Subshells ===
Subshells: (...);


=== Pipelines ===
However, by using a pipeline, they can engage in multiple cycles of computation at the same time, substantially increasing their speed. In a pipelined control unit, different instructions simultaneously go through the process but at different points. While one instruction is being fetched, a second is being decoded, and so forth.
Unix-style pipelines: |.


=== Logical operators ===
AND (&&)
OR (||)
NOT (!)
Bash supplies "conditional execution" command separators that make execution of a command contingent on the exit code set by a precedent command.
For example:

Where ./do_something is only executed if the cd (change directory) command was "successful" (returned an exit status of zero) and the echo command would only be executed if either the cd or the ./do_something command return an "error" (non-zero exit status).


=== Iteration ===

 ITERATION: Sometimes programs are repeated indefinitely or until a specific outcome is reached. Each execution of the instructions is an "iteration."

while, until, and select loop compound commands;
Arithmetic C-style and list-enumerating for loop compound commands; and
continue, break, return, and exit flow control commands;


=== Compound commands ===
 compound: something formed by a union of elements or parts.

Bash also supports if ... fi and case ... esac forms of conditional command evaluation.


=== Testing ===
Built in commands for testing file attributes, comparing string and integer values, etc.:

Traditional test command,
Traditional single bracket test: [,
Modern double bracket test: [[...]], which includes advanced features:
Extended regular expression and extglob matching
Lexicographic comparisons with < and >;
((...)) numeric evaluation and testing; this includes almost all "C" language operators for arithmetic and numeric comparison;
For all commands the exit status is stored in the special variable $?.


=== Regular Expressions ===
Bash 3.0 supports in-process regular expression matching using a syntax reminiscent of Perl.
Regexp matching is limited to strings on the right side of the =~ operator in the [[..]] extended test construct.
[[ $line =~ [[:space:]]*(a)?b ]] means values for line like 'aab', ' aaaaaab', 'xaby', and ' ab' will all match, as will a line containing a 'b' anywhere in its value.


=== Coprocesses ===
 A coprocess is a shell command preceded by the coproc reserved word. A coprocess is executed asynchronously in a subshell, as if the command had been terminated with the '&' control operator, with a two-way pipe established between the executing shell and the coprocess.


== Data manipulation ==


=== Word Splitting ===
Split into words (i.e., word splitting)


=== Quoting ===
 When in doubt -- Quote!

Bash has certain quoting rules: uses of

single quotes '...'
double quotes "..."
backslashes \, and
ANSI-C quoting $'...'.
See also § Locales, $"..."
See also backticks `...`: § Deprecated syntax.


=== Unicode ===
Support for Unicode in echo -e and ANSI-C quoting.


=== Brace Expansion ===

Brace expansion, also called alternation, is a feature copied from the C shell.
It generates a set of alternative combinations.
Generated results need not exist as files.
The results of each expanded string are not sorted and left to right order is preserved:

Users should not use brace expansions in portable shell scripts, because the Bourne shell does not produce the same output.

When brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally.
Hence, a listing of JPEG and PNG images in the current directory could be obtained using:

In addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots.
Newer versions of Bash allow a third integer to specify the increment.

When brace expansion is combined with variable expansion (a.k.a., parameter expansion and parameter substitution) the variable expansion is performed after the brace expansion, which in some cases may necessitate the use of the eval built-in, thus:


=== Tilde Expansion ===


=== Parameter and variable expansion ===
Type
Shell parameters
Environment variables
User variables
Scope
Arrays
Indexed arrays: size is unlimited.
Associative arrays: via declare -A
Parameter Expansion
Expansion syntaxes which can perform some tasks more quickly than external utilities, including, among others:
Pattern Substitution
${foo//x/y} for sed 's/x/y/g',
Remove Matching Prefix or Suffix Pattern
${bar##[a-zA-Z0-9]*} for cut -c8-,
Enumerate Array Keys
${!array[@]}, and
Display Error if Null or Unset
${var:?error message},


=== Pathname expansion ===
Pathname expansion, i.e., shell-style globbing and pattern matching using *, ?, [...].


=== Locales ===
Locale-specific translation via $"..." quoting syntax.


== Process redirections and parsing ==


=== Command substitution ===
Command substitution: $(...),


=== Process substitution ===
Process substitution, <() or >(), when a system supports it:
Bash supports process substitution using the <(command) and >(command) syntax, which substitutes the output of (or input to) a command where a filename is normally used.
(This is implemented through /proc/fd/ unnamed pipes on systems that support that, or via temporary named pipes where necessary).


=== Arithmetic expansion ===
Arithmetic expansion, ((...)) or $((...)), including

Integer arithmetic in any base from two to sixty-four, although
Floating-point arithmetic is not available from within the shell itself (for this functionality, see current versions of bc and awk, among others),
Bash can perform integer calculations ("arithmetic evaluation") without spawning external processes.
It uses the ((...)) command and the $((...)) variable syntax for this purpose.


=== Redirection ===
Redirections of Standard Input, Standard Output and Standard Error data streams are performed, including

File writing, >, and appending, >>,
Here documents, <<,
Here strings, <<<, which allow parameters to be used as input, and
A redirection operator, >|, which can force overwriting of a file when a shell's noclobber setting is enabled;
Its syntax simplifies I/O redirection.
For example, it can redirect standard output (stdout) and standard error (stderr) at the same time using the &> operator.
This is simpler to type than the Bourne shell equivalent 'command > file 2>&1'.
Bash supports here documents.
Since version 2.05b Bash can redirect standard input (stdin) from a "here string" using the <<< operator.


=== Command parsing ===
(A) Comments are ignored, from an unquoted # (hash) to the end of the same line;
(B) Commands are parsed one line at a time:
Control structures are honored, and
Backslash \ escapes are also honored at the ends of lines;
(C) Split into words (i.e., word splitting) according to quoting rules,
Including ANSI-C quoting $'...';
(D) Seven types of expansions are performed in the following order on the resulting string:
(Type 1) Brace expansion kernel{-headers},
(Type 2) Tilde expansion ~,
In a left-to-right fashion:
(Type 3) Parameter and variable expansion $foo or ${bar}, including
(Type 4) Command substitution: $(...),
(Type 5) Process substitution, <() or >(), when a system supports it:
(Type 6) Arithmetic expansion, ((...)) or $((...)), including
Integer arithmetic in any base from two to sixty-four, although
Floating-point arithmetic is not available from within the shell itself.
Word splitting (again),
(Type 7) Pathname expansion, i.e., shell-style globbing and pattern matching using *, ?, [...],
Quote removal;
(E) Redirections of Standard Input, Standard Output and Standard Error data streams are performed, including
File writing, >, and appending, >>,
Here documents, <<,
Here strings, <<<, which allow parameters to be used as input, and
A redirection operator, >|, which can force overwriting of a file when a shell's noclobber setting is enabled;
(F) Command name lookup is performed, in the following order:
Commands internal to the shell:
Shell aliases,
Shell reserved words,
Shell functions, and
Shell built-in commands;
Commands external to the shell:
Separate UNIX-style programs such as ls or ln, and
Shell scripts, which are files containing executable commands.
(G) The resulting string is executed as a command.


== Interactive-only features ==


=== Command History ===
Unlimited size command history.
This feature is available in interactive mode only.


=== Directory stack ===
A directory stack (pushd and popd built-ins) feature is available in interactive mode only.


=== Programmable completion ===
Also known as "tab completion" or "command-line completion", when a user presses the Tab ↹, within an interactive command-shell Bash automatically uses any available  completion scripts to suggest partly typed program names, filenames and variable names.

The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.
Bash supports programmable completion via built-in complete, compopt, and compgen commands.
The feature has been available since the beta version of 2.04 released in 2000.
These commands enable complex and intelligent completion specification for commands (i.e., installed programs), functions, variables, and filenames.
The complete and compopt two commands specify how arguments of some available commands or options are going to be listed in the readline input.As of version 5.1 completion of the command or the option is usually activated by the  Tab keystroke after typing its name.
This feature is available in interactive mode only.


=== Prompts ===
Configurable prompts.
This feature is available in interactive mode only.


== Documentation ==


=== User Manual ===
A user manual for Bash is provided by the GNU Project.
It is sometimes considered to be a more user-friendly document than the man page.
"You may also find information about Bash ...by looking at /usr/share/doc/bash, /usr/local/share/doc/bash, or similar directories on your system."
On GNU/Linux systems, if the info program is available then the GNU Manual version relevant for your installation should also be available at info bash.


=== Man page ===
The most recent technical manual, or 'man page', is intended to be the authoritative explanatory technical document for the understanding of how bash operates.
On GNU/Linux systems, the version relevant for your installation is usually available through the man program at man bash.


=== help builtin ===
With recent versions of Bash, information on shell built-in commands can be found by executing help, help [name of builtin] or man builtins at a terminal prompt where bash is installed.
The printf command can be invoked via env to ensure that you run the program found via your shell's search path, and not a shell alias or built-in function: env printf --help.


=== POSIX Specification ===
For the purpose of allowing inter-operability among different shell programs running on different operating systems, the POSIX Specification influences how modern UNIX-like shells are written.
Bash "is intended to be a conformant implementation of the IEEE POSIX "Shell and Utilities" portion of the IEEE POSIX specification (IEEE Standard 1003.1)."
The most recent publication of the standard (2024) is available online.
As the standard upon which bash is based, the POSIX Standard, or IEEE Std 1003.1,
et seq, is especially informative.


=== Further resources ===
"The project maintainer also has a Bash page which includes Frequently Asked Questions",
this FAQ is current as of bash version 5.1 and is no longer updated.
Informal avenues of support are available via IRC at libera.chat, in the #bash channel, and mailing lists are available at Bash - GNU Project - Free Software Foundation.


== Security and vulnerabilities ==


=== Root scripts ===
Running any shell scripts as the root user has, for years, been widely criticized as poor security practice.
One commonly given reason is that, when a script is executed as root, the negative effects of any bugs in a script would be magnified by root's elevated privileges.
One common example: a script contains the command, rm -rf ${dir}/, but the variable $dir is left undefined.
In Linux, if the script was executed by a regular user, the shell would attempt to execute the command rm -rf / as a regular user, and the command would fail.
However, if the script was executed by the root user, then the command would likely succeed and the filesystem would be erased.
It is recommended to use sudo on a per-command basis instead.


=== CGI scripts ===
CGI scripts are a significant source of vulnerability.


=== builtin eval ===
"The eval command is extremely powerful and extremely easy to abuse."


=== Input validation ===
"Input validation is the process of ensuring data has undergone data cleansing to confirm it has data quality, that is, that it is both correct and useful."

 Input validation is performed to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.


=== Shellshock ===
In September 2014, a security bug was discovered
in the program.
It was dubbed "Shellshock." Public disclosure quickly led to a range of attacks across the Internet.
Exploitation of the vulnerability could enable arbitrary code execution in CGI scripts executable by certain versions of Bash.
The bug involved how Bash passed function definitions to subshells through environment variables.
The bug had been present in the source code since August 1989 (version 1.03) and was patched in September 2014 (version 4.3).
Patches to fix the bugs were made available soon after the bugs were identified.
Upgrading to a current version is strongly advised.
It was assigned the Common Vulnerability identifiers CVE-2014-6271, CVE-2014-6277 and CVE-2014-7169, among others.
Under CVSS Metrics 2.x and 3.x, the bug is regarded as "high" and "critical", respectively.


== Deprecated syntax ==

Backtick style command substitutions: `...` is deprecated in favor of
$(...);
Use of -a or -o in test/[/[[ commands,
for example, [ -r ./file -a ! -l ./file ] is deprecated in favor of
[ -r ./file ] && ! [ -l ./file ];
Use of the arithmetic syntax $[...] is deprecated in favor of
$((...)) or
((...)), as appropriate;
Use of ^ as a pipeline is deprecated in favor of |;
Any uses of expr or let.


== Debugging ==


=== Table of Features ===

Shell features specified by POSIX:
Parameter Expansions:
Special Parameters:
Special Built-In Utility set:
Special Built-In Utility trap:
POSIX does specify certain uses of the trap builtin: ...
Utility printf: a means of reliably printing the contents of a variable:
Bash features not specified by POSIX:
Bash Variables:
Shell Builtin set:
Shell Builtin shopt:
Shell Builtin trap:
While POSIX does specify certain uses of the trap builtin, the following signal specs are Bash extensions: ...
Third party debugging utilities:
ShellCheck: Shell script analysis tool;
devscripts-checkbashisms: Check whether a /bin/sh script contains any common bash-specific constructs;
kcov: Code coverage tool without special compilation options;
Bashdb: The Bash symbolic debugger.


==== Examples ====
With the "${var:?}" parameter expansion, an unset or null variable can halt a script.

Reliably printing the contents of an array that contains spaces and newlines first in a portable syntax, and then the same thing in Bash.
Note that POSIX doesn't have named array, only the list of arguments, "$@", which can be re-set by the set builtin.

Note that in Bash, the number of spaces before the newline is made clear.

Printing an error message when there's a problem.

Using xtrace.
If errexit had been enabled, then echo quux would not have been executed.

Note: $BASHPID differs from $$ in certain circumstances, such as subshells that do not require bash to be reinitialized.


=== Bug reporting ===

An external command called bashbug reports Bash shell bugs.
When the command is invoked, it brings up the user's default editor with a form to fill in.
The form is mailed to the Bash maintainers (or optionally to other email addresses).


== History ==
Shell script functionality originated with files called "runcoms" in reference to the 1963 macro processor of the same name.
The suffix "rc" is short for "runcom."
The term "shell" was coined by Louis Pouzin in 1964 or 1965,
and appeared in his 1965 paper, "The SHELL, A Global Tool for Calling and Chaining Procedures in the System," which describes many features later found in many UNIX shells.
The ASCII standard for character encoding was defined in 1969 in a document called Request for Comments (RFC) 20.


=== Timeline ===
Significant events in Bash history are listed below:


== See also ==

Comparison of command shells
Multics § Commands, exec_com: the first command processor.
FTP download from GNU Project of Bash versions 1.14.0 to current.


=== Unix shells ===


=== Graphical interface to scripts ===
There are many programs that allow you to create a graphical interface for shell scripts.

curses - curses is a terminal control library for Unix-like systems, enabling the construction of text user interfaces (TUI) applications.
dialog - is a utility that allows you to create dialog boxes in the console, using the curses and ncurses libraries.
gtkdialog - is the most functional utility for creating graphical applications on bash scripts.
kdialog - is a KDE  equivalent of zenity.
ncurses - a programming library for creating textual user interfaces (TUI's) that work across a wide variety of terminals.
whiptail - is an analogue of the dialog utility, it uses the newt library.
xdialog - is a replacement for dialog that is designed to give programs launched from the terminal an X Window System interface.
yad - is a fork of zenity, with more features.
zenity - is the most popular application for creating a graphical interface for scripts.


== Further reading ==
[A]
"Shell Scripting Primer". apple.com. Apple. Retrieved 8 August 2025. Copyright © 2003, 2014 Apple Inc All Rights Reserved. ... Updated: 2014-03-10
[G]
"Shell Style Guide". github.io. Google. Retrieved 8 August 2025.
[H]
Stephenson, Neal (2003). In the Beginning... Was the Command Line. HarperCollins. ISBN 978-0-380-81593-7.
[I]
M. Jones (9 December 2011). "Evolution of shells in Linux: From Bourne to Bash and beyond". ibm.com. IBM. Retrieved 8 August 2025.
[M]
Pouzin, Louis (2 April 1965). "The SHELL: A Global Tool for Calling and Chaining Procedures in the System" (PDF). mit.edu. Massachusetts Institute of Technology. Retrieved 8 August 2025.
[O]
Newham, Cameron; Rosenblatt, Bill. "Learning the Bash Shell, 2e". oreilly.com. O'Reilly Media, Inc. Retrieved 8 August 2025. Content preview
[U]
"Scripting Reference :: Scripting with the Bourne-Again Shell (Bash)". berkeley.edu. University of California, Berkeley. Retrieved 19 May 2024.
"IRIS :: Instructional & Research Information Systems :: FAQ: Unix :: About UNIX Shells". berkeley.edu. University of California, Berkeley. Retrieved 8 August 2025.


== Notes ==


== References ==