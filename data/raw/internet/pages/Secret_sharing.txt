Secret sharing (also called secret splitting) refers to methods for distributing a secret among a group, in such a way that no individual holds any intelligible information about the secret, but when a sufficient number of individuals combine their 'shares', the secret may be reconstructed. Whereas insecure secret sharing allows an attacker to gain more information with each share, secure secret sharing is 'all or nothing' (where 'all' means the necessary number of shares).
In one type of secret sharing scheme there is one dealer and n players. The dealer gives a share of the secret to the players, but only when specific conditions are fulfilled will the players be able to reconstruct the secret from their shares. The dealer accomplishes this by giving each player a share in such a way that any group of t (for threshold) or more players can together reconstruct the secret but no group of fewer than t players can. Such a system is called a (t, n)-threshold scheme (sometimes it is written as an (n, t)-threshold scheme).
Secret sharing was invented independently by Adi Shamir and George Blakley in 1979.


== Importance ==
Secret sharing schemes are ideal for storing information that is highly sensitive and highly important.  Examples include:  encryption keys, missile launch codes, and numbered bank accounts.  Each of these pieces of information must be kept highly confidential, as their exposure could be disastrous; however, it is also critical that they should not be lost.  Traditional methods for encryption are ill-suited for simultaneously achieving high levels of confidentiality and reliability.  This is because when storing the encryption key, one must choose between keeping a single copy of the key in one location for maximum secrecy, or keeping multiple copies of the key in different locations for greater reliability.  Increasing reliability of the key by storing multiple copies lowers confidentiality by creating additional attack vectors; there are more opportunities for a copy to fall into the wrong hands.  Secret sharing schemes address this problem, and allow arbitrarily high levels of confidentiality and reliability to be achieved.
Secret sharing also allows the distributor of the secret to trust a group 'in aggregate'. Traditionally, giving a secret to a group for safekeeping would require that the distributor completely trust all members of the group. Secret sharing schemes allow the distributor to securely store the secret with the group even if not all members can be trusted all the time. So long as the number of traitors is never more than the critical number needed to reconstruct the secret, the secret is safe.
Secret sharing schemes are important in cloud computing environments. Thus a key can be distributed over many servers by a threshold secret sharing mechanism. The key is then reconstructed when needed.
Secret sharing has also been suggested for sensor networks where the links are liable to be tapped, by sending the data in shares which makes the task of the eavesdropper harder. The security in such environments can be made greater by continuous changing of the way the shares are constructed.


== "Secure" versus "insecure" secret sharing ==
A secure secret sharing scheme distributes shares so that anyone with fewer than t shares has no more information about the secret than someone with 0 shares.
Consider for example the secret sharing scheme in which the secret phrase "password" is divided into the shares "pa––––––", "––ss––––", "––––wo––", and "––––––rd". A person with 0 shares knows only that the password consists of eight letters, and thus would have to guess the password from 268 = 208 billion possible combinations. A person with one share, however, would have to guess only the six letters, from 266 = 308 million combinations, and so on as more persons collude. Consequently, this system is not a "secure" secret sharing scheme, because a player with fewer than t secret shares is able to reduce the problem of obtaining the inner secret without first needing to obtain all of the necessary shares.
In contrast, consider the secret sharing scheme where X is the secret to be shared, Pi are public asymmetric encryption keys and Qi their corresponding private keys. Each player J is provided with {P1(P2(...(PN(X)))), Qj}. In this scheme, any player with private key 1 can remove the outer layer of encryption, a player with keys 1 and 2 can remove the first and second layer, and so on. A player with fewer than N keys can never fully reach the secret X without first needing to decrypt a public-key-encrypted blob for which he does not have the corresponding private key – a problem that is currently believed to be computationally infeasible. Additionally we can see that any user with all N private keys is able to decrypt all of the outer layers to obtain X, the secret, and consequently this system is a secure secret distribution system.


== Limitations ==
Several secret-sharing schemes are said to be information-theoretically secure and can be proven to be so, while others give up this unconditional security for improved efficiency while maintaining enough security to be considered as secure as other common cryptographic primitives.  For example, they might allow secrets to be protected by shares with entropy of 128 bits each, since each share would be considered enough to stymie any conceivable present-day adversary, requiring a brute force attack of average size 2127.
Common to all unconditionally secure secret sharing schemes, there are limitations:

Each share of the secret must be at least as large as the secret itself. This result is based in information theory, but can be understood intuitively. Given t − 1 shares, no information whatsoever can be determined about the secret. Thus, the final share must contain as much information as the secret itself. There is sometimes a workaround for this limitation by first compressing the secret before sharing it, but this is often not possible because many secrets (keys for example) look like high-quality random data and thus are hard to compress.
All secret-sharing schemes use random bits for constructing the shares. To distribute a one-bit secret shares with a  threshold of t shares, t − 1 random bits are needed. To distribute a secret of b bits, entropy of (t − 1) × b bits is necessary.


== Trivial secret sharing ==
Note: n is the total number of 'players', among whom the shares are distributed, and t is the minimum number of players required to reveal the secret.


=== t = 1 ===
t = 1 secret sharing is trivial. The secret can simply be distributed to all n participants.


=== t = n ===
There are several (t, n) secret-sharing schemes for t = n, when all shares are necessary to recover the secret:

Encode the secret as a binary number s of any length. For each player i, where i is one fewer than the total number of players, give a random binary number pi of the same length as s. To the player without a share, give the share calculated as pn = s ⊕ p1 ⊕ p2 ⊕ ... ⊕ pn−1, where ⊕ denotes bitwise exclusive or. The secret is the bitwise exclusive-or of all the players' numbers (pi, for 1 ≤ i ≤ n).
Instead, (1) can be performed using the binary operation in any group.  For example, take the cyclic group of integers with addition modulo 232, which corresponds to 32-bit integers with addition defined with the binary overflow being discarded.  The secret s can be partitioned into a vector of M 32-bit integers, which we call vsecret.  Then (n − 1) of the players are each given a vector of M 32-bit integers that is drawn independently from a uniform probability distribution, with player i receiving vi.  The remaining player is given vn = vsecret − v1 − v2 − ... − vn−1.  The secret vector can then be recovered by summing across all the players' vectors.


=== 1 < t < n ===
The difficulty lies in creating schemes that are still secure, but do not require all n shares.
When space efficiency is not a concern, trivial t = n schemes can be used to reveal a secret to any desired subsets of the players simply by applying the scheme for each subset. For example, to reveal a secret s to any two of the three players Alice, Bob and Carol, create three (
  
    
      
        
          
            
              (
            
            
              3
              2
            
            
              )
            
          
        
      
    
    {\displaystyle {\binom {3}{2}}}
  
) different t = n = 2 secret shares for s, giving the three sets of two shares to Alice and Bob, Alice and Carol, and Bob and Carol.


=== t belonging to any desired subset of {1, 2, ..., n} ===
For example, imagine that the board of directors of a company would like to protect their secret formula. The president of the company should be able to access the formula when needed, but in an emergency any 3 of the 12 board members would be able to unlock the secret formula together. One of the ways this can be accomplished is by a secret-sharing scheme with t = 3 and n = 15, where 3 shares are given to the president, and one share is given to each board member.


== Efficient secret sharing ==
The trivial approach quickly becomes impractical as the number of subsets increases, for example when revealing a secret to any 50 of 100 players, which would require 
  
    
      
        
          
            
              (
            
            
              100
              50
            
            
              )
            
          
        
        ≈
        1.009
        ×
        
          10
          
            29
          
        
      
    
    {\displaystyle {\binom {100}{50}}\approx 1.009\times 10^{29}}
  
 schemes to be created and each player to maintain 
  
    
      
        
          
            
              (
            
            
              99
              49
            
            
              )
            
          
        
        ≈
        5.04
        ×
        
          10
          
            28
          
        
      
    
    {\displaystyle {\binom {99}{49}}\approx 5.04\times 10^{28}}
  
 distinct sets of shares for each scheme. In the worst case, the increase is exponential. This has led to the search for schemes that allow secrets to be shared efficiently with a threshold of players.


=== Shamir's scheme ===

In this scheme, any t out of n shares may be used to recover the secret.  The system relies on the idea that one can construct a unique polynomial of degree t − 1, such that each of the t points lies on the polynomial.  It takes two points to define a straight line, three points to fully define a quadratic, four points to define a cubic curve, and so on. That is, it takes t points to define a polynomial of degree t − 1.   The method is to create a polynomial of degree t − 1 with the secret as the first coefficient and the remaining coefficients picked at random.  Next find n points on the curve and give one to each of the players.  When at least t out of the n players reveal their points, there is sufficient information to fit a (t − 1)th degree polynomial to them, the first coefficient being the secret.


=== Blakley's scheme ===
Two nonparallel lines in the same plane intersect at exactly one point. Three nonparallel planes in space intersect at exactly one point. More generally, any n nonparallel (n − 1)-dimensional hyperplanes intersect at a specific point. The secret may be encoded as any single coordinate of the point of intersection.  If the secret is encoded using all the coordinates, even if they are random, then an insider (someone in possession of one or more of the (n − 1)-dimensional hyperplanes) gains information about the secret since he knows it must lie on his plane.  If an insider can gain any more knowledge about the secret than an outsider can, then the system no longer has information theoretic security.  If only one of the n coordinates is used, then the insider knows no more than an outsider (i.e., that the secret must lie on the x-axis for a 2-dimensional system).  Each player is given enough information to define a hyperplane; the secret is recovered by calculating the planes' point of intersection and then taking a specified coordinate of that intersection.

Blakley's scheme is less space-efficient than Shamir's; while Shamir's shares are each only as large as the original secret, Blakley's shares are t times larger, where t is the threshold number of players. Blakley's scheme can be tightened by adding restrictions on which planes are usable as shares. The resulting scheme is equivalent to Shamir's polynomial system.


=== Using the Chinese remainder theorem ===

The Chinese remainder theorem can also be used in secret sharing, for it provides us with a method to uniquely determine a number S modulo k many pairwise coprime integers 
  
    
      
        
          m
          
            1
          
        
        ,
        
          m
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          m
          
            k
          
        
      
    
    {\displaystyle m_{1},m_{2},...,m_{k}}
  
, given that 
  
    
      
        S
        <
        
          ∏
          
            i
            =
            1
          
          
            k
          
        
        
          m
          
            i
          
        
      
    
    {\displaystyle S<\prod _{i=1}^{k}m_{i}}
  
. There are two secret sharing schemes that make use of the Chinese remainder theorem, Mignotte's and Asmuth-Bloom's Schemes. They are threshold secret sharing schemes, in which the shares are generated by reduction modulo the integers 
  
    
      
        
          m
          
            i
          
        
      
    
    {\displaystyle m_{i}}
  
, and the secret is recovered by essentially solving the system of congruences using the Chinese remainder theorem.


== Proactive secret sharing ==

If the players store their shares on insecure computer servers, an attacker could crack in and steal the shares. If it is not practical to change the secret, the uncompromised (Shamir-style) shares can be renewed. The dealer generates a new random polynomial with constant term zero and calculates for each remaining player a new ordered pair, where the x-coordinates of the old and new pairs are the same. Each player then adds the old and new y-coordinates to each other and keeps the result as the new y-coordinate of the secret.
All of the non-updated shares the attacker accumulated become useless. An attacker can only recover the secret if he can find enough other non-updated shares to reach the threshold. This situation should not happen because the players deleted their old shares. Additionally, an attacker cannot recover any information about the original secret from the update files because they contain only random information.
The dealer can change the threshold number while distributing updates, but must always remain vigilant of players keeping expired shares.


== Verifiable secret sharing ==

A player might lie about his own share to gain access to other shares. A verifiable secret sharing (VSS) scheme allows players to be certain that no other players are lying about the contents of their shares, up to a reasonable probability of error. Such schemes cannot be computed conventionally; the players must collectively add and multiply numbers without any individual's knowing what exactly is being added and multiplied. Tal Rabin and Michael Ben-Or devised a multiparty computing (MPC) system that allows players to detect dishonesty on the part of the dealer or on part of up to one third of the threshold number of players, even if those players are coordinated by an "adaptive" attacker who can change strategies in realtime depending on what information has been revealed.


== Computationally secure secret sharing ==
The disadvantage of unconditionally secure secret sharing schemes is that the storage and transmission of the shares requires an amount of storage and bandwidth resources equivalent to the size of the secret times the number of shares.  If the size of the secret were significant, say 1 GB, and the number of shares were 10, then 10 GB of data must be stored by the shareholders.  Alternate techniques have been proposed for greatly increasing the efficiency of secret sharing schemes, by giving up the requirement of unconditional security.
One of these techniques, known as secret sharing made short, combines Rabin's information dispersal algorithm (IDA) with Shamir's secret sharing.  Data is first encrypted with a randomly generated key, using a symmetric encryption algorithm.  Next this data is split into N pieces using Rabin's IDA.  This IDA is configured with a threshold, in a manner similar to secret sharing schemes, but unlike secret sharing schemes the size of the resulting data grows by a factor of (number of fragments / threshold).  For example, if the threshold were 10, and the number of IDA-produced fragments were 15, the total size of all the fragments would be (15/10) or 1.5 times the size of the original input.  In this case, this scheme is 10 times more efficient than if Shamir's scheme had been applied directly on the data.  The final step in secret sharing made short is to use Shamir secret sharing to produce shares of the randomly generated symmetric key (which is typically on the order of 16–32 bytes) and then give one share and one fragment to each shareholder.
A related approach, known as AONT-RS,  applies an All-or-nothing transform to the data as a pre-processing step to an IDA.  The All-or-nothing transform guarantees that any number of shares less than the threshold is insufficient to decrypt the data.


== Multi-secret and space efficient (batched) secret sharing ==
An information-theoretically secure k-of-n secret-sharing scheme generates n shares, each of size at least that of the secret itself, leading to the total required storage being at least n-fold larger than the secret. In multi-secret sharing designed by Matthew K. Franklin and Moti Yung, multiple points of the polynomial host secrets; the method was found useful in numerous applications from coding to multi-party computations. In space efficient secret sharing, devised by Abhishek Parakh and Subhash Kak, each share is roughly the size of the secret divided by k − 1.
This scheme makes use of repeated polynomial interpolation and has potential applications in secure information dispersal on the Web and in
sensor networks. This method is based on data partitioning involving the roots of a polynomial in finite field. Some vulnerabilities of related space efficient secret sharing schemes were pointed out later. They show that a scheme based on interpolation method cannot be used to implement a (k, n) scheme when the k secrets to be distributed are inherently generated from a polynomial of degree less than k − 1, and the scheme does not work if all of the secrets to be shared are the same, etc.


== Other uses and applications ==
A secret-sharing scheme can secure a secret over multiple servers and remain recoverable despite multiple server failures. The dealer may act as several distinct participants, distributing the shares among the participants. Each share may be stored on a different server, but the dealer can recover the secret even if several servers break down as long as they can recover at least t shares; however, crackers that break into one server would still not know the secret as long as fewer than t shares are stored on each server.
This is one of the major concepts behind the Vanish computer project at the University of Washington, where a random key is used to encrypt data, and the key is distributed as a secret across several nodes in a P2P network. In order to decrypt the message, at least t nodes on the network must be accessible; the principle for this particular project being that the number of secret-sharing nodes on the network will decrease naturally over time, therefore causing the secret to eventually vanish. However, the network is vulnerable to a Sybil attack, thus making Vanish insecure.
Any shareholder who ever has enough information to decrypt the content at any point is able to take and store a copy of X. Consequently, although tools and techniques such as Vanish can make data irrecoverable within their own system after a time, it is not possible to force the deletion of data once a malicious user has seen it. This is one of the leading conundrums of digital rights management.
A dealer could send t shares, all of which are necessary to recover the original secret, to a single recipient. An attacker would have to intercept all t shares to recover the secret, a task which is more difficult than intercepting a single file, especially if the shares are sent using different media (e.g. some over the Internet, some mailed on CDs).
For large secrets, it may be more efficient to encrypt the secret and then distribute the key using secret sharing.
Secret sharing is an important primitive in several protocols for secure multiparty computation.
Secret sharing can also be used for user authentication in a system.


== See also ==


== References ==


== External links ==
Ubuntu Manpage: gfshare – explanation of Shamir Secret Sharing in GF(28)
Description of Shamir's and Blakley's schemes
Patent for use of secret sharing for recovering PGP (and other?) pass phrases U.S. patent 6,662,299
A bibliography on secret-sharing schemes
Code signing systems using Shared Secret at the Wayback Machine (archived February 14, 2008)
Beimel, Amos (2011). "Secret-Sharing Schemes: A Survey" (PDF).