Integrated Encryption Scheme (IES) is a hybrid encryption scheme which provides semantic security against an adversary who is able to use chosen-plaintext or chosen-ciphertext attacks. The security of the scheme is based on the computational Diffie–Hellman problem.
Two variants of IES are specified: Discrete Logarithm Integrated Encryption Scheme (DLIES) and Elliptic Curve Integrated Encryption Scheme (ECIES), which is also known as the Elliptic Curve Augmented Encryption Scheme or simply the Elliptic Curve Encryption Scheme. These two variants are identical up to the change of an underlying group.


== Informal description of DLIES ==
As a brief and informal description and overview of how IES works, a Discrete Logarithm Integrated Encryption Scheme (DLIES) is used, focusing on illuminating the reader's understanding, rather than precise technical details.

Alice learns Bob's public key 
  
    
      
        
          g
          
            x
          
        
      
    
    {\displaystyle g^{x}}
  
 through a public key infrastructure or some other distribution method.Bob knows his own private key 
  
    
      
        x
      
    
    {\displaystyle x}
  
.
Alice generates a fresh, ephemeral value 
  
    
      
        y
      
    
    {\displaystyle y}
  
, and its associated public value 
  
    
      
        
          g
          
            y
          
        
      
    
    {\displaystyle g^{y}}
  
.
Alice then computes a symmetric key 
  
    
      
        k
      
    
    {\displaystyle k}
  
 using this information and a key derivation function (KDF) as follows: 
  
    
      
        k
        =
        
          
            KDF
          
        
        (
        
          g
          
            x
            y
          
        
        )
      
    
    {\displaystyle k={\textrm {KDF}}(g^{xy})}
  

Alice computes her ciphertext 
  
    
      
        c
      
    
    {\displaystyle c}
  
 from her actual message 
  
    
      
        m
      
    
    {\displaystyle m}
  
 (by symmetric encryption of 
  
    
      
        m
      
    
    {\displaystyle m}
  
) encrypted with the key 
  
    
      
        k
      
    
    {\displaystyle k}
  
 (using an authenticated encryption scheme) as follows: 
  
    
      
        c
        =
        E
        (
        k
        ;
        m
        )
      
    
    {\displaystyle c=E(k;m)}
  

Alice transmits (in a single message) both the public ephemeral 
  
    
      
        
          g
          
            y
          
        
      
    
    {\displaystyle g^{y}}
  
 and the ciphertext 
  
    
      
        c
      
    
    {\displaystyle c}
  
.
Bob, knowing 
  
    
      
        x
      
    
    {\displaystyle x}
  
 and 
  
    
      
        
          g
          
            y
          
        
      
    
    {\displaystyle g^{y}}
  
, can now compute 
  
    
      
        k
        =
        
          
            KDF
          
        
        (
        
          g
          
            x
            y
          
        
        )
      
    
    {\displaystyle k={\textrm {KDF}}(g^{xy})}
  
 and decrypt 
  
    
      
        m
      
    
    {\displaystyle m}
  
 from 
  
    
      
        c
      
    
    {\displaystyle c}
  
.
Note that the scheme does not provide Bob with any assurance as to who really sent the message: This scheme does nothing to stop anyone from pretending to be Alice.


== Formal description of ECIES ==


=== Required information ===
To send an encrypted message to Bob using ECIES, Alice needs the following information:

The cryptography suite to be used, including a key derivation function (e.g., ANSI-X9.63-KDF with SHA-1 option), a message authentication code system (e.g., HMAC-SHA-1-160 with 160-bit keys or HMAC-SHA-1-80 with 80-bit keys) and a symmetric encryption scheme (e.g., TDEA in CBC mode or XOR encryption scheme) — noted 
  
    
      
        E
      
    
    {\displaystyle E}
  
.
The elliptic curve domain parameters: 
  
    
      
        (
        p
        ,
        a
        ,
        b
        ,
        G
        ,
        n
        ,
        h
        )
      
    
    {\displaystyle (p,a,b,G,n,h)}
  
 for a curve over a prime field or 
  
    
      
        (
        m
        ,
        f
        (
        x
        )
        ,
        a
        ,
        b
        ,
        G
        ,
        n
        ,
        h
        )
      
    
    {\displaystyle (m,f(x),a,b,G,n,h)}
  
 for a curve over a binary field.
Bob's public key 
  
    
      
        
          K
          
            B
          
        
      
    
    {\displaystyle K_{B}}
  
, which Bob generates it as follows: 
  
    
      
        
          K
          
            B
          
        
        =
        
          k
          
            B
          
        
        G
      
    
    {\displaystyle K_{B}=k_{B}G}
  
, where 
  
    
      
        
          k
          
            B
          
        
        ∈
        [
        1
        ,
        n
        −
        1
        ]
      
    
    {\displaystyle k_{B}\in [1,n-1]}
  
 is the private key he chooses at random.
Some optional shared information: 
  
    
      
        
          S
          
            1
          
        
      
    
    {\displaystyle S_{1}}
  
 and 
  
    
      
        
          S
          
            2
          
        
      
    
    {\displaystyle S_{2}}
  

  
    
      
        O
      
    
    {\displaystyle O}
  
 which denotes the point at infinity.


=== Encryption ===
To encrypt a message 
  
    
      
        m
      
    
    {\displaystyle m}
  
 Alice does the following:

generates a random number 
  
    
      
        r
        ∈
        [
        1
        ,
        n
        −
        1
        ]
      
    
    {\displaystyle r\in [1,n-1]}
  
 and calculates 
  
    
      
        R
        =
        r
        G
      
    
    {\displaystyle R=rG}
  

derives a shared secret: 
  
    
      
        S
        =
        
          P
          
            x
          
        
      
    
    {\displaystyle S=P_{x}}
  
, where 
  
    
      
        P
        =
        (
        
          P
          
            x
          
        
        ,
        
          P
          
            y
          
        
        )
        =
        r
        
          K
          
            B
          
        
      
    
    {\displaystyle P=(P_{x},P_{y})=rK_{B}}
  
 (and 
  
    
      
        P
        ≠
        O
      
    
    {\displaystyle P\neq O}
  
)
uses a KDF to derive symmetric encryption keys and MAC keys: 
  
    
      
        
          k
          
            E
          
        
        ‖
        
          k
          
            M
          
        
        =
        
          
            KDF
          
        
        (
        S
        ‖
        
          S
          
            1
          
        
        )
      
    
    {\displaystyle k_{E}\|k_{M}={\textrm {KDF}}(S\|S_{1})}
  

encrypts the message: 
  
    
      
        c
        =
        E
        (
        
          k
          
            E
          
        
        ;
        m
        )
      
    
    {\displaystyle c=E(k_{E};m)}
  

computes the tag of encrypted message and 
  
    
      
        
          S
          
            2
          
        
      
    
    {\displaystyle S_{2}}
  
: 
  
    
      
        d
        =
        
          
            MAC
          
        
        (
        
          k
          
            M
          
        
        ;
        c
        ‖
        
          S
          
            2
          
        
        )
      
    
    {\displaystyle d={\textrm {MAC}}(k_{M};c\|S_{2})}
  

outputs 
  
    
      
        R
        ‖
        c
        ‖
        d
      
    
    {\displaystyle R\|c\|d}
  


=== Decryption ===
To decrypt the ciphertext 
  
    
      
        R
        ‖
        c
        ‖
        d
      
    
    {\displaystyle R\|c\|d}
  
 Bob does the following:

derives the shared secret: 
  
    
      
        S
        =
        
          P
          
            x
          
        
      
    
    {\displaystyle S=P_{x}}
  
, where 
  
    
      
        P
        =
        (
        
          P
          
            x
          
        
        ,
        
          P
          
            y
          
        
        )
        =
        
          k
          
            B
          
        
        R
      
    
    {\displaystyle P=(P_{x},P_{y})=k_{B}R}
  
 (it is the same as the one Alice derived because 
  
    
      
        P
        =
        
          k
          
            B
          
        
        R
        =
        
          k
          
            B
          
        
        r
        G
        =
        r
        
          k
          
            B
          
        
        G
        =
        r
        
          K
          
            B
          
        
      
    
    {\displaystyle P=k_{B}R=k_{B}rG=rk_{B}G=rK_{B}}
  
), or outputs failed if 
  
    
      
        P
        =
        O
      
    
    {\displaystyle P=O}
  

derives keys the same way as Alice did: 
  
    
      
        
          k
          
            E
          
        
        ‖
        
          k
          
            M
          
        
        =
        
          
            KDF
          
        
        (
        S
        ‖
        
          S
          
            1
          
        
        )
      
    
    {\displaystyle k_{E}\|k_{M}={\textrm {KDF}}(S\|S_{1})}
  

uses MAC to check the tag and outputs failed if 
  
    
      
        d
        ≠
        
          
            MAC
          
        
        (
        
          k
          
            M
          
        
        ;
        c
        ‖
        
          S
          
            2
          
        
        )
      
    
    {\displaystyle d\neq {\textrm {MAC}}(k_{M};c\|S_{2})}
  

uses symmetric encryption scheme to decrypt the message 
  
    
      
        m
        =
        
          E
          
            −
            1
          
        
        (
        
          k
          
            E
          
        
        ;
        c
        )
      
    
    {\displaystyle m=E^{-1}(k_{E};c)}
  


== References ==
SECG, Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography, Version 2.0, May 21, 2009.
Gayoso Martínez, Hernández Encinas, Sánchez Ávila: A Survey of the Elliptic Curve Integrated Encryption Scheme, Journal of Computer Science and Engineering, 2, 2 (2010), 7–13.
Ladar Levison: Code for using ECIES to protect data (ECC + AES + SHA), openssl-devel mailing list, August 6, 2010.
IEEE 1363a (non-public standard) specifies DLIES and ECIES
ANSI X9.63 (non-public standard)
ISO/IEC 18033-2 (non-public standard)
Victor Shoup, A proposal for an ISO standard for public key encryption, Version 2.1, December 20, 2001.
Abdalla, Michel and Bellare, Mihir and Rogaway, Phillip: DHIES: An Encryption Scheme Based on the Diffie–Hellman Problem, IACR Cryptology ePrint Archive, 1999.