In cryptography, Very Smooth Hash (VSH) is a provably secure cryptographic hash function invented in 2005 by Scott Contini, Arjen Lenstra, and Ron Steinfeld. Provably secure means that finding collisions is as difficult as some known hard mathematical problem. Unlike other provably secure collision-resistant hashes, VSH is efficient and usable in practice. Asymptotically, it only requires a single multiplication per log(n) message-bits and uses RSA-type arithmetic. Therefore, VSH can be useful in embedded environments where code space is limited.
Two major variants of VSH were proposed. For one, finding a collision is provably as difficult as finding a nontrivial modular square root of a very smooth number modulo n. The other one uses a prime modulus p (with no trapdoor), and its security proof relies on the hardness of finding discrete logarithms of very smooth numbers modulo p. Both versions have similar efficiency.
VSH is not suitable as a substitute for a random oracle, but can be used to build a provably secure randomized trapdoor hash function. This function can replace the trapdoor function used in the Cramer–Shoup signature scheme, maintaining its provable security while speeding up verification time by about 50%.


== VSN and VSSR ==
All cryptographic hash functions that are now widely used are not based on hard mathematical problems. Those few functions that are constructed on hard mathematical problems are called provably secure. Finding collisions is then known to be as hard as solving the hard mathematical problem. For the basic version of Very Smooth Hash, this hard problem is to find modular square roots (VSSR) of certain special numbers (VSN). This is assumed to be as hard as factoring integers.
For fixed constants c and n, an integer m is a Very Smooth Number (VSN) if the largest prime factor of m is at most log(n)c.
An integer b is a Very Smooth Quadratic Residue modulo n if the largest prime in b's factorization is at most log(n)c and there exists an integer x such that b ≡ x2 (mod n). The integer x is then said to be a modular square root of b.
We are interested only in non-trivial square roots, those where x2 ≥ n. If x2 < n, then the root can be easily computed using algorithms from fields of characteristic 0, such as the real field. Therefore, they are not suitable in cryptographic primitives.
Very Smooth Number Nontrivial Modular Square Root (VSSR) is the following problem: Let n be the product of two unknown primes of approximately the same size, let k ≤ (log(n))c, and let (p1,p2,p3,…) = (2,3,5,…) be the sequence of primes. Given n, find an integer x coprime to n such that 
  
    
      
        
          
            x
            
              2
            
          
          ≡
          
            ∏
            
              i
              =
              0
            
            
              k
            
          
          
            p
            
              i
            
            
              
                e
                
                  i
                
              
            
          
          
            
            (
            mod
            
            n
            )
          
        
      
    
    {\displaystyle \textstyle x^{2}\equiv \prod _{i=0}^{k}p_{i}^{e_{i}}{\pmod {n}}}
  
 and at least one of e0,…,ek is odd.
The VSSR assumption is that there is no probabilistic polynomial (in log(n)) time algorithm which solves VSSR with non-negligible probability. This is considered a useless assumption in practice because it does not tell for what size of moduli VSSR is computationally hard. Instead the computational VSSR assumption is used. It says that solving VSSR is assumed to be as hard as factoring a hard-to-factor s-bit modulus, where s is somewhat smaller than the size of n.


=== Examples of VSN and VSSR ===
Let the parameters be fixed as c = 5 and n = 31.
Then m1 = 35 = 5 · 7 is a Very Smooth Number with respect to these parameters because log(31)5 ≈ 7.37 is greater than all of m1's prime factors. On the other hand, m2 = 55 = 5 · 11 is not a VSN under these parameters.
The integer 9 is a Very Smooth Quadratic Residue modulo n because it is a Very Smooth Number (under c,n), and 32 ≡ 9 (mod n). This is a trivial modular square root, because 9 < n and so the modulus is not involved when squaring.
The integer 
  
    
      
        
          b
          
            2
          
        
        =
        15
      
    
    {\displaystyle b_{2}=15}
  
 is also Very Smooth Quadratic Residue modulo 
  
    
      
        n
      
    
    {\displaystyle n}
  
. All prime factors are smaller than 7.37 and the Modular Square Root is 
  
    
      
        
          x
          
            2
          
        
        =
        20
      
    
    {\displaystyle x_{2}=20}
  
 since 
  
    
      
        
          20
          
            2
          
        
        =
        400
        ≡
        15
      
    
    {\displaystyle 20^{2}=400\equiv 15}
  
 (mod 
  
    
      
        n
      
    
    {\displaystyle n}
  
). This is thus a non-trivial root. The VSSR problem is to find 
  
    
      
        
          x
          
            2
          
        
      
    
    {\displaystyle x_{2}}
  
 given 
  
    
      
        
          b
          
            2
          
        
      
    
    {\displaystyle b_{2}}
  
 and 
  
    
      
        n
      
    
    {\displaystyle n}
  
. And we suppose that this is computationally as hard as factoring 
  
    
      
        n
      
    
    {\displaystyle n}
  
.
The integer b = 15 is also a Very Smooth Quadratic Residue modulo n. All of its prime factors are smaller than 7.37, and the modular square root is x = 20, since 202 = 400 ≡ 15 (mod n). This is thus a non-trivial square root. The VSSR problem is to find x given b and n. This is believed to be computationally as hard as factoring n.


== VSH algorithm, basic versions ==
Let n be a large RSA composite and let (p1,p2,p3,…) = (2,3,5,…) be the sequence of primes. Let k, the block length, be the largest integer such that 
  
    
      
        
          
            ∏
            
              i
              =
              1
            
            
              k
            
          
          
            p
            
              i
            
          
          <
          n
        
      
    
    {\displaystyle \textstyle \prod _{i=1}^{k}p_{i}<n}
  
. Let m be an ℓ-bit message to be hashed consisting of bits (m1,…,mℓ) and assume that ℓ < 2k. To compute the hash of m:

Set x0 = 1.
Let L, the smallest integer greater than or equal to ℓ/k, be the number of blocks.
Let mi = 0 for ℓ < i < Lk (padding).
Let 
  
    
      
        
          ℓ
          =
          
            ∑
            
              i
              =
              1
            
            
              k
            
          
          
            l
            
              i
            
          
          
            2
            
              i
              −
              1
            
          
        
      
    
    {\displaystyle \textstyle \ell =\sum _{i=1}^{k}l_{i}2^{i-1}}
  
 with ℓi ∈ {0,1} be the binary representation of the message length ℓ and define mLk+i = ℓi for 1 ≤ i ≤ k.
For j = 0, 1, …, L in succession, compute 
  
    
      
        
          x
          
            j
            +
            1
          
        
        =
        
          x
          
            j
          
          
            2
          
        
        
          ∏
          
            i
            =
            1
          
          
            k
          
        
        
          p
          
            i
          
          
            
              m
              
                j
                k
                +
                i
              
            
          
        
        
        mod
        
        
        n
      
    
    {\displaystyle x_{j+1}=x_{j}^{2}\prod _{i=1}^{k}p_{i}^{m_{jk+i}}\mod n}
  

Return xL+1.
The function in step 5 is called the compression function.


== Properties of VSH ==
The message length does not need to be known in advance.
Finding a collision in VSH is as hard as solving VSSR. Thus VSH is (strongly) collision-resistant, which also implies second preimage resistance.  VSH has not been proven to be preimage-resistant.
The compression function is not collision-resistant.  Nonetheless, the hash function VSH is collision-resistant based on the VSSR assumption. An altered version of VSH, called VSH*, uses a collision-resistant compression function and is about 5 times quicker when hashing short messages.
Since the output length of VSH is the length of a secure RSA modulus, VSH seems quite suitable in practice for constructing "hash-then-sign" RSA signatures for arbitrarily long messages. However, such a signature must be designed carefully to ensure its security. The naïve approach could be easily broken under a chosen-plaintext attack.
The cost of each iteration is less than the cost of 3 modular multiplications. The basic version of VSH altogether requires one multiplication per Ω(log(n) / log(log(n))) message bits.


== Variants of VSH ==
Several improvements, speedups, and more efficient variants of VSH have been proposed. None of them changes the underlying concept of the function. These improvements are called:

Cubing VSH (instead of squaring)
VSH with increased number of small primes
VSH with precomputed products of primes
Fast VSH
Fast VSH with increased block length


== VSDL and VSH-DL variant ==
The VSH-DL is a discrete logarithm variant of VSH that has no trapdoor; its security depends on the difficulty of finding discrete logarithms modulo a prime p.
Very Smooth Number Discrete Logarithm (VSDL) is a problem where, given a very smooth number, the task is to find its discrete logarithm modulo some number n.
As in previous section, pi denotes the ith prime. Let furthermore c be a fixed constant and p,q be primes with p = 2q + 1 and let k ≤ (log p)c. VSDL is the following problem: given p, find integers e1,…,ek such that 
  
    
      
        
          2
          
            
              e
              
                1
              
            
          
        
        ≡
        
          ∏
          
            i
            =
            2
          
          
            k
          
        
        
          p
          
            i
          
          
            
              e
              
                i
              
            
          
        
        
          
          (
          mod
          
          p
          )
        
      
    
    {\displaystyle 2^{e_{1}}\equiv \prod _{i=2}^{k}p_{i}^{e_{i}}{\pmod {p}}}
  
 with |ei| < q for i = 1, …, k  and at least one of e1,…,ek is non-zero.
The VSDL assumption is that there is no probabilistic polynomial (in log(p)) time algorithm which solves VSDL with non-negligible probability. There is a strong connection between the hardness of VSDL and the hardness of computing discrete logarithms modulo p, which is reminiscent of, but somewhat weaker than, the connection between VSSR and integer factorization.


== Security of VSH ==
Strong collision resistance is the only property proven for VSH. This does not imply preimage-resistance or other important hash function properties, and the authors state that "VSH should not be used to model random oracles," and cannot be substituted into constructions that depend upon them (RSA signatures, some MACs). VSH should not be considered a general-purpose hash function as usually understood in security engineering.


=== Multiplicative property ===
VSH is multiplicative: Let x, y, and z be three bitstrings of equal length, where z consists only of zero bits and the strings satisfy x AND y = z. Then H(z)H(x OR y) ≡ H(x)H(y) (mod n). As a result, VSH succumbs to a classical time-memory trade-off attack that applies to multiplicative and additive hashes.
This fact can be used to construct a preimage attack against VSH of ℓ bits which has 2ℓ/2 complexity rather than 2ℓ as expected.


=== Attack against truncated version ===
VSH produces a very long hash (typically 1024 bits). There are no indications that a truncated VSH hash offers security that is commensurate with the hash length.
There exists a partial collision attack on VSH truncated to ℓ least significant bits.
The complexity of this attack against VSH is:

Pre-computing the table offline: 2ℓ/3 time and space.
Finding collisions: 2ℓ/3 iterations.
Total cost: roughly 2ℓ/3, rather than 2ℓ/2 as expected from a hash function with good pseudorandomness properties.
This probably rules out the applicability of VSH in digital signature schemes which produce signatures shorter than the VSH hash result, such as elliptic-curve signature schemes.


== See also ==
Cryptographic hash functions
Provably secure cryptographic hash function


== References ==