WebAssembly (Wasm) defines a portable binary-code format and a corresponding text format for executable programs as well as software interfaces for facilitating communication between such programs and their host environment.
The main goal of WebAssembly is to facilitate high-performance applications on web pages, but it is also designed to be usable in non-web environments. It is an open standard intended to support any language on any operating system, and in practice many of the most popular languages already have at least some level of support.
Announced in 2015 (2015) and first released in March 2017 (2017-03), WebAssembly became a World Wide Web Consortium (W3C) recommendation on 5 December 2019 and it received the Programming Languages Software Award from ACM SIGPLAN in 2021. The W3C maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat.


== History ==
The name "WebAssembly" is intended to suggest bringing assembly language programming to the World Wide Web, where it will be executed client-side, by the website-user's computer via the user's web browser. To accomplish this, WebAssembly must be much more hardware-independent than a true assembly language.
WebAssembly was first announced in 2015, and the first demonstration was executing Unity's Angry Bots in Firefox, Google Chrome, and Microsoft Edge [Legacy]. The precursor technologies were asm.js from Mozilla and Google Native Client, and the initial implementation was based on the feature set of asm.js.
In March 2017, the design of the minimum viable product (MVP) was declared to be finished and the preview phase ended. In late September 2017, Safari 11 was released with support. In February 2018, the WebAssembly Working Group published three public working drafts for the Core Specification, JavaScript Interface, and Web API.
In June 2019, Chrome 75 was released with WebAssembly threads enabled by default.
Since April 2022, WebAssembly 2.0 has been in draft status. It adds many SIMD-related instructions and a new v128 datatype, with the ability for functions to return multiple values, and mass memory initialize/copy.


== Implementations ==
While WebAssembly was initially designed to permit near-native code execution speed in the web browser, it has been considered valuable outside of such, in more generalized contexts. A WebAssembly runtime environment is a low-level virtual stack machine, akin to JVM or Flash VM; it can be embedded into any host application, and thus there have been created standalone WebAssembly runtime environments, including Wasmtime  and Wasmer . WebAssembly runtime environments are embedded in application servers to host "server-side" WebAssembly applications and in other applications to support plug-in-based software extension architectures, e.g., "WebAssembly for Proxies" (Proxy-Wasm) which specifies a WebAssembly-based ABI for extending proxy servers.


=== Web browsers ===
In November 2017, Mozilla declared support "in all major browsers", after WebAssembly was enabled by default in Edge [Legacy] 16. This support also includes mobile web browsers for iOS and Android.  As of March 2024, 99% of tracked web browsers  support WebAssembly (version 1.0), more than for its predecessor asm.js.  For some extensions, from the 2.0 draft standard, support may be lower, but still more than 90% of web browsers may already support, e.g. the reference types extension.


=== Compilers ===
WebAssembly implementations generally use either ahead-of-time (AOT) or just-in-time (JIT) compilation, though some may also use an interpreter. While the first implementations appeared in web browsers, there are now many non-browser implementations for general-purpose use.


==== Implementations and runtimes ====
Non-browser WebAssembly runtimes include Wasmer, Wasmtime, WAMR, WAVM, wasm3, and others. These systems execute precompiled Wasm modules and often provide additional APIs for embedding WebAssembly in different environments.


==== Compiler toolchains ====
Because WebAssembly executables are precompiled, a variety of programming languages can target Wasm. Compilation is achieved either through direct output to Wasm or via intermediate virtual machines implemented in Wasm.
Notable toolchains include:

Emscripten, which compiles C and C++ to Wasm using Clang as a frontend, Binaryen as an optimizer, and can also target any LLVM-supported language.
Standalone Clang (version 8 and later), which supports direct compilation to Wasm.
LLVM-based workflows for languages such as Rust and AssemblyScript.


==== Language support ====
As of 2021, around 40 programming languages support WebAssembly as a compilation target. Examples include:

C and C++: via Emscripten or Clang standalone.
Rust: via rustc with Wasm target.
AssemblyScript: a TypeScript-like language compiling directly to Wasm.
Go: native WebAssembly support introduced in Go 1.11.
.NET languages: C# (via Blazor), F# (via Bolero and Blazor).
Python: implementations such as Pyodide.
Java and JVM languages: via CheerpJ, JWebAssembly, and TeaVM.
Kotlin: direct Wasm compilation support.
Haskell: supported via GHC backend.
Julia: community implementations.
Ruby: supported through MRuby.
Ring: supported with Wasm backend.


==== Recent enhancements ====
Post-MVP developments in WebAssembly, such as support for multithreading and garbage collection (WasmGC), have enabled more efficient compilation for garbage-collected languages like C#, F#, and Python.


== Limitations ==
Web browsers do not permit WebAssembly code to directly manipulate the Document Object Model. Wasm code must defer to JavaScript for this.
In an October 2023 survey of developers, less than half of the 303 participants were satisfied with the state of WebAssembly. A large majority cited the need for improvement in four areas: WASI, debugging support, integration with JavaScript and browser APIs, and build tooling.
For memory-intensive allocations in WebAssembly, there are "grave limitations that make many applications infeasible to be reliably deployed on mobile browsers [..] Currently allocating more than ~300MB of memory is not reliable on Chrome on Android without resorting to Chrome-specific workarounds, nor in Safari on iOS."
All major browsers allow WebAssembly if Content-Security-Policy is not specified, or if the value unsafe-eval is used, but behave differently otherwise; Chrome requires unsafe-eval, though a worker thread can be a workaround.


== Security considerations ==
In June 2018, a security researcher presented the possibility of using WebAssembly to circumvent browser mitigations for Spectre and Meltdown security vulnerabilities once support for threads with shared memory is added. Due to this concern, WebAssembly developers put the feature on hold. However, in order to explore these future language extensions, Google Chrome added experimental support for the WebAssembly thread proposal in October 2018.
WebAssembly has been criticized for allowing greater ease of hiding the evidence for malware writers, scammers and phishing attackers; WebAssembly is present on the user's machine only in its compiled form, which "[makes malware] detection difficult". Speed and the easy ability to conceal in WebAssembly have led to its use in hidden crypto mining within the website visitor's device. Coinhive, a now defunct service facilitating cryptocurrency mining in website visitors' browsers, claims their "miner uses WebAssembly and runs with about 65% of the performance of a native Miner." A June 2019 study from the Technische Universität Braunschweig analyzed the usage of WebAssembly in the Alexa top 1 million websites and found the prevalent use was for malicious crypto mining, and that malware accounted for more than half of the WebAssembly-using websites studied. An April 2021 study from Universität Stuttgart found that since then crypto mining has been marginalized, falling to below 1% of all WebAssembly modules gathered from a wide range of sources, also including the Alexa top 1 million websites. 
As WebAssembly supports only structured control flow, it is amenable toward security verification techniques including symbolic execution.


== Performance ==
Early on, the execution speed of a Wasm program was benchmarked to be around 91% of (or about 10% slower than) a comparable native program, not including load/instantiation time; however, various later benchmarks indicate a wide range of performance characteristics, from 33% to 200% of the execution speed of native code, depending on the task.
In 2019, a group of researchers from the University of Massachusetts Amherst presented a comprehensive analysis of WebAssembly's performance compared to native code. This study used the SPEC CPU suite of benchmarks and a system called "Browsix-Wasm" to run unmodified Unix applications in the browser, thereby allowing for a test of real-world applications, finding a significant performance gap between Wasm execution and native execution; in particular, Wasm programs showed an average slowdown of 45% in Firefox and 55% in Chrome across the real-world benchmarks; peak slowdowns resulted in a Wasm program taking 2.08 times as long to run in Firefox and 2.5 times as long to run in Chrome. The paper identified several reasons for this performance difference, including missing optimizations, code generation issues in WebAssembly compilers, and inherent limitations of the WebAssembly platform itself.  
A 2021 study suggested that WebAssembly is much faster than JavaScript in certain cases, such as running a complex function on a small file (e.g., processing a graphics file); however, at the time, the JavaScript interpreter had some optimizations available that the WebAssembly implemenations did not have (e.g., Just-in-time compilation).

In 2022, it was determined by researchers that a Wasm program runs at about 120% of (or 20% faster than) the speed of a comparable JavaScript program. Those findings align with the experience of a startup company named "Zaplib", whose founders summarized in a blog that it was shutting down due to lack of performance in WebAssembly. Their goal had been to significantly increase the performance of existing web apps by incrementally porting them to Rust/Wasm; however, porting a customer's simulator from JavaScript yielded only a 5% improvement in performance. Similarly, regarding Figma, they stated the following:[Upon] closer inspection it seems that [Figma's] use of Wasm is more due to historical accidents—wanting to build in C++ to hedge for their native app—than for critical performance needs. Figma files are processed in C++/Wasm, and this is likely a huge speedup, but most of Figma's performance magic is due to their WebGL renderer.In 2023, a study of Wasm's performance for cryptographic tasks indicated that "when using the fastest runtime, WebAssembly was only about 2.32 times slower (median) than native code with architecture-specific optimizations." This result excluded 2 tests where the native code benefited from special instructions implemented directly in the CPU of the target platform; for those particular tests, the Wasm programs were "80 times slower than native code". 
Benchmarking has revealed several other pain-points for WebAssembly, such as poor performance because of no direct access to the DOM, a problem which is being addressed.


== WASI ==
WebAssembly System Interface (WASI) is a simple interface (ABI and API) designed by Mozilla, which is intended to be portable to any platform. It provides POSIX-like features like file I/O constrained by capability-based security. There are additional proposed ABI/APIs.
WASI is influenced by CloudABI and Capsicum.
Solomon Hykes, a co-founder of Docker, wrote in 2019, "If WASM+WASI existed in 2008, we wouldn't have needed to create Docker. That's how important it is. WebAssembly on the server is the future of computing."


== Specification ==


=== Host environment ===
The general standard provides core specifications for the JavaScript API and details on embedding.


=== Virtual machine ===
Wasm code (binary code, i.e. bytecode) is intended to be run on a portable virtual stack machine (VM). The VM is designed to be faster to parse and execute than JavaScript and to have compact code representation. Any external functionality (like syscalls) that may be expected by Wasm binary code is not stipulated by the standard; instead, the standard specifies how the host environment can provide such an interface via a "module".


=== Wasm program ===
A Wasm program is designed as a separate module containing collections of various Wasm-defined values and program type definitions. These are provided in either binary or textual format (see below) that have a common structure. Such a module may provide a start function that is executed upon instantiation of a wasm binary.


==== Instruction set ====
The core standard for the binary format of a Wasm program defines an instruction set architecture (ISA); each operation that can be executed by the VM is assigned a specific binary encoding (an "opcode"), but the exact way in which the operation is implemented is not specified, allowing for flexibility in the construction of a VM. The list of instructions includes standard memory load/store instructions, numeric, parametric, control of flow instruction types and Wasm-specific variable instructions.
The number of opcodes used in the original standard (MVP) was a bit fewer than 200 of the 256 possible opcodes. Subsequent versions of WebAssembly pushed the number of opcodes a bit over 200. The WebAssembly SIMD proposal (for parallel processing) introduces an alternate opcode prefix (0xfd) for 128-bit wide SIMD instructions; the concatenation of the SIMD prefix, plus an opcode that is valid after the SIMD prefix, forms each SIMD opcode. The SIMD opcodes bring an additional 236 instructions to the MVP's SIMD capability (for a total of around 436 instructions, and there ), This set of instructions are enabled by default across a number of important implementations:

Google's V8 (in Google Chrome)
The SpiderMonkey engine in Mozilla Firefox
The JavaScriptCore engine in Apple's Safari
These SIMD opcodes are both portable and intended to map directly to native instruction sets like x86-64 and ARM. In contrast, SIMD instructions are not directly supported by Java's JVM or .NET's CIL; however, both do have some APIs for parallel processing, which provide SIMD speedups.
There are proposals for additional instructions, including a "relaxed-simd".


==== Code representation ====
In March 2017, the WebAssembly Community Group reached consensus on the initial ("MVP") binary format, JavaScript API, and reference interpreter. It defines a WebAssembly binary format (.wasm), which is not designed to be used by humans, as well as a human-readable WebAssembly text format (.wat) that resembles a cross between S-expressions and traditional assembly languages.
The table below shows an example of a factorial function written in C and its corresponding WebAssembly code after compilation, shown both in .wat text format (a human-readable textual representation of WebAssembly) and in .wasm binary format (the raw bytecode, expressed below in hexadecimal), that is executed by a Web browser or run-time environment that supports WebAssembly.

All integer constants are encoded using a space-efficient, variable-length LEB128 encoding.
The WebAssembly text format is more canonically written in a folded format using S-expressions. For instructions and expressions, this format is purely syntactic sugar and has no behavioral differences with the linear format. Through wasm2wat, the code above decompiles to:

A module is implicitly generated by the compiler. The function is referenced by an entry of the type table in the binary, hence a type section and the type emitted by the decompiler. The compiler and decompiler can be accessed online.


== See also ==
Architecture Neutral Distribution Format (ANDF)
UNCOL
Java bytecode
Common Language Runtime
LLVM
Compilation
Software portability


== Notes ==


== References ==

 This article incorporates text from a free content work. Licensed under Apache License 2.0 (license statement/permission). Text taken from Text Format​, jfbastien; rossberg-chromium; kripken; titzer; s3ththompson; sunfishcode; lukewagner; flagxor; enricobacis; c3d; binji; andrewosh, GitHub. WebAssembly/design.  


== External links ==

Official website 
WebAssembly on GitHub, hosts Design Documents
W3C Community Group Archived 18 June 2015 at the Wayback Machine
WebAssembly Specification Archived 22 September 2022 at the Wayback Machine
"WebAssembly". MDN Web Docs. 16 April 2024. Archived from the original on 13 May 2022. Retrieved 14 February 2018. Has info on browser compatibility and specifications (WebAssembly JavaScript API)