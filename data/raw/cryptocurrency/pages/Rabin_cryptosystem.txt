The Rabin cryptosystem is a family of public-key encryption schemes
based on a trapdoor function whose security, like that of RSA, is related to the difficulty of integer factorization.
The Rabin trapdoor function has the advantage that inverting it has been mathematically proven to be as hard as factoring integers, while there is no such proof known for the RSA trapdoor function.
It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext.
Naive attempts to work around this often either enable a chosen-ciphertext attack to recover the secret key or, by encoding redundancy in the plaintext space, invalidate the proof of security relative to factoring.
Public-key encryption schemes based on the Rabin trapdoor function are used mainly for examples in textbooks.
In contrast, RSA is the basis of standard public-key encryption schemes such as RSAES-PKCS1-v1_5 and RSAES-OAEP that are used widely in practice.


== History ==
The Rabin trapdoor function was first published as part of the Rabin signature scheme in 1978 by Michael O. Rabin.
The Rabin signature scheme was the first digital signature scheme where forging a signature could be proven to be as hard as factoring.
The trapdoor function was later repurposed in textbooks as an example of a public-key encryption scheme,
which came to be known as the Rabin cryptosystem even though Rabin never published it as an encryption scheme.


== Algorithm ==
Like all asymmetric cryptosystems, the Rabin system uses a key pair: a public key for encryption and a private key for decryption. The public key is published for anyone to use, while the private key remains known only to the recipient of the message.


=== Key generation ===
The keys for the Rabin cryptosystem are generated as follows:

Choose two large distinct prime numbers 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 such that 
  
    
      
        p
        ≡
        3
        
          mod
          
            4
          
        
      
    
    {\displaystyle p\equiv 3{\bmod {4}}}
  
 and 
  
    
      
        q
        ≡
        3
        
          mod
          
            4
          
        
      
    
    {\displaystyle q\equiv 3{\bmod {4}}}
  
.
Compute 
  
    
      
        n
        =
        p
        q
      
    
    {\displaystyle n=pq}
  
.
Then 
  
    
      
        n
      
    
    {\displaystyle n}
  
 is the public key and the pair 
  
    
      
        (
        p
        ,
        q
        )
      
    
    {\displaystyle (p,q)}
  
 is the private key.


=== Encryption ===
A message 
  
    
      
        M
      
    
    {\displaystyle M}
  
 can be encrypted by first converting it to a number 
  
    
      
        m
        <
        n
      
    
    {\displaystyle m<n}
  
 using a reversible mapping, then computing 
  
    
      
        c
        =
        
          m
          
            2
          
        
        
          mod
          
            n
          
        
      
    
    {\displaystyle c=m^{2}{\bmod {n}}}
  
. The ciphertext is 
  
    
      
        c
      
    
    {\displaystyle c}
  
.


=== Decryption ===
The message 
  
    
      
        m
      
    
    {\displaystyle m}
  
 can be recovered from the ciphertext 
  
    
      
        c
      
    
    {\displaystyle c}
  
 by taking its square root modulo 
  
    
      
        n
      
    
    {\displaystyle n}
  
 as follows.

Compute the square root of 
  
    
      
        c
      
    
    {\displaystyle c}
  
 modulo 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 using these formulas:

  
    
      
        
          
            
              
                
                  m
                  
                    p
                  
                
              
              
                
                =
                
                  c
                  
                    
                      
                        1
                        4
                      
                    
                    (
                    p
                    +
                    1
                    )
                  
                
                
                  mod
                  
                    p
                  
                
              
            
            
              
                
                  m
                  
                    q
                  
                
              
              
                
                =
                
                  c
                  
                    
                      
                        1
                        4
                      
                    
                    (
                    q
                    +
                    1
                    )
                  
                
                
                  mod
                  
                    q
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}m_{p}&=c^{{\frac {1}{4}}(p+1)}{\bmod {p}}\\m_{q}&=c^{{\frac {1}{4}}(q+1)}{\bmod {q}}\end{aligned}}}
  

Use the extended Euclidean algorithm to find 
  
    
      
        
          y
          
            p
          
        
      
    
    {\displaystyle y_{p}}
  
 and 
  
    
      
        
          y
          
            q
          
        
      
    
    {\displaystyle y_{q}}
  
 such that 
  
    
      
        
          y
          
            p
          
        
        ⋅
        p
        +
        
          y
          
            q
          
        
        ⋅
        q
        =
        1
      
    
    {\displaystyle y_{p}\cdot p+y_{q}\cdot q=1}
  
.
Use the Chinese remainder theorem to find the four square roots of 
  
    
      
        c
      
    
    {\displaystyle c}
  
 modulo 
  
    
      
        n
      
    
    {\displaystyle n}
  
:

  
    
      
        
          
            
              
                
                  r
                  
                    1
                  
                
              
              
                
                =
                
                  (
                  
                    
                      y
                      
                        p
                      
                    
                    ⋅
                    p
                    ⋅
                    
                      m
                      
                        q
                      
                    
                    +
                    
                      y
                      
                        q
                      
                    
                    ⋅
                    q
                    ⋅
                    
                      m
                      
                        p
                      
                    
                  
                  )
                
                
                  mod
                  
                    n
                  
                
              
            
            
              
                
                  r
                  
                    2
                  
                
              
              
                
                =
                n
                −
                
                  r
                  
                    1
                  
                
              
            
            
              
                
                  r
                  
                    3
                  
                
              
              
                
                =
                
                  (
                  
                    
                      y
                      
                        p
                      
                    
                    ⋅
                    p
                    ⋅
                    
                      m
                      
                        q
                      
                    
                    −
                    
                      y
                      
                        q
                      
                    
                    ⋅
                    q
                    ⋅
                    
                      m
                      
                        p
                      
                    
                  
                  )
                
                
                  mod
                  
                    n
                  
                
              
            
            
              
                
                  r
                  
                    4
                  
                
              
              
                
                =
                n
                −
                
                  r
                  
                    3
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}r_{1}&=\left(y_{p}\cdot p\cdot m_{q}+y_{q}\cdot q\cdot m_{p}\right){\bmod {n}}\\r_{2}&=n-r_{1}\\r_{3}&=\left(y_{p}\cdot p\cdot m_{q}-y_{q}\cdot q\cdot m_{p}\right){\bmod {n}}\\r_{4}&=n-r_{3}\end{aligned}}}
  

One of these four values is the original plaintext 
  
    
      
        m
      
    
    {\displaystyle m}
  
, although which of the four is the correct one cannot be determined without additional information.


==== Computing square roots ====
We can show that the formulas in step 1 above actually produce the square roots of 
  
    
      
        c
      
    
    {\displaystyle c}
  
 as follows. For the first formula, we want to prove that 
  
    
      
        
          m
          
            p
          
          
            2
          
        
        ≡
        c
        
          mod
          
            p
          
        
      
    
    {\displaystyle m_{p}^{2}\equiv c{\bmod {p}}}
  
. Since 
  
    
      
        p
        ≡
        3
        
          mod
          
            4
          
        
        ,
      
    
    {\displaystyle p\equiv 3{\bmod {4}},}
  
 the exponent 
  
    
      
        
          
            1
            4
          
        
        (
        p
        +
        1
        )
      
    
    {\textstyle {\frac {1}{4}}(p+1)}
  
 is an integer. The proof is trivial if 
  
    
      
        c
        ≡
        0
        
          mod
          
            p
          
        
      
    
    {\displaystyle c\equiv 0{\bmod {p}}}
  
, so we may assume that 
  
    
      
        p
      
    
    {\displaystyle p}
  
 does not divide 
  
    
      
        c
      
    
    {\displaystyle c}
  
. Note that 
  
    
      
        c
        ≡
        
          m
          
            2
          
        
        
          mod
          
            p
            q
          
        
      
    
    {\displaystyle c\equiv m^{2}{\bmod {pq}}}
  
 implies that 
  
    
      
        c
        ≡
        
          m
          
            2
          
        
        
          mod
          
            p
          
        
      
    
    {\displaystyle c\equiv m^{2}{\bmod {p}}}
  
, so c is a quadratic residue modulo 
  
    
      
        p
      
    
    {\displaystyle p}
  
. Then

  
    
      
        
          m
          
            p
          
          
            2
          
        
        ≡
        
          c
          
            
              
                1
                2
              
            
            (
            p
            +
            1
            )
          
        
        ≡
        c
        ⋅
        
          c
          
            
              
                1
                2
              
            
            (
            p
            −
            1
            )
          
        
        ≡
        c
        ⋅
        1
        
        mod
        
        
        p
      
    
    {\displaystyle m_{p}^{2}\equiv c^{{\frac {1}{2}}(p+1)}\equiv c\cdot c^{{\frac {1}{2}}(p-1)}\equiv c\cdot 1\mod p}
  

The last step is justified by Euler's criterion.


=== Example ===
As an example, take 
  
    
      
        p
        =
        7
      
    
    {\displaystyle p=7}
  
 and 
  
    
      
        q
        =
        11
      
    
    {\displaystyle q=11}
  
, then 
  
    
      
        n
        =
        77
      
    
    {\displaystyle n=77}
  
. Take 
  
    
      
        m
        =
        20
      
    
    {\displaystyle m=20}
  
 as our plaintext. The ciphertext is thus 

  
    
      
        c
        =
        
          m
          
            2
          
        
        
          mod
          
            n
          
        
        =
        400
        
          mod
          
            77
          
        
        =
        15
      
    
    {\displaystyle c=m^{2}{\bmod {n}}=400{\bmod {77}}=15}
  
.
Decryption proceeds as follows:

Compute 
  
    
      
        
          m
          
            p
          
        
        =
        
          c
          
            
              
                1
                4
              
            
            (
            p
            +
            1
            )
          
        
        
          mod
          
            p
          
        
        =
        
          15
          
            2
          
        
        
          mod
          
            7
          
        
        =
        1
      
    
    {\displaystyle m_{p}=c^{{\frac {1}{4}}(p+1)}{\bmod {p}}=15^{2}{\bmod {7}}=1}
  
 and 
  
    
      
        
          m
          
            q
          
        
        =
        
          c
          
            
              
                1
                4
              
            
            (
            q
            +
            1
            )
          
        
        
          mod
          
            q
          
        
        =
        
          15
          
            3
          
        
        
          mod
          
            11
          
        
        =
        9
      
    
    {\displaystyle m_{q}=c^{{\frac {1}{4}}(q+1)}{\bmod {q}}=15^{3}{\bmod {11}}=9}
  
.
Use the extended Euclidean algorithm to compute 
  
    
      
        
          y
          
            p
          
        
        =
        −
        3
      
    
    {\displaystyle y_{p}=-3}
  
 and 
  
    
      
        
          y
          
            q
          
        
        =
        2
      
    
    {\displaystyle y_{q}=2}
  
. We can confirm that 
  
    
      
        
          y
          
            p
          
        
        ⋅
        p
        +
        
          y
          
            q
          
        
        ⋅
        q
        =
        (
        −
        3
        ⋅
        7
        )
        +
        (
        2
        ⋅
        11
        )
        =
        1
      
    
    {\displaystyle y_{p}\cdot p+y_{q}\cdot q=(-3\cdot 7)+(2\cdot 11)=1}
  
.
Compute the four plaintext candidates:

  
    
      
        
          
            
              
                
                  r
                  
                    1
                  
                
              
              
                
                =
                (
                −
                3
                ⋅
                7
                ⋅
                9
                +
                2
                ⋅
                11
                ⋅
                1
                )
                
                  mod
                  
                    77
                  
                
                =
                64
              
            
            
              
                
                  r
                  
                    2
                  
                
              
              
                
                =
                77
                −
                64
                =
                13
              
            
            
              
                
                  r
                  
                    3
                  
                
              
              
                
                =
                (
                −
                3
                ⋅
                7
                ⋅
                9
                −
                2
                ⋅
                11
                ⋅
                1
                )
                
                  mod
                  
                    77
                  
                
                =
                
                  20
                
              
            
            
              
                
                  r
                  
                    4
                  
                
              
              
                
                =
                77
                −
                20
                =
                57
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}r_{1}&=(-3\cdot 7\cdot 9+2\cdot 11\cdot 1){\bmod {77}}=64\\r_{2}&=77-64=13\\r_{3}&=(-3\cdot 7\cdot 9-2\cdot 11\cdot 1){\bmod {77}}=\mathbf {20} \\r_{4}&=77-20=57\end{aligned}}}
  

and we see that 
  
    
      
        
          r
          
            3
          
        
      
    
    {\displaystyle r_{3}}
  
 is the desired plaintext. Note that all four candidates are square roots of 15 mod 77. That is, for each candidate, 
  
    
      
        
          r
          
            i
          
          
            2
          
        
        
          mod
          
            77
          
        
        =
        15
      
    
    {\displaystyle r_{i}^{2}{\bmod {77}}=15}
  
, so each 
  
    
      
        
          r
          
            i
          
        
      
    
    {\displaystyle r_{i}}
  
 encrypts to the same value, 15.


== Evaluation of the algorithm ==


=== Effectiveness ===
Decrypting produces three false results in addition to the correct one, so that the correct result must be guessed. This is the major disadvantage of the Rabin cryptosystem and one of the factors which have prevented it from finding widespread practical use.
If the plaintext is intended to represent a text message, guessing is not difficult; however, if the plaintext is intended to represent a numerical value, this issue becomes a problem that must be resolved by some kind of disambiguation scheme. It is possible to choose plaintexts with special structures, or to add padding, to eliminate this problem. A way of removing the ambiguity of inversion was suggested by Blum and Williams: the two primes used are restricted to primes congruent to 3 modulo 4 and the domain of the squaring is restricted to the set of quadratic residues. These restrictions make the squaring function into a trapdoor permutation, eliminating the ambiguity.


=== Efficiency ===
For encryption, a square modulo n must be calculated. This is more efficient than RSA, which requires the calculation of at least a cube.
For decryption, the Chinese remainder theorem is applied, along with two modular exponentiations. Here the efficiency is comparable to RSA.


=== Security ===
It has been proven that any algorithm which finds one of the possible plaintexts for every Rabin-encrypted ciphertext can be used to factor the modulus 
  
    
      
        n
      
    
    {\displaystyle n}
  
. Thus, Rabin decryption for random plaintext is at least as hard as the integer factorization problem, something that has not been proven for RSA. It is generally believed that there is no polynomial-time algorithm for factoring, which implies that there is no efficient algorithm for decrypting a random Rabin-encrypted value without the private key 
  
    
      
        (
        p
        ,
        q
        )
      
    
    {\displaystyle (p,q)}
  
.
The Rabin cryptosystem does not provide indistinguishability against chosen plaintext attacks since the process of encryption is deterministic. An adversary, given a ciphertext and a candidate message, can easily determine whether or not the ciphertext encodes the candidate message (by simply checking whether encrypting the candidate message yields the given ciphertext).
The Rabin cryptosystem is insecure against a chosen ciphertext attack (even when challenge messages are chosen uniformly at random from the message space). By adding redundancies, for example, the repetition of the last 64 bits, the system can be made to produce a single root. This thwarts this specific chosen-ciphertext attack, since the decryption algorithm then only produces the root that the attacker already knows. If this technique is applied, the proof of the equivalence with the factorization problem fails, so it is uncertain as of 2004 if this variant is secure. The Handbook of Applied Cryptography by Menezes, Oorschot and Vanstone considers this equivalence probable, however, as long as the finding of the roots remains a two-part process (1. roots 
  
    
      
        
          mod
          
            p
          
        
      
    
    {\displaystyle {\bmod {p}}}
  
 and 
  
    
      
        
          mod
          
            q
          
        
      
    
    {\displaystyle {\bmod {q}}}
  
 and 2. application of the Chinese remainder theorem).


== See also ==
Topics in cryptography
Blum Blum Shub
Shanks–Tonelli algorithm
Schmidt–Samoa cryptosystem
Blum–Goldwasser cryptosystem


== Notes ==


== References ==
Buchmann, Johannes. Einführung in die Kryptographie. Second Edition. Berlin: Springer, 2001. ISBN 3-540-41283-2
Menezes, Alfred; van Oorschot, Paul C.; and Vanstone, Scott A. Handbook of Applied Cryptography. CRC Press, October 1996. ISBN 0-8493-8523-7
Rabin, Michael. Digitalized Signatures and Public-Key Functions as Intractable as Factorization (in PDF). MIT Laboratory for Computer Science, January 1979.
Scott Lindhurst, An analysis of Shank's algorithm for computing square  roots in finite fields. in R Gupta and K S Williams, Proc 5th Conf Can Nr Theo Assoc, 1999, vol 19 CRM Proc & Lec Notes, AMS, Aug 1999.
R Kumanduri and C Romero, Number Theory w/ Computer Applications, Alg 9.2.9, Prentice Hall, 1997. A probabilistic for square root of a quadratic residue modulo a prime.


== External links ==
Menezes, Oorschot, Vanstone, Scott: Handbook of Applied Cryptography (free PDF downloads), see Chapter 8