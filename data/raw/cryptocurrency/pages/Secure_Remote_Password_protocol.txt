The Secure Remote Password protocol (SRP) is an augmented password-authenticated key exchange (PAKE) protocol, specifically designed to work around existing patents.
Like all PAKE protocols, an eavesdropper or man in the middle cannot obtain enough information to be able to brute-force guess a password or apply a dictionary attack without further interactions with the parties for each guess. Furthermore, being an augmented PAKE protocol, the server does not store password-equivalent data. This means that an attacker who steals the server data cannot masquerade as the client unless they first perform a brute force search for the password.
In layman's terms, during SRP (or any other PAKE protocol) authentication, one party (the "client" or "user") demonstrates to another party (the "server") that they know the password, without sending the password itself nor any other information from which the password can be derived. The password never leaves the client and is unknown to the server.
Furthermore, the server also needs to know about the password (but not the password itself) in order to instigate the secure connection. This means that the server also authenticates itself to the client which prevents phishing without reliance on the user parsing complex URLs.
The only mathematically proven security property of SRP is that it is equivalent to Diffie-Hellman against a passive attacker. While mature and widely deployed, SRP is an older design with some variants showing subtle weaknesses; it is not UC‑secure, lacks resistance to all precomputation attacks, has weaker formal proofs, and offers no protection against certain modern attack models. For these reasons, SRP is now largely considered superseded. OPAQUE is the preferred augmented PAKE, while CPace or SPAKE2 are favored for balanced PAKE scenarios where both parties share the password.


== Overview ==
The SRP protocol has a number of desirable properties: it allows a user to authenticate themselves to a server, it is resistant to dictionary attacks mounted by an eavesdropper, and it does not require a trusted third party. It effectively conveys a zero-knowledge password proof from the user to the server. In revision 6 of the protocol only one password can be guessed per connection attempt. One of the interesting properties of the protocol is that even if one or two of the cryptographic primitives it uses are attacked, it is still secure. The SRP protocol has been revised several times, and is currently at revision 6a.
The SRP protocol creates a large private key shared between the two parties in a manner similar to Diffie–Hellman key exchange based on the client side having the user password and the server side having a cryptographic verifier derived from the password. The shared public key is derived from two random numbers, one generated by the client, and the other generated by the server, which are unique to the login attempt. In cases where encrypted communications as well as authentication are required, the SRP protocol is more secure than the alternative SSH protocol and faster than using Diffie–Hellman key exchange with signed messages. It is also independent of third parties, unlike Kerberos.
The SRP protocol, version 3 is described in RFC 2945. SRP version 6a is also used for strong password authentication in SSL/TLS (in TLS-SRP) and other standards such as EAP and SAML, and is part of IEEE 1363.2 and ISO/IEC 11770-4.


== Protocol ==
The following notation is used in this description of the protocol, version 6:

q and N = 2q + 1 are chosen such that both are prime (which makes q a Sophie Germain prime and N a safe prime). N must be large enough so that computing discrete logarithms modulo N is infeasible.
All arithmetic is performed in the ring of integers modulo N, 
  
    
      
        
          
            
              Z
            
            
              N
            
          
        
      
    
    {\displaystyle \scriptstyle \mathbb {Z} _{N}}
  
. This means that below gx should be read as gxmod N
g is a generator of the multiplicative group 
  
    
      
        
          
            
              Z
            
            
              N
            
            
              ∗
            
          
        
      
    
    {\displaystyle \scriptstyle \mathbb {Z} _{N}^{*}}
  
.
H() is a hash function; e.g., SHA-256.
k is a parameter derived by both sides; in SRP-6, k = 3, while in SRP-6a it is derived from N and g : k = H(N, g).  It is used to prevent a 2-for-1 guess when an active attacker impersonates the server.
s is a salt.
I is an identifying username.
p is the user's password.
v is the host's password verifier, v = gx where at a minimum x = H(s, p). As x is only computed on the client it is free to choose a stronger algorithm. An implementation could choose to use x = H(s | I | p) without affecting any steps required of the host. The standard RFC2945 defines x = H(s | H ( I | ":" | p) ). Use of I within x avoids a malicious server from being able to learn if two users share the same password.
A and B are random one time ephemeral keys of the user and host respectively.
| (pipe) denotes concatenation.
All other variables are defined in terms of these.
First, to establish a password p with server Steve, client Carol picks a random salt s, and computes x = H(s, p), v = gx.  Steve stores v and s, indexed by I, as Carol's password verifier and salt. Carol must not share x with anybody, and must safely erase it at this step, because it is equivalent to the plaintext password p.  This step is completed before the system is used as part of the user registration with Steve. Note that the salt s is shared and exchanged to negotiate a session key later so the value could be chosen by either side but is done by Carol so that she can register I, s and v in a single registration request. The transmission and authentication of the registration request is not covered in SRP.
Then to perform a proof of password at a later date the following exchange protocol occurs:

Carol → Steve: generate random value a; send I and A = ga
Steve → Carol: generate random value b; send s and B = kv + gb
Both: u = H(A, B)
Carol: SCarol = (B − kgx)(a + ux) = (kv + gb − kgx)(a + ux) = (kgx − kgx + gb)(a + ux) = (gb)(a + ux)
Carol: KCarol = H(SCarol)
Steve: SSteve = (Avu)b = (gavu)b = [ga(gx)u]b = (ga + ux)b = (gb)(a + ux)
Steve: KSteve = H(SSteve) = KCarol
Now the two parties have a shared, strong session key K. To complete authentication, they need to prove to each other that their keys match. One possible way is as follows:

Carol → Steve: M1 = H[H(N) XOR H(g) | H(I) | s | A | B | KCarol]. Steve verifies M1.
Steve → Carol: M2 = H(A | M1 | KSteve). Carol verifies M2.
This method requires guessing more of the shared state to be successful in impersonation than just the key.  While most of the additional state is public, private information could safely be added to the inputs to the hash function, like the server private key.
Alternatively, in a password-only proof the calculation of K can be skipped and the shared S proven with:

Carol → Steve: M1 = H(A | B | SCarol). Steve verifies M1.
Steve → Carol: M2 = H(A | M1 | SSteve). Carol verifies M2.
When using SRP to negotiate a shared key K which will be immediately used after the negotiation, it is tempting to skip the verification steps of M1 and M2. The server will reject the very first request from the client which it cannot decrypt. This can however be dangerous as demonstrated in the Implementation Pitfalls section below.
The two parties also employ the following safeguards:

Carol will abort if she receives B = 0 (mod N) or u = 0.
Steve will abort if he receives A (mod N) = 0.
Carol must show her proof of K (or S) first. If Steve detects that Carol's proof is incorrect, he must abort without showing his own proof of K (or S)


=== Example code in Python ===


== Implementation pitfalls ==


=== Offline bruteforce attack with server-first messaging in the absence of key verification ===
If the server sends an encrypted message without waiting for verification from the client then an attacker is able to mount an offline bruteforce attack similar to hash cracking. This can happen if the server sends an encrypted message in the second packet alongside the salt and B or if key verification is skipped and the server (rather  than the client) sends the first encrypted message. This is tempting as after the very first packet, the server has every information to compute the shared key K.
The attack goes as follow:

Carol → Steve: generate random value a; send I and A = ga
Steve: u = H(A, B); S=Avu; K=H(S)
Steve: generate message m and encrypts it to produce c=ENC(K,m)
Steve → Carol: generate random value b; send s, B = kv + gb and c
Carol doesn't know x or v. But given any password p she can compute:

xp = H(salt, p)
Sp = (B - kgxp)(a + uxp)
Kp = H(Sp)
Kp is the key that Steve would use if p was the expected password. All values required to compute Kp are either controlled by Carol or known from the first packet from Steve. Carol can now try to guess the password, generate the corresponding key, and attempt to decrypt Steve's encrypted message c to verify the key. As protocol messages tend to be structured, it is assumed that identifying that c was properly decrypted is easy. This allows offline recovery of the password.
This attack would not be possible had Steve waited for Carol to prove she was able to compute the correct key before sending an encrypted message. Proper implementations of SRP are not affected by this attack as the attacker would be unable to pass the key verification step.


=== Offline bruteforce based on timing attack ===
In 2021 Daniel De Almeida Braga, Pierre-Alain Fouque and Mohamed Sabt published PARASITE, a paper in which they demonstrate practical exploitation of a timing attack over the network. This exploits non-constant implementations of modular exponentiation of big numbers and impacted OpenSSL in particular.


== Implementations ==
SRP-6 Variables A Java library of cryptographic primitives required to implement the SRP-6 protocol.
OpenSSL version 1.0.1 or later.
Botan (the C++ crypto library) contains an implementation of SRP-6a
TLS-SRP is a set of ciphersuites for transport layer security that uses SRP.
srp-client SRP-6a implementation in JavaScript (compatible with RFC 5054), open source, Mozilla Public License (MPL) licensed.
The JavaScript Crypto Library includes a JavaScript implementation of the SRP protocol, open source, BSD licensed.
Gnu Crypto provide a Java implementation licensed under the GNU General Public License with the "library exception", which permits its use as a library in conjunction with non-Free software.
The Legion of the Bouncy Castle provides Java and C# implementations under the MIT License.
Nimbus SRP is a Java library providing a verifier generator, client and server-side sessions. Includes interfaces for custom password key, client and server evidence message routines. No external dependencies. Released under the Apache 2.0 license.
srplibcpp is a C++ implement base on MIRACL.
DragonSRP is a C++ modular implementation currently works with OpenSSL.
Json2Ldap provides SRP-6a authentication to LDAP directory servers.
csrp SRP-6a implementation in C.
Crypt-SRP SRP-6a implementation in Perl.
pysrp SRP-6a implementation in Python (compatible with csrp).
py3srp SRP-6a implementation in pure Python3.
srptools Tools to implement Secure Remote Password (SRP) authentication in Python. Verified compatible libraries.
Meteor web framework's Accounts system implements SRP for password authentication.
srp-rb SRP-6a implementation in Ruby.
falkmueller demo SRP-6a implementation of the Stanford SRP Protocol Design in JavaScript and PHP under the MIT License.
srp-6a-demo SRP-6a implementation in PHP and JavaScript.
thinbus-srp-js SRP-6a implementation in JavaScript. Comes with compatible Java classes which use Nimbus SRP a demonstration app using Spring Security. There is also a demonstration application performing authentication to a PHP server. Released under the Apache License.
Stanford JavaScript Crypto Library (SJCL) implements SRP for key exchange.
node-srp is a JavaScript client and server (node.js) implementation of SRP.
SRP6 for C# and Java implementation in C# and Java.
ALOSRPAuth is an Objective-C implementation of SRP-6a.
go-srp is a Go implementation of SRP-6a.
tssrp6a is a TypeScript implementation of SRP-6a.
TheIceNet Cryptography Java library to develop cryptography-based Spring Boot applications. Implements SRP-6a. Under Apache License.
SRP-6a in .NET implementation of SRP-6a
Apple Homekit Apple Homekit uses SRP when pairing with "smart" home accessories & devices
Proton Mail Authentication for Email Encryption
SRP is a Go implementation of SRP, used to authenticate users on Posterity.


== History ==
The SRP project was started in 1997. Two different approaches to fixing a security hole in SRP-1 resulted in SRP-2 and SRP-3. SRP-3 was first published in 1998 in a conference. RFC 2945, which describes SRP-3 with SHA1, was published in 2000. SRP-6, which fixes "two-for-one" guessing and messaging ordering attacks, was published in 2002. SRP-6a appeared in the official "libsrp" in version 2.1.0, dated 2005. SRP-6a is found in standards as:

ISO/IEC 11770-4:2006 "Key Agreement Mechanism 2" (calls the method "SRP-6, but has the k calculation of 6a)
RFC 5054 TLS-SRP of 2007 (again referred to as "SRP-6", but corrected in erratum)
IEEE Std 1363.2-2008 "DLAPKAS-SRP6" (again referred to as "SRP-6")
IEEE 1363.2 also includes a description of "SRP5", a variant replacing the discrete logarithm with an elliptic curve contributed by Yongge Wang in 2001. It also describes SRP-3 as found in RFC 2945.


== See also ==
Challenge–response authentication
Password-authenticated key agreement
Salted Challenge Response Authentication Mechanism (SCRAM)
Simple Password Exponential Key Exchange
Zero-knowledge password proof


== References ==


== External links ==
Official website
SRP License—BSD like open source.
US6539479 - SRP Patent (Expired on May 12, 2015 due to failure to pay maintenance fees (according to Google Patents). Originally set to expire in July 2018).


=== Manual pages ===
pppd(8): Point-to-Point Protocol Daemon
srptool(1): Simple SRP password tool


=== RFCs ===
RFC 2944 - Telnet Authentication: SRP
RFC 2945 - The SRP Authentication and Key Exchange System (version 3)
RFC 3720 - Internet Small Computer Systems Interface (iSCSI)
RFC 3723 - Securing Block Storage Protocols over IP
RFC 3669 - Guidelines for Working Groups on Intellectual Property Issues
RFC 5054 - Using the Secure Remote Password (SRP) Protocol for TLS Authentication


=== Other links ===
IEEE 1363
SRP Intellectual Property Slides (Dec 2001 - possible deprecated) The EKE patents mentioned expired in 2011 and 2013.