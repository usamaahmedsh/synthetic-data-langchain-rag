Equihash is a memory-hard Proof-of-work algorithm introduced by the University of Luxembourg's Interdisciplinary Centre for Security, Reliability and Trust (SnT) at the 2016 Network and Distributed System Security Symposium. The algorithm is based on a generalization of the Birthday problem which finds colliding hash values. It has severe time-space trade-offs but concedes vulnerability to unforeseen parallel optimizations. It was designed such that parallel implementations are bottle-necked by memory bandwidth in an attempt to worsen the cost-performance trade-offs of designing custom ASIC implementations. ASIC resistance in Equihash is based on the assumption that commercially-sold hardware already has quite high memory bandwidth, so improvements made by custom hardware may not be worth the development cost.


== General ==
Equihash was proposed by Alex Biryukov and Dmitry Khovratovich as part of the University of Luxembourg research group CryptoLUX. It was introduced at the Network and Distributed System Security Symposium 2016 in San Diego. Notable blockchain-based projects such as ZCash, BitcoinZ, Horizen, Aion, Hush, and Pirate Chain have integrated Equihash for reasons such as security, privacy, and ASIC miner resistance.

The manufacturer Bitmain has succeeded in optimizing the processing of Zcash's Equihash-200,9 with an ASIC.


== Specification ==
Equihash has three parameters –  
  
    
      
        n
      
    
    {\displaystyle n}
  
, 
  
    
      
        k
      
    
    {\displaystyle k}
  
, and 
  
    
      
        d
      
    
    {\displaystyle d}
  
 – which determine the algorithm's time and memory requirements. The time complexity is proportional to 
  
    
      
        
          2
          
            
              
                n
                
                  k
                  +
                  1
                
              
            
            +
            d
          
        
      
    
    {\displaystyle 2^{{\frac {n}{k+1}}+d}}
  
while the memory complexity is proportional to 
  
    
      
        
          2
          
            k
            +
            
              
                n
                
                  k
                  +
                  1
                
              
            
          
        
      
    
    {\displaystyle 2^{k+{\frac {n}{k+1}}}}
  
. The algorithm is often implemented with 
  
    
      
        d
        =
        0
      
    
    {\displaystyle d=0}
  
 (using an alternative method of controlling the effective difficulty).
The problem in Equihash is to find distinct, 
  
    
      
        n
      
    
    {\displaystyle n}
  
-bit values 
  
    
      
        
          i
          
            1
          
        
        ,
        
          i
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          i
          
            
              2
              
                k
              
            
          
        
      
    
    {\displaystyle i_{1},i_{2},...,i_{2^{k}}}
  
 to satisfy 
  
    
      
        H
        (
        
          i
          
            1
          
        
        )
        ⊕
        H
        (
        
          i
          
            2
          
        
        )
        
        ⊕
        
        .
        .
        .
        
        ⊕
        
        H
        (
        
          i
          
            
              2
              
                k
              
            
          
        
        )
        =
        0
      
    
    {\displaystyle H(i_{1})\oplus H(i_{2})\,\oplus \,...\,\oplus \,H(i_{2^{k}})=0}
  
 such that 
  
    
      
        H
        (
        
          i
          
            1
          
        
        ∥
        
          i
          
            2
          
        
        ∥
        
        .
        .
        .
        
        ∥
        
          i
          
            
              2
              
                k
              
            
          
        
        )
      
    
    {\displaystyle H(i_{1}\parallel i_{2}\parallel \,...\,\parallel i_{2^{k}})}
  
 has 
  
    
      
        d
      
    
    {\displaystyle d}
  
 leading zeros, where 
  
    
      
        H
      
    
    {\displaystyle H}
  
 is a chosen hash function. In addition, there are "algorithm binding conditions" which are intended to reduce the risk of other algorithms developed to solve the underlying birthday problem being applicable. A memory-less verification requires 
  
    
      
        
          2
          
            k
          
        
      
    
    {\displaystyle 2^{k}}
  
hashes and XORs.


== Memory-hardness and time-space tradeoffs ==
It is proposed that the puzzle in Equihash be solved by a variation of Wagner's algorithm for the generalized birthday problem. (Note that the underlying problem is not exactly the Generalized Birthday Problem as defined by Wagner, since it uses a single list rather than multiple lists.) The proposed algorithm makes 
  
    
      
        k
      
    
    {\displaystyle k}
  
 iterations over a large list. For every factor of 
  
    
      
        
          
            1
            q
          
        
      
    
    {\displaystyle {\frac {1}{q}}}
  
 fewer entries per list, computational complexity of the algorithm scales proportional to 
  
    
      
        
          q
          
            
              k
              2
            
          
        
      
    
    {\displaystyle q^{\frac {k}{2}}}
  
 for memory-efficient implementations. Alcock and Ren
refute Equihash’s security claims, concluding that no tradeoff-resistance bound is in fact known for Equihash.


== Usage ==

The cryptocurrency Zcash implements Equihash with 
  
    
      
        n
        =
        200
      
    
    {\displaystyle n=200}
  
 and 
  
    
      
        k
        =
        9
      
    
    {\displaystyle k=9}
  
.
The cryptocurrency BitcoinGold implements Equihash with 
  
    
      
        n
        =
        144
      
    
    {\displaystyle n=144}
  
 and 
  
    
      
        k
        =
        5
      
    
    {\displaystyle k=5}
  
.


== See also ==
Proof of stake


== References ==


== External links ==