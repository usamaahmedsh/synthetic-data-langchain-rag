In cryptography, XTR is an algorithm for public-key encryption. XTR stands for 'ECSTR', which is an abbreviation for Efficient and Compact Subgroup Trace Representation. It is a method to represent elements of a subgroup of a multiplicative group of a finite field. To do so, it uses the trace over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 to represent elements of a subgroup of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF(p^{6})^{*}}
  
.
From a security point of view, XTR relies on the difficulty of solving Discrete Logarithm related problems in the full multiplicative group of a finite field. Unlike many cryptographic protocols that are based on the generator of the full multiplicative group of a finite field, XTR uses the generator 
  
    
      
        g
      
    
    {\displaystyle g}
  
 of a relatively small subgroup of some prime order  
  
    
      
        q
      
    
    {\displaystyle q}
  
 of a subgroup of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF(p^{6})^{*}}
  
. With the right choice of 
  
    
      
        q
      
    
    {\displaystyle q}
  
, computing Discrete Logarithms in the group, generated by  
  
    
      
        g
      
    
    {\displaystyle g}
  
, is, in general, as hard as it is in  
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF(p^{6})^{*}}
  
 and thus cryptographic applications of XTR use 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 arithmetics while achieving full 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 security leading to substantial savings both in communication and computational overhead without compromising security. Some other advantages of XTR are its fast key generation, small key sizes and speed.


== Fundamentals of XTR ==
XTR uses a subgroup, commonly referred to as XTR subgroup or just  XTR group, of a subgroup called XTR supergroup, of the multiplicative group of a finite field 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 with 
  
    
      
        
          p
          
            6
          
        
      
    
    {\displaystyle p^{6}}
  
 elements. The XTR supergroup is of order 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
, where p is a prime such that a sufficiently large prime q divides 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
. The XTR subgroup has now order q and is, as a subgroup of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF(p^{6})^{*}}
  
, a cyclic group 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
 with generator g.  The following three paragraphs will describe how elements of the XTR supergroup can be represented using an element of 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 instead of an element of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 and how arithmetic operations  take place in 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 instead of in 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
.


=== Arithmetic operations in ===
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  

Let p be a prime such that p ≡ 2 mod 3 and p2 - p + 1 has a sufficiently large prime factor q. Since p2 ≡ 1 mod 3 we see that p generates 
  
    
      
        (
        
          Z
        
        
          /
        
        3
        
          Z
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle (\mathbb {Z} /3\mathbb {Z} )^{*}}
  
 and thus the third cyclotomic polynomial

  
    
      
        
          Φ
          
            3
          
        
        (
        x
        )
        =
        
          x
          
            2
          
        
        +
        x
        +
        1
      
    
    {\displaystyle \Phi _{3}(x)=x^{2}+x+1}
  

is irreducible over 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
. It follows that the roots 
  
    
      
        α
      
    
    {\displaystyle \alpha }
  
 and 
  
    
      
        
          α
          
            p
          
        
      
    
    {\displaystyle \alpha ^{p}}
  
 form an optimal normal basis for 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 over 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
 and

  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
        ≅
        {
        
          x
          
            1
          
        
        α
        +
        
          x
          
            2
          
        
        
          α
          
            p
          
        
        :
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ∈
        G
        F
        (
        p
        )
        }
        .
      
    
    {\displaystyle GF(p^{2})\cong \{x_{1}\alpha +x_{2}\alpha ^{p}:x_{1},x_{2}\in GF(p)\}.}
  

Considering that p ≡ 2 mod 3 we can reduce the exponents modulo 3 to get

  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
        ≅
        {
        
          y
          
            1
          
        
        α
        +
        
          y
          
            2
          
        
        
          α
          
            2
          
        
        :
        
          α
          
            2
          
        
        +
        α
        +
        1
        =
        0
        ,
        
          y
          
            1
          
        
        ,
        
          y
          
            2
          
        
        ∈
        G
        F
        (
        p
        )
        }
        .
      
    
    {\displaystyle GF(p^{2})\cong \{y_{1}\alpha +y_{2}\alpha ^{2}:\alpha ^{2}+\alpha +1=0,y_{1},y_{2}\in GF(p)\}.}
  

The cost of arithmetic operations is now given in the following Lemma labeled Lemma 2.21 in "An overview of the XTR public key system":
Lemma

Computing xp is done without using multiplication
Computing x2 takes two multiplications in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  

Computing xy takes three multiplications in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  

Computing xz-yzp takes four multiplications in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.


=== Traces over ===
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  

The trace in XTR is always considered over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
. In other words, the conjugates of 
  
    
      
        h
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle h\in GF(p^{6})}
  
 over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 are 
  
    
      
        h
        ,
        
          h
          
            
              p
              
                2
              
            
          
        
      
    
    {\displaystyle h,h^{p^{2}}}
  
 and 
  
    
      
        
          h
          
            
              p
              
                4
              
            
          
        
      
    
    {\displaystyle h^{p^{4}}}
  
 and the trace of 
  
    
      
        h
      
    
    {\displaystyle h}
  
 is their sum:

  
    
      
        T
        r
        (
        h
        )
        =
        h
        +
        
          h
          
            
              p
              
                2
              
            
          
        
        +
        
          h
          
            
              p
              
                4
              
            
          
        
        .
      
    
    {\displaystyle Tr(h)=h+h^{p^{2}}+h^{p^{4}}.}
  

Note that 
  
    
      
        T
        r
        (
        h
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(h)\in GF(p^{2})}
  
 since

  
    
      
        
          
            
              
                T
                r
                (
                h
                
                  )
                  
                    
                      p
                      
                        2
                      
                    
                  
                
              
              
                
                =
                
                  h
                  
                    
                      p
                      
                        2
                      
                    
                  
                
                +
                
                  h
                  
                    
                      p
                      
                        4
                      
                    
                  
                
                +
                
                  h
                  
                    
                      p
                      
                        6
                      
                    
                  
                
              
            
            
              
              
                
                =
                h
                +
                
                  h
                  
                    
                      p
                      
                        2
                      
                    
                  
                
                +
                
                  h
                  
                    
                      p
                      
                        4
                      
                    
                  
                
              
            
            
              
              
                
                =
                T
                r
                (
                h
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}Tr(h)^{p^{2}}&=h^{p^{2}}+h^{p^{4}}+h^{p^{6}}\\&=h+h^{p^{2}}+h^{p^{4}}\\&=Tr(h)\end{aligned}}}
  

Consider now the generator 
  
    
      
        g
      
    
    {\displaystyle g}
  
 of the XTR subgroup of a prime order 
  
    
      
        q
      
    
    {\displaystyle q}
  
. Remember that 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
 is a subgroup of the XTR supergroup of order 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
, so 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
. In the following section we will see how to choose 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
, but for now it is sufficient to assume that 
  
    
      
        q
        >
        3
      
    
    {\displaystyle q>3}
  
. To compute the trace of 
  
    
      
        g
      
    
    {\displaystyle g}
  
 note that modulo 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 we have

  
    
      
        
          p
          
            2
          
        
        =
        p
        −
        1
      
    
    {\displaystyle p^{2}=p-1}
  
 and

  
    
      
        
          p
          
            4
          
        
        =
        (
        p
        −
        1
        
          )
          
            2
          
        
        =
        
          p
          
            2
          
        
        −
        2
        p
        +
        1
        =
        −
        p
      
    
    {\displaystyle p^{4}=(p-1)^{2}=p^{2}-2p+1=-p}
  

and thus

  
    
      
        
          
            
              
                T
                r
                (
                g
                )
              
              
                
                =
                g
                +
                
                  g
                  
                    
                      p
                      
                        2
                      
                    
                  
                
                +
                
                  g
                  
                    
                      p
                      
                        4
                      
                    
                  
                
              
            
            
              
              
                
                =
                g
                +
                
                  g
                  
                    p
                    −
                    1
                  
                
                +
                
                  g
                  
                    −
                    p
                  
                
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}Tr(g)&=g+g^{p^{2}}+g^{p^{4}}\\&=g+g^{p-1}+g^{-p}.\end{aligned}}}
  

The product of the conjugates of 
  
    
      
        g
      
    
    {\displaystyle g}
  
 equals 
  
    
      
        1
      
    
    {\displaystyle 1}
  
,
i.e., that 
  
    
      
        g
      
    
    {\displaystyle g}
  
 has norm 1.
The crucial observation in XTR is that the minimal polynomial of 
  
    
      
        g
      
    
    {\displaystyle g}
  
 over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  

  
    
      
        (
        x
        −
        g
        )
        
         
        (
        x
        −
        
          g
          
            p
            −
            1
          
        
        )
        (
        x
        −
        
          g
          
            −
            p
          
        
        )
      
    
    {\displaystyle (x-g)\!\ (x-g^{p-1})(x-g^{-p})}
  

simplifies to

  
    
      
        
          x
          
            3
          
        
        −
        T
        r
        (
        g
        )
        
         
        
          x
          
            2
          
        
        +
        T
        r
        (
        g
        
          )
          
            p
          
        
        x
        −
        1
      
    
    {\displaystyle x^{3}-Tr(g)\!\ x^{2}+Tr(g)^{p}x-1}
  

which is fully determined by 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
. Consequently, conjugates of 
  
    
      
        g
      
    
    {\displaystyle g}
  
, as roots of the minimal polynomial of 
  
    
      
        g
      
    
    {\displaystyle g}
  
 over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
, are completely determined by the trace of 
  
    
      
        g
      
    
    {\displaystyle g}
  
. The same is true for any power of 
  
    
      
        g
      
    
    {\displaystyle g}
  
: conjugates of 
  
    
      
        
          g
          
            n
          
        
      
    
    {\displaystyle g^{n}}
  
 are roots of polynomial

  
    
      
        
          x
          
            3
          
        
        −
        T
        r
        (
        
          g
          
            n
          
        
        )
        
         
        
          x
          
            2
          
        
        +
        T
        r
        (
        
          g
          
            n
          
        
        
          )
          
            p
          
        
        x
        −
        1
      
    
    {\displaystyle x^{3}-Tr(g^{n})\!\ x^{2}+Tr(g^{n})^{p}x-1}
  

and this polynomial is completely determined by 
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
      
    
    {\displaystyle Tr(g^{n})}
  
.
The idea behind using traces is to replace 
  
    
      
        
          g
          
            n
          
        
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle g^{n}\in GF(p^{6})}
  
 in cryptographic protocols, e.g. the Diffie–Hellman key exchange by 
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{n})\in GF(p^{2})}
  
 and thus obtaining a factor of 3 reduction in representation size. This is, however, only useful if there is a quick way to obtain 
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
      
    
    {\displaystyle Tr(g^{n})}
  
 given 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
. The next paragraph gives an algorithm for the efficient computation of 
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
      
    
    {\displaystyle Tr(g^{n})}
  
. In addition, computing 
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
      
    
    {\displaystyle Tr(g^{n})}
  
 given 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
 turns out to be quicker than computing 
  
    
      
        
          g
          
            n
          
        
      
    
    {\displaystyle g^{n}}
  
 given 
  
    
      
        g
      
    
    {\displaystyle g}
  
.


=== Algorithm for the quick computation of ===
  
    
      
        T
        r
        (
        
          g
          
            n
          
        
        )
      
    
    {\displaystyle Tr(g^{n})}
  
 given 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  

A. Lenstra and E. Verheul give this algorithm in their paper titled The XTR public key system in. All the definitions and lemmas necessary for the algorithm and the algorithm itself presented here, are taken from that paper.
Definition For c in 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 define

  
    
      
        F
        (
        c
        ,
        X
        )
        =
        
          X
          
            3
          
        
        −
        c
        
          X
          
            2
          
        
        +
        
          c
          
            p
          
        
        X
        −
        1
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
        [
        X
        ]
        .
      
    
    {\displaystyle F(c,X)=X^{3}-cX^{2}+c^{p}X-1\in GF(p^{2})[X].}
  

Definition Let 
  
    
      
        
          h
          
            0
          
        
        ,
        
         
        
          h
          
            1
          
        
        ,
        
          h
          
            2
          
        
      
    
    {\displaystyle h_{0},\!\ h_{1},h_{2}}
  
 denote the, not necessarily distinct, roots of 
  
    
      
        F
        (
        c
        ,
        X
        )
      
    
    {\displaystyle F(c,X)}
  
 in 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 and let 
  
    
      
        n
      
    
    {\displaystyle n}
  
 be in 
  
    
      
        
          Z
        
      
    
    {\displaystyle \mathbb {Z} }
  
. Define

  
    
      
        
          c
          
            n
          
        
        =
        
          h
          
            0
          
          
            n
          
        
        +
        
          h
          
            1
          
          
            n
          
        
        +
        
          h
          
            2
          
          
            n
          
        
        .
      
    
    {\displaystyle c_{n}=h_{0}^{n}+h_{1}^{n}+h_{2}^{n}.}
  

Properties of 
  
    
      
        
          c
          
            n
          
        
      
    
    {\displaystyle c_{n}}
  
 and 
  
    
      
        F
        (
        c
        ,
        X
        )
      
    
    {\displaystyle F(c,X)}
  

  
    
      
        c
        =
        
          c
          
            1
          
        
      
    
    {\displaystyle c=c_{1}}
  

  
    
      
        
          c
          
            −
            n
          
        
        =
        
          c
          
            n
            p
          
        
        =
        
          c
          
            n
          
          
            p
          
        
      
    
    {\displaystyle c_{-n}=c_{np}=c_{n}^{p}}
  

  
    
      
        
          c
          
            n
          
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
        
           for 
        
        n
        ∈
        
          Z
        
      
    
    {\displaystyle c_{n}\in GF(p^{2}){\text{ for }}n\in \mathbb {Z} }
  

  
    
      
        
          c
          
            u
            +
            v
          
        
        =
        
          c
          
            u
          
        
        
          c
          
            v
          
        
        −
        
          c
          
            v
          
          
            p
          
        
        
          c
          
            u
            −
            v
          
        
        +
        
          c
          
            u
            −
            2
            v
          
        
        
           for 
        
        u
        ,
        v
        ∈
        
          Z
        
      
    
    {\displaystyle c_{u+v}=c_{u}c_{v}-c_{v}^{p}c_{u-v}+c_{u-2v}{\text{ for }}u,v\in \mathbb {Z} }
  

Either all 
  
    
      
        
          h
          
            j
          
        
      
    
    {\displaystyle h_{j}}
  
 have order dividing 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 and 
  
    
      
        >
        3
      
    
    {\displaystyle >3}
  
 or all 
  
    
      
        
          h
          
            j
          
        
      
    
    {\displaystyle h_{j}}
  
 are in 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
. In particular, 
  
    
      
        F
        (
        c
        ,
        X
        )
      
    
    {\displaystyle F(c,X)}
  
 is irreducible if and only if its roots have order diving 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 and 
  
    
      
        >
        3
      
    
    {\displaystyle >3}
  
.

  
    
      
        F
        (
        c
        ,
        X
        )
      
    
    {\displaystyle F(c,X)}
  
 is reducible over 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 if and only if 
  
    
      
        
          c
          
            p
            +
            1
          
        
        ∈
        G
        F
        (
        p
        )
      
    
    {\displaystyle c_{p+1}\in GF(p)}
  

Lemma
Let 
  
    
      
        c
        ,
        
         
        
          c
          
            n
            −
            1
          
        
        ,
        
          c
          
            n
          
        
        ,
        
          c
          
            n
            +
            1
          
        
      
    
    {\displaystyle c,\!\ c_{n-1},c_{n},c_{n+1}}
  
 be given.

Computing 
  
    
      
        
          c
          
            2
            n
          
        
        =
        
          c
          
            n
          
          
            2
          
        
        −
        2
        
          c
          
            n
          
          
            p
          
        
      
    
    {\displaystyle c_{2n}=c_{n}^{2}-2c_{n}^{p}}
  
 takes two multiplication in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.
Computing 
  
    
      
        
          c
          
            n
            +
            2
          
        
        =
        
          c
          
            n
            +
            1
          
        
        ⋅
        c
        −
        
          c
          
            p
          
        
        ⋅
        
          c
          
            n
          
        
        +
        
          c
          
            n
            −
            1
          
        
      
    
    {\displaystyle c_{n+2}=c_{n+1}\cdot c-c^{p}\cdot c_{n}+c_{n-1}}
  
 takes four multiplication in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.
Computing 
  
    
      
        
          c
          
            2
            n
            −
            1
          
        
        =
        
          c
          
            n
            −
            1
          
        
        ⋅
        
          c
          
            n
          
        
        −
        
          c
          
            p
          
        
        ⋅
        
          c
          
            n
          
          
            p
          
        
        +
        
          c
          
            n
            +
            1
          
          
            p
          
        
      
    
    {\displaystyle c_{2n-1}=c_{n-1}\cdot c_{n}-c^{p}\cdot c_{n}^{p}+c_{n+1}^{p}}
  
 takes four multiplication in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.
Computing 
  
    
      
        
          c
          
            2
            n
            +
            1
          
        
        =
        
          c
          
            n
            +
            1
          
        
        ⋅
        
          c
          
            n
          
        
        −
        c
        ⋅
        
          c
          
            n
          
          
            p
          
        
        +
        
          c
          
            n
            −
            1
          
          
            p
          
        
      
    
    {\displaystyle c_{2n+1}=c_{n+1}\cdot c_{n}-c\cdot c_{n}^{p}+c_{n-1}^{p}}
  
 takes four multiplication in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.
Definition Let 
  
    
      
        
          S
          
            n
          
        
        (
        c
        )
        =
        (
        
          c
          
            n
            −
            1
          
        
        ,
        
          c
          
            n
          
        
        ,
        
          c
          
            n
            +
            1
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{n}(c)=(c_{n-1},c_{n},c_{n+1})\in GF(p^{2})^{3}}
  
.
Algorithm 1 for computation of 
  
    
      
        
          S
          
            n
          
        
        (
        c
        )
      
    
    {\displaystyle S_{n}(c)}
  
 given 
  
    
      
        n
      
    
    {\displaystyle n}
  
 and 
  
    
      
        c
      
    
    {\displaystyle c}
  

If 
  
    
      
        n
        <
        0
      
    
    {\displaystyle n<0}
  
 apply this algorithm to 
  
    
      
        −
        n
      
    
    {\displaystyle -n}
  
 and 
  
    
      
        c
      
    
    {\displaystyle c}
  
, and apply Property 2 to the resulting value.
If 
  
    
      
        n
        =
        0
      
    
    {\displaystyle n=0}
  
, then 
  
    
      
        
          S
          
            0
          
        
        (
        c
        )
        
         
        =
        (
        
          c
          
            p
          
        
        ,
        3
        ,
        c
        )
      
    
    {\displaystyle S_{0}(c)\!\ =(c^{p},3,c)}
  
.
If 
  
    
      
        n
        =
        1
      
    
    {\displaystyle n=1}
  
, then 
  
    
      
        
          S
          
            1
          
        
        (
        c
        )
        
         
        =
        (
        3
        ,
        c
        ,
        
          c
          
            2
          
        
        −
        2
        
          c
          
            p
          
        
        )
      
    
    {\displaystyle S_{1}(c)\!\ =(3,c,c^{2}-2c^{p})}
  
.
If 
  
    
      
        n
        =
        2
      
    
    {\displaystyle n=2}
  
, use the computation of 
  
    
      
        
          c
          
            n
            +
            2
          
        
        =
        
          c
          
            n
            +
            1
          
        
        ⋅
        c
        −
        
          c
          
            p
          
        
        ⋅
        
          c
          
            n
          
        
        +
        
          c
          
            n
            −
            1
          
        
      
    
    {\displaystyle c_{n+2}=c_{n+1}\cdot c-c^{p}\cdot c_{n}+c_{n-1}}
  
 and 
  
    
      
        
          S
          
            1
          
        
        (
        c
        )
      
    
    {\displaystyle S_{1}(c)}
  
 to find 
  
    
      
        
          c
          
            3
          
        
      
    
    {\displaystyle c_{3}}
  
 and thereby 
  
    
      
        
          S
          
            2
          
        
        (
        c
        )
      
    
    {\displaystyle S_{2}(c)}
  
.
If 
  
    
      
        n
        >
        2
      
    
    {\displaystyle n>2}
  
, to compute 
  
    
      
        
          S
          
            n
          
        
        (
        c
        )
      
    
    {\displaystyle S_{n}(c)}
  
 define

  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            i
          
        
        (
        c
        )
        =
        
          S
          
            2
            i
            +
            1
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{i}(c)=S_{2i+1}(c)}
  

and 
  
    
      
        
          
            
              m
              ¯
            
          
        
        =
        n
      
    
    {\displaystyle {\bar {m}}=n}
  
 if n is odd and 
  
    
      
        
          
            
              m
              ¯
            
          
        
        =
        n
        −
        1
      
    
    {\displaystyle {\bar {m}}=n-1}
  
 otherwise. Let 
  
    
      
        
          
            
              m
              ¯
            
          
        
        =
        2
        m
        +
        1
        ,
        k
        =
        1
      
    
    {\displaystyle {\bar {m}}=2m+1,k=1}
  
 and compute 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            k
          
        
        (
        c
        )
        =
        
          S
          
            3
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{k}(c)=S_{3}(c)}
  
 using the Lemma above and 
  
    
      
        
          S
          
            2
          
        
        (
        c
        )
      
    
    {\displaystyle S_{2}(c)}
  
. Let further

  
    
      
        m
        =
        
          ∑
          
            j
            =
            0
          
          
            r
          
        
        
          m
          
            j
          
        
        
          2
          
            j
          
        
      
    
    {\displaystyle m=\sum _{j=0}^{r}m_{j}2^{j}}
  

with 
  
    
      
        
          m
          
            j
          
        
        ∈
        
          0
          ,
          1
        
      
    
    {\displaystyle m_{j}\in {0,1}}
  
 and 
  
    
      
        
          m
          
            r
          
        
        =
        1
      
    
    {\displaystyle m_{r}=1}
  
. For 
  
    
      
        j
        =
        r
        −
        1
        ,
        r
        −
        2
        ,
        .
        .
        .
        ,
        0
      
    
    {\displaystyle j=r-1,r-2,...,0}
  
 in succession, do the following:
If 
  
    
      
        
          m
          
            j
          
        
        =
        0
      
    
    {\displaystyle m_{j}=0}
  
, use 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            k
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{k}(c)}
  
 to compute 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            2
            k
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{2k}(c)}
  
.
If 
  
    
      
        
          m
          
            j
          
        
        =
        1
      
    
    {\displaystyle m_{j}=1}
  
, use 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            k
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{k}(c)}
  
 to compute 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            2
            k
            +
            1
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{2k+1}(c)}
  
.
Replace 
  
    
      
        k
      
    
    {\displaystyle k}
  
 by 
  
    
      
        2
        k
        +
        
          m
          
            j
          
        
      
    
    {\displaystyle 2k+m_{j}}
  
.
When these iterations finish, 
  
    
      
        k
        =
        m
      
    
    {\displaystyle k=m}
  
 and 
  
    
      
        
          S
          
            
              
                m
                ¯
              
            
          
        
        (
        c
        )
        =
        
          
            
              
                S
                ¯
              
            
          
          
            m
          
        
        (
        c
        )
      
    
    {\displaystyle S_{\bar {m}}(c)={\bar {S}}_{m}(c)}
  
. If n is even use 
  
    
      
        
          S
          
            
              
                m
                ¯
              
            
          
        
        (
        c
        )
      
    
    {\displaystyle S_{\bar {m}}(c)}
  
 to compute 
  
    
      
        
          
            
              
                S
                ¯
              
            
          
          
            m
            +
            1
          
        
        (
        c
        )
      
    
    {\displaystyle {\bar {S}}_{m+1}(c)}
  
.


== Parameter selection ==


=== Finite field and subgroup size selection ===
In order to take advantage of the above described representations of elements with their traces and furthermore ensure sufficient security, that will be discussed below, we need to find primes 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
, where 
  
    
      
        p
      
    
    {\displaystyle p}
  
 denotes the characteristic of the field 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 with 
  
    
      
        p
        ≡
        2
         
        
          mod
        
         
        3
      
    
    {\displaystyle p\equiv 2\ {\text{mod}}\ 3}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is the size of the subgroup, such that 
  
    
      
        q
      
    
    {\displaystyle q}
  
 divides 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
.
We denote with 
  
    
      
        P
      
    
    {\displaystyle P}
  
 and 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
 the sizes of 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 in bits. To achieve  security comparable to 1024-bit RSA, we should choose 
  
    
      
        6
        P
      
    
    {\displaystyle 6P}
  
 about 1024, i.e. 
  
    
      
        P
        ≈
        170
      
    
    {\displaystyle P\approx 170}
  
 and 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
 can be around 160.
A first easy algorithm to compute such primes 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is the next Algorithm A:
Algorithm A

Find 
  
    
      
        r
        ∈
        
          Z
        
      
    
    {\displaystyle r\in \mathbb {Z} }
  
 such that 
  
    
      
        q
        =
        
          r
          
            2
          
        
        −
        r
        +
        1
      
    
    {\displaystyle q=r^{2}-r+1}
  
 is a 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
-bit prime.
Find 
  
    
      
        k
        ∈
        
          Z
        
      
    
    {\displaystyle k\in \mathbb {Z} }
  
 such that 
  
    
      
        p
        =
        r
        +
        k
        ⋅
        q
      
    
    {\displaystyle p=r+k\cdot q}
  
 is a 
  
    
      
        P
      
    
    {\displaystyle P}
  
-bit prime with 
  
    
      
        p
        ≡
        2
         
        
          mod
        
         
        3
      
    
    {\displaystyle p\equiv 2\ {\text{mod}}\ 3}
  
.
Correctness of Algorithm A:
It remains to check that 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
 because all the other necessary properties are obviously satisfied per definition of 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
. We easily see that 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
        =
        
          r
          
            2
          
        
        +
        2
        r
        k
        q
        +
        
          k
          
            2
          
        
        
          q
          
            2
          
        
        −
        r
        −
        k
        q
        +
        1
        =
        
          r
          
            2
          
        
        −
        r
        +
        1
        +
        q
        (
        2
        r
        k
        +
        
          k
          
            2
          
        
        q
        −
        k
        )
        =
        q
        (
        1
        +
        2
        r
        k
        +
        
          k
          
            2
          
        
        q
        −
        k
        )
      
    
    {\displaystyle p^{2}-p+1=r^{2}+2rkq+k^{2}q^{2}-r-kq+1=r^{2}-r+1+q(2rk+k^{2}q-k)=q(1+2rk+k^{2}q-k)}
  
 which implies that 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
.
Algorithm A is very fast and can be used to find primes 
  
    
      
        p
      
    
    {\displaystyle p}
  
 that satisfy a degree-two polynomial with small coefficients. Such 
  
    
      
        p
      
    
    {\displaystyle p}
  
 lead to fast arithmetic operations in 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
.
In particular if the search for 
  
    
      
        k
      
    
    {\displaystyle k}
  
 is restricted to 
  
    
      
        k
        =
        1
      
    
    {\displaystyle k=1}
  
, which means looking for an 
  
    
      
        r
      
    
    {\displaystyle r}
  
 such that both 
  
    
      
        
          r
          
            2
          
        
        −
        r
        +
        1
        
           and 
        
        
          r
          
            2
          
        
        +
        1
      
    
    {\displaystyle r^{2}-r+1{\text{ and }}r^{2}+1}
  
 are prime and such that 
  
    
      
        
          r
          
            2
          
        
        +
        1
        ≡
        2
        
           mod 
        
        3
      
    
    {\displaystyle r^{2}+1\equiv 2{\text{ mod }}3}
  
, the primes 
  
    
      
        p
      
    
    {\displaystyle p}
  
 have this nice form.
Note that in this case 
  
    
      
        r
      
    
    {\displaystyle r}
  
 must be even and 
  
    
      
        r
        ≡
        1
        
           mod 
        
        4
      
    
    {\displaystyle r\equiv 1{\text{ mod }}4}
  
.
On the other hand, such 
  
    
      
        p
      
    
    {\displaystyle p}
  
 may be undesirable from a security point of view because they may make an attack with the Discrete Logarithm variant of the Number Field Sieve easier.
The following Algorithm B doesn't have this disadvantage, but it also doesn't have the fast arithmetic modulo 
  
    
      
        p
      
    
    {\displaystyle p}
  
 Algorithm A has in that case.
Algorithm B

Select a 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
-bit prime 
  
    
      
        q
      
    
    {\displaystyle q}
  
 so that 
  
    
      
        q
        ≡
        7
         
        
          mod
        
         
        12
      
    
    {\displaystyle q\equiv 7\ {\text{mod}}\ 12}
  
.
Find the roots 
  
    
      
        
          r
          
            1
          
        
      
    
    {\displaystyle r_{1}}
  
 and 
  
    
      
        
          r
          
            2
          
        
      
    
    {\displaystyle r_{2}}
  
 of 
  
    
      
        
          X
          
            2
          
        
        −
        X
        +
        1
         
        
          mod
        
         
        q
      
    
    {\displaystyle X^{2}-X+1\ {\text{mod}}\ q}
  
.
Find a  
  
    
      
        k
        ∈
        
          Z
        
      
    
    {\displaystyle k\in \mathbb {Z} }
  
 such that 
  
    
      
        p
        =
        
          r
          
            i
          
        
        +
        k
        ⋅
        q
      
    
    {\displaystyle p=r_{i}+k\cdot q}
  
 is a 
  
    
      
        P
      
    
    {\displaystyle P}
  
-bit prime with 
  
    
      
        p
        ≡
        2
         
        
          mod
        
         
        3
      
    
    {\displaystyle p\equiv 2\ {\text{mod}}\ 3}
  
 for 
  
    
      
        i
        ∈
        {
        1
        ,
        2
        }
      
    
    {\displaystyle i\in \{1,2\}}
  

Correctness of Algorithm B:
Since we chose  
  
    
      
        q
        ≡
        7
         
        
          mod
        
         
        12
      
    
    {\displaystyle q\equiv 7\ {\text{mod}}\ 12}
  
 it follows immediately that  
  
    
      
        q
        ≡
        1
         
        
          mod
        
         
        3
      
    
    {\displaystyle q\equiv 1\ {\text{mod}}\ 3}
  
 (because  
  
    
      
        7
        ≡
        1
         
        
          mod
        
         
        3
      
    
    {\displaystyle 7\equiv 1\ {\text{mod}}\ 3}
  
 and  
  
    
      
        3
        ∣
        12
      
    
    {\displaystyle 3\mid 12}
  
). From that and quadratic reciprocity we can deduce that  
  
    
      
        
          r
          
            1
          
        
      
    
    {\displaystyle r_{1}}
  
 and 
  
    
      
        
          r
          
            2
          
        
      
    
    {\displaystyle r_{2}}
  
 exist.
To check that 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
 we consider again 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 for 
  
    
      
        
          r
          
            i
          
        
        ∈
        {
        1
        ,
        2
        }
      
    
    {\displaystyle r_{i}\in \{1,2\}}
  
 and get that 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
        =
        
          r
          
            i
          
          
            2
          
        
        +
        2
        
          r
          
            i
          
        
        k
        q
        +
        
          k
          
            2
          
        
        
          q
          
            2
          
        
        −
        
          r
          
            i
          
        
        −
        k
        q
        +
        1
        =
        
          r
          
            i
          
          
            2
          
        
        −
        
          r
          
            i
          
        
        +
        1
        +
        q
        (
        2
        r
        k
        +
        
          k
          
            2
          
        
        q
        −
        k
        )
        =
        q
        (
        2
        r
        k
        +
        
          k
          
            2
          
        
        q
        −
        k
        )
      
    
    {\displaystyle p^{2}-p+1=r_{i}^{2}+2r_{i}kq+k^{2}q^{2}-r_{i}-kq+1=r_{i}^{2}-r_{i}+1+q(2rk+k^{2}q-k)=q(2rk+k^{2}q-k)}
  
, since 
  
    
      
        
          r
          
            1
          
        
      
    
    {\displaystyle r_{1}}
  
 and 
  
    
      
        
          r
          
            2
          
        
      
    
    {\displaystyle r_{2}}
  
 are roots of 
  
    
      
        
          X
          
            2
          
        
        −
        X
        +
        1
      
    
    {\displaystyle X^{2}-X+1}
  
 and hence 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
.


=== Subgroup selection ===
In the last paragraph we have chosen the sizes 
  
    
      
        p
      
    
    {\displaystyle p}
  
 and 
  
    
      
        q
      
    
    {\displaystyle q}
  
 of the finite field 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 and the multiplicative subgroup of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF(p^{6})^{*}}
  
, now we have to find a subgroup 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
 of 
  
    
      
        G
        F
        
         
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF\!\ (p^{6})^{*}}
  
 for some 
  
    
      
        g
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle g\in GF(p^{6})}
  
 such that 
  
    
      
        ∣
        
        
        ⟨
        g
        ⟩
        
        
        ∣=
        q
      
    
    {\displaystyle \mid \!\!\langle g\rangle \!\!\mid =q}
  
.
However, we do not need to find an explicit 
  
    
      
        g
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle g\in GF(p^{6})}
  
, it suffices to find an element 
  
    
      
        c
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle c\in GF(p^{2})}
  
 such that 
  
    
      
        c
        =
        T
        r
        (
        g
        )
      
    
    {\displaystyle c=Tr(g)}
  
 for an element 
  
    
      
        g
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle g\in GF(p^{6})}
  
 of order 
  
    
      
        q
      
    
    {\displaystyle q}
  
. But, given 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
, a generator 
  
    
      
        g
      
    
    {\displaystyle g}
  
 of the XTR (sub)group can be found by determining any root of 
  
    
      
        F
        (
        T
        r
        (
        g
        )
        ,
         
        X
        )
      
    
    {\displaystyle F(Tr(g),\ X)}
  
 which has been defined above.
To find such a 
  
    
      
        c
      
    
    {\displaystyle c}
  
 we can take a look at property 5 of 
  
    
      
        F
        (
        c
        ,
         
        X
        )
      
    
    {\displaystyle F(c,\ X)}
  
 here stating that the roots of 
  
    
      
        F
        (
        c
        ,
         
        X
        )
      
    
    {\displaystyle F(c,\ X)}
  
 have an order dividing 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 if and only if 
  
    
      
        F
        (
        c
        ,
         
        X
        )
      
    
    {\displaystyle F(c,\ X)}
  
 is irreducible. After finding such 
  
    
      
        c
      
    
    {\displaystyle c}
  
 we need to check if it really is of order 
  
    
      
        q
      
    
    {\displaystyle q}
  
, but first we focus on how to select 
  
    
      
        c
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle c\in GF(p^{2})}
  
 such that 
  
    
      
        F
        (
        c
        ,
         
        X
        )
      
    
    {\displaystyle F(c,\ X)}
  
 is irreducible.
An initial approach is to select 
  
    
      
        c
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
        ∖
        G
        F
        (
        p
        )
      
    
    {\displaystyle c\in GF(p^{2})\backslash GF(p)}
  
 randomly which is justified by the next lemma.
Lemma: For a randomly selected 
  
    
      
        c
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle c\in GF(p^{2})}
  
 the probability that 
  
    
      
        F
        (
        c
        ,
         
        X
        )
        =
        
          X
          
            3
          
        
        −
        c
        
          X
          
            2
          
        
        +
        
          c
          
            p
          
        
        X
        −
        1
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
        [
        X
        ]
      
    
    {\displaystyle F(c,\ X)=X^{3}-cX^{2}+c^{p}X-1\in GF(p^{2})[X]}
  
 is irreducible is about one third.
Now the basic algorithm to find a suitable 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
 is as follows:
Outline of the algorithm

Pick a random 
  
    
      
        c
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
        ∖
        G
        F
        (
        p
        )
      
    
    {\displaystyle c\in GF(p^{2})\backslash GF(p)}
  
.
If 
  
    
      
        F
        (
        c
        ,
         
        X
        )
      
    
    {\displaystyle F(c,\ X)}
  
 is reducible, then return to Step 1.
Use Algorithm 1 to compute 
  
    
      
        d
        =
        
          c
          
            (
            
              p
              
                2
              
            
            −
            p
            +
            1
            )
            
              /
            
            q
          
        
      
    
    {\displaystyle d=c_{(p^{2}-p+1)/q}}
  
.
If 
  
    
      
        d
      
    
    {\displaystyle d}
  
 is not of order 
  
    
      
        q
      
    
    {\displaystyle q}
  
, return to Step 1.
Let 
  
    
      
        T
        r
        (
        g
        )
        =
        d
      
    
    {\displaystyle Tr(g)=d}
  
.
It turns out that this algorithm indeed computes an element of 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 that equals 
  
    
      
        T
        r
        (
        g
        )
      
    
    {\displaystyle Tr(g)}
  
 for some 
  
    
      
        g
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle g\in GF(p^{6})}
  
 of order 
  
    
      
        q
      
    
    {\displaystyle q}
  
.
More details to the algorithm, its correctness, runtime and the proof of the Lemma can be found in "An overview of the XTR public key system" in.


== Cryptographic schemes ==
In this section it is explained how the concepts above using traces of elements can be applied to cryptography. In general, XTR can be used in any cryptosystem that relies on the (subgroup) Discrete Logarithm problem. Two important applications of XTR are the Diffie–Hellman key exchange and the ElGamal encryption. We will start first with Diffie–Hellman.


=== XTR-DH key agreement ===
We suppose that both Alice and Bob have access to the XTR public key data 
  
    
      
        
          (
          
            p
            ,
            q
            ,
            T
            r
            (
            g
            )
          
          )
        
      
    
    {\displaystyle \left(p,q,Tr(g)\right)}
  
 and intend to agree on a shared secret key 
  
    
      
        K
      
    
    {\displaystyle K}
  
. They can do this by using the following XTR version of the Diffie–Hellman key exchange:

Alice picks 
  
    
      
        a
        ∈
        
          Z
        
      
    
    {\displaystyle a\in \mathbb {Z} }
  
 randomly with 
  
    
      
        1
        <
        a
        <
        q
        −
        2
      
    
    {\displaystyle 1<a<q-2}
  
, computes with Algorithm 1 
  
    
      
        
          S
          
            a
          
        
        (
        T
        r
        (
        g
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                a
                −
                1
              
            
            )
            ,
            T
            r
            (
            
              g
              
                a
              
            
            )
            ,
            T
            r
            (
            
              g
              
                a
                +
                1
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{a}(Tr(g))=\left(Tr(g^{a-1}),Tr(g^{a}),Tr(g^{a+1})\right)\in GF(p^{2})^{3}}
  
 and sends 
  
    
      
        T
        r
        (
        
          g
          
            a
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{a})\in GF(p^{2})}
  
 to Bob.
Bob receives 
  
    
      
        T
        r
        (
        
          g
          
            a
          
        
        )
      
    
    {\displaystyle Tr(g^{a})}
  
 from Alice, selects at random 
  
    
      
        b
        ∈
        
          Z
        
      
    
    {\displaystyle b\in \mathbb {Z} }
  
 with 
  
    
      
        1
        <
        b
        <
        q
        −
        2
      
    
    {\displaystyle 1<b<q-2}
  
, applies Algorithm 1 to compute 
  
    
      
        
          S
          
            b
          
        
        (
        T
        r
        (
        g
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                b
                −
                1
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
                +
                1
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{b}(Tr(g))=\left(Tr(g^{b-1}),Tr(g^{b}),Tr(g^{b+1})\right)\in GF(p^{2})^{3}}
  
 and sends  
  
    
      
        T
        r
        (
        
          g
          
            b
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{b})\in GF(p^{2})}
  
 to Alice.
Alice receives 
  
    
      
        T
        r
        (
        
          g
          
            b
          
        
        )
      
    
    {\displaystyle Tr(g^{b})}
  
 from Bob, computes with Algorithm 1 
  
    
      
        
          S
          
            a
          
        
        (
        T
        r
        (
        
          g
          
            b
          
        
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                (
                a
                −
                1
                )
                b
              
            
            )
            ,
            T
            r
            (
            
              g
              
                a
                b
              
            
            )
            ,
            T
            r
            (
            
              g
              
                (
                a
                +
                1
                )
                b
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{a}(Tr(g^{b}))=\left(Tr(g^{(a-1)b}),Tr(g^{ab}),Tr(g^{(a+1)b})\right)\in GF(p^{2})^{3}}
  
 and determines 
  
    
      
        K
      
    
    {\displaystyle K}
  
 based on 
  
    
      
        T
        r
        (
        
          g
          
            a
            b
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{ab})\in GF(p^{2})}
  
.
Bob analogously applies Algorithm 1 to compute 
  
    
      
        
          S
          
            b
          
        
        (
        T
        r
        (
        
          g
          
            a
          
        
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                a
                (
                b
                −
                1
                )
              
            
            )
            ,
            T
            r
            (
            
              g
              
                a
                b
              
            
            )
            ,
            T
            r
            (
            
              g
              
                a
                (
                b
                +
                1
                )
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{b}(Tr(g^{a}))=\left(Tr(g^{a(b-1)}),Tr(g^{ab}),Tr(g^{a(b+1)})\right)\in GF(p^{2})^{3}}
  
 and also determines 
  
    
      
        K
      
    
    {\displaystyle K}
  
 based on 
  
    
      
        T
        r
        (
        
          g
          
            a
            b
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{ab})\in GF(p^{2})}
  
.


=== XTR ElGamal encryption ===
For the ElGamal encryption we suppose now that Alice is the owner of the XTR public key data 
  
    
      
        (
        p
        ,
        q
        ,
        T
        r
        (
        g
        )
        )
      
    
    {\displaystyle (p,q,Tr(g))}
  
 and that she has selected a secret integer 
  
    
      
        k
      
    
    {\displaystyle k}
  
, computed 
  
    
      
        T
        r
        (
        
          g
          
            k
          
        
        )
      
    
    {\displaystyle Tr(g^{k})}
  
 and published the result.
Given Alice's XTR public key data 
  
    
      
        
          (
          
            p
            ,
            q
            ,
            T
            r
            (
            g
            )
            ,
            T
            r
            (
            
              g
              
                k
              
            
            )
          
          )
        
      
    
    {\displaystyle \left(p,q,Tr(g),Tr(g^{k})\right)}
  
, Bob can encrypt a message 
  
    
      
        M
      
    
    {\displaystyle M}
  
, intended for Alice, using the following XTR version of the ElGamal encryption:

Bob selects randomly a 
  
    
      
        b
        ∈
        
          Z
        
      
    
    {\displaystyle b\in \mathbb {Z} }
  
 with 
  
    
      
        1
        <
        b
        <
        q
        −
        2
      
    
    {\displaystyle 1<b<q-2}
  
 and computes with Algorithm 1 
  
    
      
        
          S
          
            b
          
        
        (
        T
        r
        (
        g
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                b
                −
                1
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
                +
                1
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{b}(Tr(g))=\left(Tr(g^{b-1}),Tr(g^{b}),Tr(g^{b+1})\right)\in GF(p^{2})^{3}}
  
.
Bob next applies Algorithm 1 to compute 
  
    
      
        
          S
          
            b
          
        
        (
        T
        r
        (
        
          g
          
            k
          
        
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                (
                b
                −
                1
                )
                k
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
                k
              
            
            )
            ,
            T
            r
            (
            
              g
              
                (
                b
                +
                1
                )
                k
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{b}(Tr(g^{k}))=\left(Tr(g^{(b-1)k}),Tr(g^{bk}),Tr(g^{(b+1)k})\right)\in GF(p^{2})^{3}}
  
.
Bob determines a symmetric encryption key 
  
    
      
        K
      
    
    {\displaystyle K}
  
 based on 
  
    
      
        T
        r
        (
        
          g
          
            b
            k
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{bk})\in GF(p^{2})}
  
.
Bob uses an agreed upon symmetric encryption method with key 
  
    
      
        K
      
    
    {\displaystyle K}
  
 to encrypt his message 
  
    
      
        M
      
    
    {\displaystyle M}
  
, resulting in the encryption 
  
    
      
        E
      
    
    {\displaystyle E}
  
.
Bob sends 
  
    
      
        (
        T
        r
        (
        
          g
          
            b
          
        
        )
        ,
         
        E
        )
      
    
    {\displaystyle (Tr(g^{b}),\ E)}
  
 to Alice.
Upon receipt of 
  
    
      
        (
        T
        r
        (
        
          g
          
            b
          
        
        )
        ,
         
        E
        )
      
    
    {\displaystyle (Tr(g^{b}),\ E)}
  
, Alice decrypts the message in the following way:

Alice computes 
  
    
      
        
          S
          
            k
          
        
        (
        T
        r
        (
        
          g
          
            b
          
        
        )
        )
        =
        
          (
          
            T
            r
            (
            
              g
              
                b
                (
                k
                −
                1
                )
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
                k
              
            
            )
            ,
            T
            r
            (
            
              g
              
                b
                (
                k
                +
                1
                )
              
            
            )
          
          )
        
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        
          )
          
            3
          
        
      
    
    {\displaystyle S_{k}(Tr(g^{b}))=\left(Tr(g^{b(k-1)}),Tr(g^{bk}),Tr(g^{b(k+1)})\right)\in GF(p^{2})^{3}}
  
.
Alice determines the symmetric key 
  
    
      
        K
      
    
    {\displaystyle K}
  
 based on 
  
    
      
        T
        r
        (
        
          g
          
            b
            k
          
        
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle Tr(g^{bk})\in GF(p^{2})}
  
.
Alice uses the agreed upon symmetric encryption method with key 
  
    
      
        K
      
    
    {\displaystyle K}
  
 to decrypt 
  
    
      
        E
      
    
    {\displaystyle E}
  
, resulting in the original message 
  
    
      
        M
      
    
    {\displaystyle M}
  
.
The here described encryption scheme is based on a common hybrid version of the ElGamal encryption, where the secret key 
  
    
      
        K
      
    
    {\displaystyle K}
  
 is obtained by an asymmetric public key system and then the message is encrypted with a symmetric key encryption method Alice and Bob agreed to.
In the more traditional ElGamal encryption the message is restricted to the key space, which would here be 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
, because 
  
    
      
        T
        r
        (
        g
        )
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
         
        ∀
        p
        ∈
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle Tr(g)\in GF(p^{2})\ \forall p\in GF(p^{6})^{*}}
  
. The encryption in this case is the multiplication of the message with the key, which is an invertible operation in the key space 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
.
Concretely this means if Bob wants to encrypt a message 
  
    
      
        M
        
        
           
          ′
        
      
    
    {\displaystyle M\!\ '}
  
, first he has to convert it into an element 
  
    
      
        M
      
    
    {\displaystyle M}
  
 of 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
 and then compute the encrypted message 
  
    
      
        E
      
    
    {\displaystyle E}
  
 as 
  
    
      
        E
        =
        K
        ⋅
        M
        ∈
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle E=K\cdot M\in GF(p^{2})}
  
.
Upon receipt of the encrypted message 
  
    
      
        E
      
    
    {\displaystyle E}
  
 Alice can recover the original message 
  
    
      
        M
      
    
    {\displaystyle M}
  
 by computing 
  
    
      
        M
        =
        E
        ⋅
        
          K
          
            −
            1
          
        
      
    
    {\displaystyle M=E\cdot K^{-1}}
  
, where 
  
    
      
        
          K
          
            −
            1
          
        
      
    
    {\displaystyle K^{-1}}
  
 is the inverse of 
  
    
      
        K
      
    
    {\displaystyle K}
  
 in 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
.


== Security ==
In order to say something about the security properties of the above explained XTR encryption scheme, first it is important to check the security of the XTR group, which means how hard it is to solve the Discrete Logarithm problem there. The next part will then state the equivalency between the Discrete Logarithm problem in the XTR group and the XTR version of the discrete logarithm problem, using only the traces of elements.


=== Discrete logarithms in a general ===
  
    
      
        G
        F
        
          (
          
            p
            
              t
            
          
          )
        
      
    
    {\displaystyle GF\left(p^{t}\right)}
  

Let now 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 be a multiplicative group of order 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
. The security of the Diffie–Hellman protocol in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 relies on the Diffie–Hellman (DH) problem of computing 
  
    
      
        
          γ
          
            x
            y
          
        
        
           given 
        
        γ
        ,
        
          γ
          
            x
          
        
        
           and 
        
        
          γ
          
            y
          
        
      
    
    {\displaystyle \gamma ^{xy}{\text{ given }}\gamma ,\gamma ^{x}{\text{ and }}\gamma ^{y}}
  
. We write 
  
    
      
        D
        H
        (
        
          γ
          
            x
          
        
        ,
         
        
          γ
          
            y
          
        
        )
        =
        
          γ
          
            x
            y
          
        
      
    
    {\displaystyle DH(\gamma ^{x},\ \gamma ^{y})=\gamma ^{xy}}
  
.
There are two other problems related to the DH problem. The first one is the Diffie–Hellman Decision (DHD) problem to determine if 
  
    
      
        c
        =
        D
        H
        (
        a
        ,
        b
        )
      
    
    {\displaystyle c=DH(a,b)}
  
 for given 
  
    
      
        a
        ,
        b
        ,
        c
        ∈
        ⟨
        γ
        ⟩
      
    
    {\displaystyle a,b,c\in \langle \gamma \rangle }
  
 and the second one is the Discrete Logarithm (DL) problem to find 
  
    
      
        x
        =
        D
        L
        (
        a
        )
      
    
    {\displaystyle x=DL(a)}
  
 for a given 
  
    
      
        a
        =
        
          γ
          
            x
          
        
        ∈
        ⟨
        γ
        ⟩
        
           with 
        
        0
        ≤
        x
        <
        ω
      
    
    {\displaystyle a=\gamma ^{x}\in \langle \gamma \rangle {\text{ with }}0\leq x<\omega }
  
.
The DL problem is at least as difficult as the DH problem and it is generally assumed that if the DL problem in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 is intractable, then so are the other two.
Given the prime factorization of 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
 the DL problem in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 can be reduced to the DL problem in all subgroups of 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 with prime order due to the Pohlig–Hellman algorithm. Hence 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
 can safely be assumed to be prime.
For a subgroup 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 of prime order 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
 of the multiplicative group 
  
    
      
        G
        F
        
          
            (
            
              p
              
                t
              
            
            )
          
          
            ∗
          
        
      
    
    {\displaystyle GF\left(p^{t}\right)^{*}}
  
 of an extension field 
  
    
      
        G
        F
        (
        
          p
          
            t
          
        
        )
      
    
    {\displaystyle GF(p^{t})}
  
 of 
  
    
      
        G
        F
        (
        p
        )
      
    
    {\displaystyle GF(p)}
  
 for some 
  
    
      
        t
      
    
    {\displaystyle t}
  
, there are now two possible ways to attack the system. One can either focus on the whole multiplicative group or on the subgroup. To attack the multiplicative group the best known method is the Discrete Logarithm variant of the Number Field Sieve or alternatively in the subgroup one can use one of several methods that take 
  
    
      
        
          
            O
          
        
        (
        
          
            ω
          
        
        )
      
    
    {\displaystyle {\mathcal {O}}({\sqrt {\omega }})}
  
 operations in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
, such as Pollard's rho method.
For both approaches the difficulty of the DL problem in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 depends on the size of the minimal surrounding subfield of 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 and on the size of its prime order 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
. If 
  
    
      
        G
        F
        
          (
          
            p
            
              t
            
          
          )
        
      
    
    {\displaystyle GF\left(p^{t}\right)}
  
 itself is the minimal surrounding subfield of 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 and 
  
    
      
        ω
      
    
    {\displaystyle \omega }
  
 is sufficiently large, then the DL problem in 
  
    
      
        ⟨
        γ
        ⟩
      
    
    {\displaystyle \langle \gamma \rangle }
  
 is as hard as the general DL problem in 
  
    
      
        G
        F
        
          (
          
            p
            
              t
            
          
          )
        
      
    
    {\displaystyle GF\left(p^{t}\right)}
  
.
The XTR parameters are now chosen in such a way that 
  
    
      
        p
      
    
    {\displaystyle p}
  
 is not small, 
  
    
      
        q
      
    
    {\displaystyle q}
  
 is sufficiently large and 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
 cannot be embedded in a true subfield of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
, since 
  
    
      
        q
        ∣
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle q\mid p^{2}-p+1}
  
 and 
  
    
      
        
          p
          
            2
          
        
        −
        p
        +
        1
      
    
    {\displaystyle p^{2}-p+1}
  
 is a divisor of 
  
    
      
        ∣
        
        G
        F
        (
        
          p
          
            6
          
        
        
          )
          
            ∗
          
        
        
        ∣=
        
          p
          
            6
          
        
        −
        1
      
    
    {\displaystyle \mid \!GF(p^{6})^{*}\!\mid =p^{6}-1}
  
, but it does not divide 
  
    
      
        
          p
          
            s
          
        
        −
        1
        
           for 
        
        s
        ∈
        {
        1
        ,
        2
        ,
        3
        }
      
    
    {\displaystyle p^{s}-1{\text{ for }}s\in \{1,2,3\}}
  
 and thus 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
 cannot be a subgroup of 
  
    
      
        G
        F
        
         
        (
        
          p
          
            s
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle GF\!\ (p^{s})^{*}}
  
 for 
  
    
      
        s
        ∈
        {
        1
        ,
        2
        ,
        3
        }
      
    
    {\displaystyle s\in \{1,2,3\}}
  
.
It follows that the DL problem in the XTR group may be assumed as hard as the DL problem in 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
.


=== Security of XTR ===
Cryptographic protocols that are based on Discrete Logarithms can use many different types of subgroups like groups of points of elliptic curves or subgroups of the multiplicative group of a finite field like the XTR group.
As we have seen above the XTR versions of the Diffie–Hellman and ElGamal encryption protocol replace using elements of the XTR group by using their traces.
This means that the security of the XTR versions of these encryption schemes is no longer based on the original DH, DHD or DL problems.
Therefore, the XTR versions of those problems need to be defined and we will see that they are equivalent (in the sense of the next definition) to the original problems.
Definitions:

We define the XTR-DH problem as the problem of computing 
  
    
      
        T
        r
        (
        
          g
          
            x
            y
          
        
        )
      
    
    {\displaystyle Tr(g^{xy})}
  
 given 
  
    
      
        T
        r
        (
        
          g
          
            x
          
        
        )
      
    
    {\displaystyle Tr(g^{x})}
  
 and 
  
    
      
        T
        r
        (
        
          g
          
            y
          
        
        )
      
    
    {\displaystyle Tr(g^{y})}
  
 and we write 
  
    
      
        X
        D
        H
        (
        
          g
          
            x
          
        
        ,
         
        
          g
          
            y
          
        
        )
        =
        
          g
          
            x
            y
          
        
      
    
    {\displaystyle XDH(g^{x},\ g^{y})=g^{xy}}
  
.
The XTR-DHD problem is the problem of determining whether 
  
    
      
        X
        D
        H
        (
        a
        ,
        b
        )
        =
        c
      
    
    {\displaystyle XDH(a,b)=c}
  
 for 
  
    
      
        a
        ,
        b
        ,
        c
        ∈
        T
        r
        (
        ⟨
        g
        ⟩
        )
      
    
    {\displaystyle a,b,c\in Tr(\langle g\rangle )}
  
.
Given 
  
    
      
        a
        ∈
        T
        r
        (
        ⟨
        g
        ⟩
        )
      
    
    {\displaystyle a\in Tr(\langle g\rangle )}
  
, the XTR-DL problem is to find 
  
    
      
        x
        =
        X
        D
        L
        (
        a
        )
      
    
    {\displaystyle x=XDL(a)}
  
, i.e. 
  
    
      
        0
        ≤
        x
        <
        q
      
    
    {\displaystyle 0\leq x<q}
  
 such that 
  
    
      
        a
        =
        T
        r
        (
        
          g
          
            x
          
        
        )
      
    
    {\displaystyle a=Tr(g^{x})}
  
.
 We say that problem 
  
    
      
        
          
            A
          
        
      
    
    {\displaystyle {\mathcal {A}}}
  
 is (a,b)-equivalent to problem 
  
    
      
        
          
            B
          
        
      
    
    {\displaystyle {\mathcal {B}}}
  
, if any instance of problem 
  
    
      
        
          
            A
          
        
      
    
    {\displaystyle {\mathcal {A}}}
  
 (or 
  
    
      
        
          
            B
          
        
      
    
    {\displaystyle {\mathcal {B}}}
  
) can be solved by at most a (or b) calls to an algorithm solving problem 
  
    
      
        
          
            B
          
        
      
    
    {\displaystyle {\mathcal {B}}}
  
 (or 
  
    
      
        
          
            A
          
        
      
    
    {\displaystyle {\mathcal {A}}}
  
).
After introducing the XTR versions of these problems the next theorem is an important result telling us the connection between the XTR and the non-XTR problems, which are in fact equivalent. This implies that the XTR representation of elements with their traces is, as can be seen above, faster by a factor of 3 than the usual representation without compromising security.
Theorem   The following equivalencies hold:

i. The XTR-DL problem is (1,1)-equivalent to the DL problem in 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
.
ii. The XTR-DH problem is (1,2)-equivalent to the DH problem in 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
.
iii. The XTR-DHD problem is (3,2)-equivalent to the DHD problem in 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
.
This means that an algorithm solving either XTR-DL, XTR-DH or XTR-DHD with non-negligible probability can be transformed into an algorithm solving the corresponding non-XTR problem DL, DH or DHD with non-negligible probability and vice versa.
In particular part ii. implies that determining the small XTR-DH key (being an element of 
  
    
      
        G
        F
        (
        
          p
          
            2
          
        
        )
      
    
    {\displaystyle GF(p^{2})}
  
) is as hard as determining the whole DH key (being an element of 
  
    
      
        G
        F
        (
        
          p
          
            6
          
        
        )
      
    
    {\displaystyle GF(p^{6})}
  
 ) in the representation group 
  
    
      
        ⟨
        g
        ⟩
      
    
    {\displaystyle \langle g\rangle }
  
.


== References ==