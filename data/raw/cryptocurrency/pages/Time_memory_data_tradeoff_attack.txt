A time/memory/data tradeoff attack is a type of cryptographic attack where an attacker tries to achieve a situation similar to the space–time tradeoff but with the additional parameter of data, representing the amount of data available to the attacker. An attacker balances or reduces one or two of those parameters in favor of the other one or two. This type of attack is very difficult, so most of the ciphers and encryption schemes in use were not designed to resist it.


== History ==
Tradeoff attacks on symmetric cryptosystems date back to 1980, when Martin Hellman suggested a time/memory tradeoff method to break block ciphers with 
  
    
      
        N
      
    
    {\displaystyle N}
  
 possible keys in time 
  
    
      
        T
      
    
    {\displaystyle T}
  
 and memory 
  
    
      
        M
      
    
    {\displaystyle M}
  
 related by the tradeoff curve 
  
    
      
        T
        
          
            M
            
              2
            
          
        
        =
        
          
            N
            
              2
            
          
        
      
    
    {\displaystyle T{M^{2}}={N^{2}}}
  
 where 
  
    
      
        1
        ≤
        T
        ≤
        N
      
    
    {\displaystyle 1\leq T\leq N}
  
. Later, in 1995, Babbage and Golic devised a different tradeoff attack for stream ciphers with a new bound such that 
  
    
      
        T
        M
        =
        N
      
    
    {\displaystyle TM=N}
  
 for 
  
    
      
        1
        ≤
        T
        ≤
        D
      
    
    {\displaystyle 1\leq T\leq D}
  
 where 
  
    
      
        D
      
    
    {\displaystyle D}
  
 is the output data available to the cryptanalyst at real time.


== Attack mechanics ==
This attack is a special version of the general cryptanalytic time/memory tradeoff attack, which has two main phases:

Preprocessing:  During this phase, the attacker explores the structure of the cryptosystem and is allowed to record their findings in large tables. This can take a long time.
Realtime:  In this phase, the cryptanalyst is granted real data obtained from a specific unknown key. They then try to use this data with the precomputed table from the preprocessing phase to find the particular key in as little time as possible.
Any time/memory/data tradeoff attack has the following parameters:

  
    
      
        N
      
    
    {\displaystyle N}
  
 search space size

  
    
      
        P
      
    
    {\displaystyle P}
  
 time required for the preprocessing phase

  
    
      
        T
      
    
    {\displaystyle T}
  
 time required for the realtime phase

  
    
      
        M
      
    
    {\displaystyle M}
  
 amount of memory available to the attacker

  
    
      
        D
      
    
    {\displaystyle D}
  
 amount of realtime data available to the attacker


== Hellman's attack on block ciphers ==
For block ciphers, let 
  
    
      
        N
      
    
    {\displaystyle N}
  
 be the total number of possible keys and also assume the number of possible plaintexts and ciphertexts to be 
  
    
      
        N
      
    
    {\displaystyle N}
  
. Also let the given data be a single ciphertext block of a specific plaintext counterpart. If we consider the mapping from the key 
  
    
      
        x
      
    
    {\displaystyle x}
  
 to the ciphertext 
  
    
      
        y
      
    
    {\displaystyle y}
  
 as a random permutation function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 over an 
  
    
      
        N
      
    
    {\displaystyle N}
  
 point space, and if this function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is invertible; we need to find the inverse of this function 
  
    
      
        
          
            f
          
          
            −
            1
          
        
        (
        y
        )
        =
        x
      
    
    {\displaystyle {f}^{-1}(y)=x}
  
.
Hellman's technique to invert this function:

During the preprocessing stage
Try to cover the 
  
    
      
        N
      
    
    {\displaystyle N}
  
 point space by an 
  
    
      
        m
        ×
        t
      
    
    {\displaystyle m\times t}
  
 rectangular matrix that is constructed by iterating the function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 on 
  
    
      
        m
      
    
    {\displaystyle m}
  
 random starting points in 
  
    
      
        N
      
    
    {\displaystyle N}
  
 for 
  
    
      
        t
      
    
    {\displaystyle t}
  
 times. The start points are the leftmost column in the matrix and the end points are the rightmost column. Then store the pairs of start and end points in increasing order of end points values.

Now, only one matrix will not be able to cover the whole 
  
    
      
        N
      
    
    {\displaystyle N}
  
 space. But if we add more rows to the matrix, we will end up with a huge matrix that includes recovered points more than once. So, we find the critical value of 
  
    
      
        m
      
    
    {\displaystyle m}
  
 at which the matrix contains exactly 
  
    
      
        m
      
    
    {\displaystyle m}
  
 different points. Consider the first 
  
    
      
        m
      
    
    {\displaystyle m}
  
 paths from start points to end points are all disjoint with 
  
    
      
        m
        t
      
    
    {\displaystyle mt}
  
 points, such that the next path which has at least one common point with one of those previous paths and includes exactly 
  
    
      
        t
      
    
    {\displaystyle t}
  
 points. Those two sets of 
  
    
      
        m
        t
      
    
    {\displaystyle mt}
  
 and 
  
    
      
        t
      
    
    {\displaystyle t}
  
 points are disjoint by the birthday paradox if we make sure that 
  
    
      
        t
        ⋅
        m
        t
        ≤
        N
      
    
    {\displaystyle t\cdot mt\leq N}
  
. We achieve this by enforcing the matrix stopping rule: 
  
    
      
        m
        
          
            t
          
          
            2
          
        
        =
        N
      
    
    {\displaystyle m{t}^{2}=N}
  
.
Nevertheless, an 
  
    
      
        m
        ×
        t
      
    
    {\displaystyle m\times t}
  
 matrix with 
  
    
      
        m
        
          
            t
          
          
            2
          
        
        =
        N
      
    
    {\displaystyle m{t}^{2}=N}
  
 covers a portion 
  
    
      
        m
        t
        
          /
        
        N
        =
        1
        
          /
        
        t
      
    
    {\displaystyle mt/N=1/t}
  
 of the whole space. To generate 
  
    
      
        t
      
    
    {\displaystyle t}
  
 to cover the whole space, we use a variant of 
  
    
      
        f
      
    
    {\displaystyle f}
  
 defined: 
  
    
      
        
          
            f
          
          
            i
          
        
        (
        x
        )
        =
        
          
            h
          
          
            i
          
        
        (
        f
        (
        x
        )
        )
      
    
    {\displaystyle {f}_{i}(x)={h}_{i}(f(x))}
  
 and 
  
    
      
        
          
            h
          
          
            i
          
        
      
    
    {\displaystyle {h}_{i}}
  
 is simple out manipulation such as reordering of bits of 
  
    
      
        f
        (
        x
        )
      
    
    {\displaystyle f(x)}
  
  (refer to the original paper for more details). And one can see that the total preprocessing time is 
  
    
      
        P
        ≈
        N
      
    
    {\displaystyle P\approx N}
  
. Also 
  
    
      
        M
        =
        m
        t
      
    
    {\displaystyle M=mt}
  
 since we only need to store the pairs of start and end points and we have 
  
    
      
        t
      
    
    {\displaystyle t}
  
 matrices each of 
  
    
      
        m
      
    
    {\displaystyle m}
  
 pairs.
During the real time phase
The total computation required to find 
  
    
      
        
          f
          
            −
            1
          
        
        (
        y
        )
      
    
    {\displaystyle f^{-1}(y)}
  
 is 
  
    
      
        T
        =
        
          t
          
            2
          
        
      
    
    {\displaystyle T=t^{2}}
  
 because we need to do 
  
    
      
        t
      
    
    {\displaystyle t}
  
 inversion attempts as it is likely to be covered by one matrix and each of the attempts takes 
  
    
      
        t
      
    
    {\displaystyle t}
  
 evaluations of some 
  
    
      
        
          f
          
            i
          
        
      
    
    {\displaystyle f_{i}}
  
. The optimum tradeoff curve is obtained by using the matrix stopping rule 
  
    
      
        m
        
          
            t
          
          
            2
          
        
        =
        N
      
    
    {\displaystyle m{t}^{2}=N}
  
 and we get 
  
    
      
        T
        
          
            M
            
              2
            
          
        
        =
        
          
            N
            
              2
            
          
        
        ,
        P
        =
        N
        ,
        D
        =
        1
      
    
    {\displaystyle T{M^{2}}={N^{2}},P=N,D=1}
  
 and choice of 
  
    
      
        T
      
    
    {\displaystyle T}
  
 and 
  
    
      
        M
      
    
    {\displaystyle M}
  
 depends on the cost of each resource.
According to Hellman, if the block cipher at hand has the property that the mapping from its key to cipher text is a random permutation function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 over an 
  
    
      
        N
      
    
    {\displaystyle N}
  
 point space, and if this 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is invertible, the tradeoff relationship becomes much better: 
  
    
      
        T
        M
        =
        N
      
    
    {\displaystyle TM=N}
  
.


== Babbage-and-Golic attack on stream ciphers ==
For stream ciphers, N is specified by the number of internal states of the bit generator—probably different from the number of keys. D is the count of the first pseudorandom bits produced from the generator. Finally, the attacker's goal is to find one of the actual internal states of the bit generator to be able to run the generator from this point on to generate the rest of the key. Associate each of the possible N internal states of the bit generator with the corresponding string that consists of the first 
  
    
      
        log
        ⁡
        (
        N
        )
      
    
    {\displaystyle \log(N)}
  
 bits obtained by running the generator from that state by the mapping 
  
    
      
        f
        (
        x
        )
        =
        y
      
    
    {\displaystyle f(x)=y}
  
 from states x to output prefixes y. This previous mapping is considered a random function over the N points common space. To invert this function, an attacker establishes the following.

During the preprocessing phase, pick M random 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle {x}_{i}}
  
 states and compute their corresponding 
  
    
      
        
          
            y
          
          
            i
          
        
      
    
    {\displaystyle {y}_{i}}
  
 output prefixes.
Store the pairs 
  
    
      
        (
        
          
            x
          
          
            i
          
        
        ,
        
          
            y
          
          
            i
          
        
        )
      
    
    {\displaystyle ({x}_{i},{y}_{i})}
  
 in increasing order of 
  
    
      
        
          
            y
          
          
            i
          
        
      
    
    {\displaystyle {y}_{i}}
  
 in a large table.
During the realtime phase, you have 
  
    
      
        D
        +
        log
        ⁡
        (
        N
        )
        −
        1
      
    
    {\displaystyle D+\log(N)-1}
  
 generated bits. Calculate from them all D possible combinations of 
  
    
      
        
          
            y
          
          
            1
          
        
        ,
        
          
            y
          
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          
            y
          
          
            D
          
        
        ,
      
    
    {\displaystyle {y}_{1},{y}_{2},...,{y}_{D},}
  
 of consecutive bits with length 
  
    
      
        log
        ⁡
        (
        N
        )
      
    
    {\displaystyle \log(N)}
  
.
Search for each 
  
    
      
        
          
            y
          
          
            i
          
        
      
    
    {\displaystyle {y}_{i}}
  
 in the generated table which takes log time.
If you have a hit, this 
  
    
      
        
          
            y
          
          
            i
          
        
      
    
    {\displaystyle {y}_{i}}
  
 corresponds to an internal state 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle {x}_{i}}
  
 of the bit generator from which you can forward run the generator to obtain the rest of the key.
By the Birthday Paradox, you are guaranteed that two subsets of a space with N points have an intersection if the product of their sizes is greater than N.
This result from the Birthday attack gives the condition 
  
    
      
        D
        M
        =
        N
      
    
    {\displaystyle DM=N}
  
 with attack time 
  
    
      
        T
        =
        D
      
    
    {\displaystyle T=D}
  
 and preprocessing time 
  
    
      
        P
        =
        M
      
    
    {\displaystyle P=M}
  
 which is just a particular point on the tradeoff curve 
  
    
      
        T
        M
        =
        N
      
    
    {\displaystyle TM=N}
  
. We can generalize this relation if we ignore some of the available data at real time and we are able to reduce T from T=D to 1 and the general tradeoff curve eventually becomes 
  
    
      
        T
        M
        =
        N
      
    
    {\displaystyle TM=N}
  
 with 
  
    
      
        1
        ≤
        T
        ≤
        D
      
    
    {\displaystyle 1\leq T\leq D}
  
 and 
  
    
      
        P
        =
        M
      
    
    {\displaystyle P=M}
  
.


== Shamir and Biryukov's attack on stream ciphers ==
This novel idea introduced in 2000 combines the Hellman and Babbage-and-Golic tradeoff attacks to achieve a new tradeoff curve with better bounds for stream cipher cryptoanalysis. Hellman's block cipher technique can be applied to a stream cipher by using the same idea of covering the 
  
    
      
        N
      
    
    {\displaystyle N}
  
 points space through matrices obtained from multiple variants 
  
    
      
        
          f
          
            i
          
        
      
    
    {\displaystyle f_{i}}
  
 of the function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 which is the mapping of internal states to output prefixes. Recall that this tradeoff attack on stream cipher is successful if any of the given 
  
    
      
        D
      
    
    {\displaystyle D}
  
 output prefixes is found in any of the matrices covering 
  
    
      
        N
      
    
    {\displaystyle N}
  
. This cuts the number of covered points by the matrices from 
  
    
      
        N
      
    
    {\displaystyle N}
  
 to 
  
    
      
        N
        
          /
        
        D
      
    
    {\displaystyle N/D}
  
 points. This is done by reducing the number of matrices from 
  
    
      
        t
      
    
    {\displaystyle t}
  
 to 
  
    
      
        t
        
          /
        
        D
      
    
    {\displaystyle t/D}
  
 while keeping 
  
    
      
        m
      
    
    {\displaystyle m}
  
 as large as possible (but this requires 
  
    
      
        t
        ≥
        D
      
    
    {\displaystyle t\geq D}
  
 to have at least one table).
For this new attack, we have 
  
    
      
        M
        =
        m
        t
        
          /
        
        D
      
    
    {\displaystyle M=mt/D}
  
 because we reduced the number of matrices to 
  
    
      
        t
        
          /
        
        D
      
    
    {\displaystyle t/D}
  
 and the same for the preprocessing time 
  
    
      
        P
        =
        N
        
          /
        
        D
      
    
    {\displaystyle P=N/D}
  
. The realtime required for the attack is 
  
    
      
        T
        =
        (
        t
        
          /
        
        D
        )
        ⋅
        t
        ⋅
        D
        =
        
          t
          
            2
          
        
      
    
    {\displaystyle T=(t/D)\cdot t\cdot D=t^{2}}
  
 which is the product of the number of matrices, length of each iteration and number of available data points at attack time.
Eventually, we again use the matrix stopping rule to obtain the tradeoff curve 
  
    
      
        T
        
          M
          
            2
          
        
        
          D
          
            2
          
        
        =
        
          t
          
            2
          
        
        ⋅
        (
        
          m
          
            2
          
        
        
          t
          
            2
          
        
        
          /
        
        
          D
          
            2
          
        
        )
        ⋅
        
          D
          
            2
          
        
        =
        
          m
          
            2
          
        
        
          t
          
            4
          
        
        =
        
          N
          
            2
          
        
      
    
    {\displaystyle TM^{2}D^{2}=t^{2}\cdot (m^{2}t^{2}/D^{2})\cdot D^{2}=m^{2}t^{4}=N^{2}}
  
 for 
  
    
      
        
          D
          
            2
          
        
        ≤
        T
        ≤
        N
      
    
    {\displaystyle D^{2}\leq T\leq N}
  
 (because 
  
    
      
        t
        ≥
        D
      
    
    {\displaystyle t\geq D}
  
).


=== Attacks on stream ciphers with low sampling resistance ===
This attack, invented by Biryukov, Shamir, and Wagner, relies on a specific feature of some stream ciphers: that the bit generator undergoes only few changes in its internal state before producing the next output bit.
Therefore, we can enumerate those special states that generate 
  
    
      
        k
      
    
    {\displaystyle k}
  
 zero bits for small values of 
  
    
      
        k
      
    
    {\displaystyle k}
  
 at low cost. But when forcing large number of output bits to take specific values, this enumeration process become very expensive and difficult.
Now, we can define the sampling resistance of a stream cipher to be 
  
    
      
        R
        =
        
          2
          
            −
            k
          
        
      
    
    {\displaystyle R=2^{-k}}
  
 with 
  
    
      
        k
      
    
    {\displaystyle k}
  
 the maximum value which makes such enumeration feasible.
Let the stream cipher be of 
  
    
      
        N
        =
        
          2
          
            n
          
        
      
    
    {\displaystyle N=2^{n}}
  
 states each has a full name of 
  
    
      
        n
      
    
    {\displaystyle n}
  
 bits and a corresponding output name which is the first 
  
    
      
        n
      
    
    {\displaystyle n}
  
 bits in the output sequence of bits. If this stream cipher has sampling resistance 
  
    
      
        R
        =
        
          2
          
            −
            k
          
        
      
    
    {\displaystyle R=2^{-k}}
  
, then an efficient enumeration can use a short name of 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
  
 bits to define the special states of the generator. Each special state with 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
  
 short name has a corresponding short output name of 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
  
 bits which is the output sequence of the special state after removing the first 
  
    
      
        k
      
    
    {\displaystyle k}
  
 leading bits. Now, we are able to define a new mapping over a reduced space of 
  
    
      
        N
        R
        =
        
          2
          
            n
            −
            k
          
        
      
    
    {\displaystyle NR=2^{n-k}}
  
 points and this mapping is equivalent to the original mapping. If we let 
  
    
      
        D
        R
        ≥
        1
      
    
    {\displaystyle DR\geq 1}
  
, the realtime data available to the attacker is guaranteed to have at least one output of those special states. Otherwise, we relax the definition of special states to include more points. If we substitute for 
  
    
      
        D
      
    
    {\displaystyle D}
  
 by 
  
    
      
        D
        R
      
    
    {\displaystyle DR}
  
 and 
  
    
      
        N
      
    
    {\displaystyle N}
  
 by 
  
    
      
        N
        R
      
    
    {\displaystyle NR}
  
 in the new time/memory/data tradeoff attack by Shamir and Biryukov, we obtain the same tradeoff curve 
  
    
      
        T
        
          M
          
            2
          
        
        
          D
          
            2
          
        
        =
        
          N
          
            2
          
        
      
    
    {\displaystyle TM^{2}D^{2}=N^{2}}
  
 but with 
  
    
      
        (
        D
        R
        
          )
          
            2
          
        
        ≤
        T
        ≤
        N
        R
      
    
    {\displaystyle (DR)^{2}\leq T\leq NR}
  
. This is actually an improvement since we could relax the lower bound on 
  
    
      
        T
      
    
    {\displaystyle T}
  
 since 
  
    
      
        (
        D
        R
        
          )
          
            2
          
        
      
    
    {\displaystyle (DR)^{2}}
  
 can be small up to 
  
    
      
        1
      
    
    {\displaystyle 1}
  
 which means that our attack can be made faster. This technique reduces the number of expensive disk access operations from 
  
    
      
        t
      
    
    {\displaystyle t}
  
 to 
  
    
      
        t
        R
      
    
    {\displaystyle tR}
  
 since we will be accessing only the special 
  
    
      
        D
        R
      
    
    {\displaystyle DR}
  
 points, and makes the attack faster because of the reduced number of expensive disk operations.


== References ==